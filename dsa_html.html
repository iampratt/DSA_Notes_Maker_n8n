<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>DSA Notes</title>
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <style>
  body {
    font-family: 'Fira Code', monospace;
    background: #0f1117;
    color: #e0e0e0;
    padding: 40px;
    line-height: 1.7;
  }

  h2 {
    background: #1f1f1f;
    color: #00e0ff;
    padding: 14px 20px;
    border-left: 5px solid #00e0ff;
    font-size: 1.8em;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
    margin-bottom: 20px;
  }

  h3 {
    color: #ff6b6b;
    font-size: 1.5em;
    margin-top: 30px;
  }

  h4 {
    color: #64b5f6;
    font-size: 1.3em;
    margin-top: 20px;
  }

  pre {
    background: #1e1e2f;
    color: #dcdcdc;
    padding: 16px;
    border-radius: 8px;
    overflow-x: auto;
    font-size: 0.95em;
    margin-top: 10px;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
  }

  table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
    margin-top: 20px;
    background: #1a1a2e;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
  }

  th, td {
    padding: 12px 16px;
    border-bottom: 1px solid #2e2e3e;
  }

  th {
    background-color: #292b3e;
    color: #00e0ff;
    font-weight: bold;
    text-align: left;
  }

  td {
    color: #d6d6d6;
  }

  tr:last-child td {
    border-bottom: none;
  }

  hr {
    border: none;
    border-top: 1px solid #444;
    margin: 50px 0;
  }

  a:link, a:visited {
    color: #00e0ff;
    text-decoration: underline;
    transition: color 0.2s ease;
  }

  a:hover {
    color: #ff4081;
  }
</style>
</head>
<body>
  <h2>Arrays </h2>
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/find-the-duplicate-number/>Find the Duplicate Number</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given an array of integers `nums` containing `n + 1` integers where each integer is in the range `[1, n]` inclusive. 

There is only one repeated number in `nums`, return this repeated number.

You must solve the problem without modifying the array `nums` and use only constant extra space.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the array and for each element, check if it appears again later in the array. If it does, return the element. This approach uses nested loops.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int findDuplicate_brute_force(vector&lt;int&gt;&amp; nums) {
    for (int i = 0; i &lt; nums.size(); ++i) {
        for (int j = i + 1; j &lt; nums.size(); ++j) {
            if (nums[i] == nums[j]) {
                return nums[i];
            }
        }
    }
    return -1; // Should not reach here as per problem constraints.
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Floyd's Tortoise and Hare (Cycle Detection)</h5>
  <p>Treat the array as a linked list where the value at index `i` represents the next node. The duplicate number creates a cycle. Use Floyd's cycle-finding algorithm (tortoise and hare) to detect the cycle and find the entry point (duplicate).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int findDuplicate_floyd(vector&lt;int&gt;&amp; nums) {
    // Find the intersection point of the two runners.
    int slow = nums[0];
    int fast = nums[0];
    do {
        slow = nums[slow];
        fast = nums[nums[fast]];
    } while (slow != fast);

    // Find the "entrance" to the cycle.
    slow = nums[0];
    while (slow != fast) {
        slow = nums[slow];
        fast = nums[fast];
    }
    return slow;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) | <b>Space Complexity:</b> O(1)</p>
  <h5>‚û§ Binary Search</h5>
  <p>Use binary search on the range `[1, n]`. For each `mid` value, count the number of elements in the array that are less than or equal to `mid`. If the count is greater than `mid`, the duplicate must be in the range `[1, mid]`; otherwise, the duplicate must be in the range `[mid + 1, n]`.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int findDuplicate_binary_search(vector&lt;int&gt;&amp; nums) {
    int n = nums.size() - 1;
    int left = 1, right = n;
    while (left &lt; right) {
        int mid = left + (right - left) / 2;
        int count = 0;
        for (int num : nums) {
            if (num &lt;= mid) {
                count++;
            }
        }
        if (count &gt; mid) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log n) | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,3,4,2,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The number 2 is repeated.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [3,1,3,4,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The number 3 is repeated.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The number 1 is repeated.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The number 1 is repeated.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The constraints state that the array contains n+1 integers where each integer is in the range [1, n]. This guarantees a duplicate exists.  The Floyd's Cycle Detection algorithm is the most efficient in terms of time and space complexity. Binary search provides another valid solution but slightly slower. The brute-force solution should be avoided due to its time complexity.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/sort-colors/>Sort Colors</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given an array `nums` with `n` objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We use the integers 0, 1, and 2 to represent the colors red, white, and blue, respectively.

You must solve this problem without using the library's sort function.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves counting the occurrences of each color (0, 1, and 2) and then overwriting the array `nums` based on the counts. First, iterate through the array and count how many 0s, 1s, and 2s are present. Then, iterate through the array again.  Fill the array with the determined number of 0s first, then 1s, and finally 2s.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt

using namespace std;

void sortColors_BruteForce(vector&lt;int&gt;&amp; nums) {
    int count0 = 0, count1 = 0, count2 = 0;
    for (int num : nums) {
        if (num == 0) count0++;
        else if (num == 1) count1++;
        else count2++;
    }

    int index = 0;
    for (int i = 0; i &lt count0; i++) {
        nums[index++] = 0;
    }
    for (int i = 0; i &lt count1; i++) {
        nums[index++] = 1;
    }
    for (int i = 0; i &lt count2; i++) {
        nums[index++] = 2;
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the size of the input array. We iterate through the array three times. | <b>Space Complexity:</b> O(1). We use a constant amount of extra space.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Two-Pass Algorithm (Counting Sort)</h5>
  <p>This approach is essentially a more streamlined version of the brute-force. We still count the occurrences of each color in the first pass. In the second pass, we populate the array with the colors based on the counts. This achieves the sorting in-place.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt

using namespace std;

void sortColors_CountingSort(vector&lt;int&gt;&amp; nums) {
    int count0 = 0, count1 = 0, count2 = 0;
    for (int num : nums) {
        if (num == 0) count0++;
        else if (num == 1) count1++;
        else count2++;
    }

    int index = 0;
    for (int i = 0; i &lt count0; i++) {
        nums[index++] = 0;
    }
    for (int i = 0; i &lt count1; i++) {
        nums[index++] = 1;
    }
    for (int i = 0; i &lt count2; i++) {
        nums[index++] = 2;
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the size of the input array. We iterate through the array twice. | <b>Space Complexity:</b> O(1). We use a constant amount of extra space.</p>
  <h5>‚û§ One-Pass Algorithm (Dutch National Flag)</h5>
  <p>The Dutch National Flag algorithm uses three pointers: `low`, `mid`, and `high`.  `low` points to the beginning of the array, `high` points to the end, and `mid` iterates through the array.  If `nums[mid]` is 0, swap it with `nums[low]` and increment both `low` and `mid`. If `nums[mid]` is 1, just increment `mid`. If `nums[mid]` is 2, swap it with `nums[high]` and decrement `high`.  Do *not* increment `mid` after a swap with `nums[high]` because the swapped value might be 0 or 1 and needs to be checked.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt

using namespace std;

void sortColors_DutchNationalFlag(vector&lt;int&gt;&amp; nums) {
    int low = 0, mid = 0, high = nums.size() - 1;
    while (mid &lt= high) {
        if (nums[mid] == 0) {
            swap(nums[low], nums[mid]);
            low++;
            mid++;
        } else if (nums[mid] == 1) {
            mid++;
        } else {
            swap(nums[mid], nums[high]);
            high--;
        }
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the size of the input array. We iterate through the array at most once. | <b>Space Complexity:</b> O(1). We use a constant amount of extra space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [2,0,2,1,1,0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[0,0,1,1,2,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">After sorting, the array becomes [0, 0, 1, 1, 2, 2].</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [2,0,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[0,1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">After sorting, the array becomes [0, 1, 2].</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The array is already sorted.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The Dutch National Flag algorithm is the most efficient and preferred method because it sorts the array in-place with a single pass, offering optimal time complexity and space complexity.  Edge cases to consider include empty arrays and arrays with only one color.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/remove-duplicates-from-sorted-array/>Remove Duplicates from Sorted Array</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given a sorted array `nums`, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Return the number of unique elements in `nums`. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array `nums`. More formally, if there are `k` unique elements after removing the duplicates, then the first `k` elements of `nums` should hold the final result. It does not matter what you leave beyond the first `k` elements. Return `k`.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the array and use a set to keep track of unique elements. After iterating, overwrite the original array with the unique elements from the set.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

int removeDuplicates_brute_force(vector&lt;int&gt;&amp; nums) {
    set&lt;int&gt; unique_nums;
    for (int num : nums) {
        unique_nums.insert(num);
    }

    int k = 0;
    for (int num : unique_nums) {
        nums[k++] = num;
    }
    return k;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log n) - due to the set insertion and potential iteration. | <b>Space Complexity:</b> O(n) - for the set to store unique elements.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Two Pointers</h5>
  <p>Use two pointers, `i` (slow pointer) and `j` (fast pointer). `i` tracks the position to place the next unique element, and `j` iterates through the array. If `nums[j]` is different from `nums[i-1]`, then it's a unique element and we place it at `nums[i]` and increment `i`.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

int removeDuplicates_optimized(vector&lt;int&gt;&amp; nums) {
    if (nums.empty()) {
        return 0;
    }

    int i = 1;
    for (int j = 1; j &lt; nums.size(); j++) {
        if (nums[j] != nums[j - 1]) {
            nums[i++] = nums[j];
        }
    }
    return i;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) - single pass through the array. | <b>Space Complexity:</b> O(1) - constant extra space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The function should return 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the returned k (2).</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [0,0,1,1,1,2,2,3,3,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The function should return 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1, 2, 2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The function should return 2, with the first two elements of nums being 1 and 2 respectively.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Empty input array.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The input array `nums` is sorted. This is crucial for the two-pointer approach to work efficiently. Consider the edge case of an empty or a single-element input array. The problem explicitly asks to modify the array in-place, so solutions using extra space to store the result are less efficient.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/set-matrix-zeroes/>Set Matrix Zeroes</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given an m x n integer matrix, if an element is 0, set its entire row and column to 0. You must do it in place.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the matrix. If an element is 0, mark its entire row and column for zeroing out later. Use extra space (e.g., two boolean arrays) to keep track of the rows and columns that need to be zeroed. Finally, iterate through the matrix again and set elements to 0 based on the marked rows and columns.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

void setZeroes_bruteForce(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
    int rows = matrix.size();
    int cols = matrix[0].size();

    vector&lt;bool&gt; zeroRows(rows, false);
    vector&lt;bool&gt; zeroCols(cols, false);

    // Mark rows and columns to be zeroed
    for (int i = 0; i &lt rows; ++i) {
        for (int j = 0; j &lt cols; ++j) {
            if (matrix[i][j] == 0) {
                zeroRows[i] = true;
                zeroCols[j] = true;
            }
        }
    }

    // Zero out rows
    for (int i = 0; i &lt rows; ++i) {
        if (zeroRows[i]) {
            for (int j = 0; j &lt cols; ++j) {
                matrix[i][j] = 0;
            }
        }
    }

    // Zero out columns
    for (int j = 0; j &lt cols; ++j) {
        if (zeroCols[j]) {
            for (int i = 0; i &lt rows; ++i) {
                matrix[i][j] = 0;
            }
        }
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(M * N * (M + N)), where M is the number of rows and N is the number of columns. (O(M*N) to find zeros, O(M*N) for each zero found) | <b>Space Complexity:</b> O(M + N), for the boolean arrays to track rows and columns to be zeroed.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized (Constant Space)</h5>
  <p>Use the first row and first column of the matrix to store the information about which rows and columns need to be zeroed. Use two boolean variables (e.g., `firstRowZero` and `firstColZero`) to indicate whether the first row and first column should be zeroed. Iterate through the matrix and check for zeros. If an element is 0, set the corresponding element in the first row and first column to 0.  Iterate through the matrix again, starting from index (1,1), set the row and column to zero if the corresponding element in the first row/column is 0. Finally, based on `firstRowZero` and `firstColZero`, zero the first row and first column if needed.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

void setZeroes_optimized(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
    int rows = matrix.size();
    int cols = matrix[0].size();
    bool firstRowZero = false;
    bool firstColZero = false;

    // Check if first row and first column have zeros
    for (int j = 0; j &lt cols; ++j) {
        if (matrix[0][j] == 0) {
            firstRowZero = true;
            break;
        }
    }
    for (int i = 0; i &lt rows; ++i) {
        if (matrix[i][0] == 0) {
            firstColZero = true;
            break;
        }
    }

    // Use first row and first column to mark zeroed rows/cols
    for (int i = 1; i &lt rows; ++i) {
        for (int j = 1; j &lt cols; ++j) {
            if (matrix[i][j] == 0) {
                matrix[i][0] = 0;
                matrix[0][j] = 0;
            }
        }
    }

    // Zero out rows and columns based on the first row/col
    for (int i = 1; i &lt rows; ++i) {
        for (int j = 1; j &lt cols; ++j) {
            if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                matrix[i][j] = 0;
            }
        }
    }

    // Zero out first row and first column if needed
    if (firstRowZero) {
        for (int j = 0; j &lt cols; ++j) {
            matrix[0][j] = 0;
        }
    }
    if (firstColZero) {
        for (int i = 0; i &lt rows; ++i) {
            matrix[i][0] = 0;
        }
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(M * N), where M is the number of rows and N is the number of columns. (Three passes through the matrix). | <b>Space Complexity:</b> O(1), constant space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,1,1],[1,0,1],[1,1,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,0,1],[0,0,0],[1,0,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The element at matrix[1][1] is 0. Therefore, the entire second row and the second column should be zeroed.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0,1,2,0],[3,4,5,2],[1,3,1,5]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The elements at matrix[0][0] and matrix[0][3] are 0, thus first row and first and last columns become zeros.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,2,3,4],[5,0,7,8],[0,10,11,12],[13,14,15,0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0,0,3,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The elements at matrix[1][1], matrix[2][0] and matrix[3][3] are zeros.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The in-place constraint is crucial. 
2. The optimized approach cleverly uses the first row and column to store state information, avoiding extra space.  
3. Edge cases:  Empty matrix (handled implicitly), matrix with only one row or column (consider the first row or column as the indicator).  If matrix[0][0] == 0, the first row and first column should be zeroed based on the optimization. Consider the order of operations.  Setting the rows and columns to zero must follow the marking process so as not to overwrite any needed zeroing.
4. The `firstRowZero` and `firstColZero` flags are important for handling the first row and column correctly. Without these flags, the solution won't work correctly when there's a zero in either the first row or first column. 
5. Ensure to iterate from index 1,1 in the optimized approach.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/move-zeroes/>Move Zeroes</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given an integer array `nums`, move all 0's to the end of it while maintaining the relative order of the non-zero elements.  Do this in-place without making a copy of the array. Minimize the total number of operations.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the array. If an element is not zero, place it in a new array.  Count the number of zeros.  Create a new array with the non-zero elements followed by the zeros.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Brute Force Approach - Not In-Place (as required by the problem)
void moveZeroesBruteForce(vector&lt;int&gt;&amp; nums) {
    vector&lt;int&gt; nonZeroElements;
    int zeroCount = 0;

    for (int num : nums) {
        if (num != 0) {
            nonZeroElements.push_back(num);
        } else {
            zeroCount++;
        }
    }

    for (int i = 0; i &lt; zeroCount; ++i) {
        nonZeroElements.push_back(0);
    }

    nums = nonZeroElements;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the number of elements in the array.  We iterate through the array twice. | <b>Space Complexity:</b> O(n), We create a new array to store the non-zero elements.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Two Pointers (In-place)</h5>
  <p>Use two pointers: `j` to track the position where the next non-zero element should be placed, and `i` to iterate through the array. If `nums[i]` is non-zero, move it to `nums[j]` and increment `j`. After the iteration, fill the remaining positions from `j` to the end of the array with zeros.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

void moveZeroesOptimized(vector&lt;int&gt;&amp; nums) {
    int j = 0; // Tracks the position for the next non-zero element
    for (int i = 0; i &lt; nums.size(); ++i) {
        if (nums[i] != 0) {
            nums[j] = nums[i];
            if (i != j) {
                nums[i] = 0;
            }
            j++;
        }
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the number of elements in the array. We iterate through the array once. | <b>Space Complexity:</b> O(1), we are modifying the array in-place and using a constant amount of extra space.</p>
  <h5>‚û§ Two Pointers (Simplified)</h5>
  <p>Similar to the previous approach, but only swaps elements when `nums[i]` is not zero and `i != j`.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

void moveZeroesOptimizedSimplified(vector&lt;int&gt;&amp; nums) {
    int j = 0; // Tracks the position for the next non-zero element
    for (int i = 0; i &lt; nums.size(); ++i) {
        if (nums[i] != 0) {
            if (i != j) {
                swap(nums[i], nums[j]);
            }
            j++;
        }
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the number of elements in the array. We iterate through the array once. | <b>Space Complexity:</b> O(1), we are modifying the array in-place and using a constant amount of extra space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [0,1,0,3,12]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,3,12,0,0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The non-zero elements are moved to the beginning, and the zeros are moved to the end.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No changes needed as there is only one zero element.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The non-zero elements are already in the correct position.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [0,0,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,0,0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The non-zero element is moved to the beginning.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to solving this problem efficiently is to perform the operations in-place, using only constant extra space. The two-pointer approach is the optimal solution. The simplified two-pointer approach minimizes operations. Consider edge cases with all zeros, or all non-zeros.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock/>Best Time to Buy and Sell Stock</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible buy and sell days and calculate the profit. Keep track of the maximum profit found so far.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int max_profit = 0;
        int n = prices.size();
        for (int i = 0; i &lt n - 1; ++i) {
            for (int j = i + 1; j &lt n; ++j) {
                int profit = prices[j] - prices[i];
                max_profit = max(max_profit, profit);
            }
        }
        return max_profit;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ One-Pass</h5>
  <p>Iterate through the prices once, keeping track of the minimum price seen so far (buy price) and the maximum profit calculated so far. On each day, calculate the potential profit (sell price - buy price) and update the maximum profit if necessary. Also update the minimum buy price if a lower price is encountered.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int min_price = INT_MAX;
        int max_profit = 0;
        for (int i = 0; i &lt prices.size(); i++) {
            min_price = min(min_price, prices[i]);
            max_profit = max(max_profit, prices[i] - min_price);
        }
        return max_profit;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n) | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">prices = [7,1,5,3,6,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as the sell day must be after the buy day.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">prices = [7,6,4,3,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">In this case, no transaction is done, i.e., max profit = 0.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">prices = [2,4,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Buy at 2 and sell at 4.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to solving this problem efficiently is to track the minimum buy price seen so far and calculate the maximum profit at each step. The buy day must always come before the sell day. If prices are decreasing, the profit would be zero.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/chocolate-distribution-problem/>Chocolate Distribution Problem</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given an array of `n` integers representing the packets of chocolate and an integer `m` representing the number of students, the task is to distribute chocolate packets among `m` students such that:

1.  Each student gets one packet.
2.  The difference between the maximum and minimum chocolates given to the students is minimized.

Return the minimum difference.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves generating all possible combinations of selecting `m` packets out of `n`. For each combination, calculate the difference between the maximum and minimum packet sizes and then find the minimum among all these differences.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int findMinDiffBruteForce(vector&lt;int&gt; &amp;a, int m) {
    int n = a.size();
    if (m &gt; n || n == 0 || m == 0) return -1; // Edge cases

    sort(a.begin(), a.end()); // Sort to make it easier to pick combinations

    int minDiff = INT_MAX;
    for (int i = 0; i &lt;= n - m; i++) {
        minDiff = min(minDiff, a[i + m - 1] - a[i]);
    }
    return minDiff;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log n + (n-m+1)) . The sorting is O(n log n), and the loop for finding the min difference takes O(n-m+1) in the worst case | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach (Sorting and Sliding Window)</h5>
  <p>1.  **Sort the array:** Sort the given array of chocolate packet sizes in ascending order.
2.  **Sliding Window:** Iterate through the sorted array using a sliding window of size `m`.  For each window, calculate the difference between the largest and smallest values (i.e., the difference between the rightmost and leftmost elements of the window).
3.  **Minimize the difference:** Keep track of the minimum difference found so far and update it as you slide the window.
4. **Return the minimum difference**</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int findMinDiff(vector&lt;int&gt; &amp;a, int m) {
    int n = a.size();
    if (m &gt; n || n == 0 || m == 0) return -1; // Edge cases

    sort(a.begin(), a.end()); // Sort the array

    int minDiff = INT_MAX;
    for (int i = 0; i &lt;= n - m; i++) {
        minDiff = min(minDiff, a[i + m - 1] - a[i]); // Calculate and update minDiff
    }
    return minDiff;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log n) - dominates the sorting step | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr[] = {3, 4, 1, 9, 56, 7, 9, 12}, m = 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The subarray {3, 4, 7, 9, 9} has the minimum difference between the maximum and minimum, which is 9 - 3 = 6.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr[] = {7, 3, 2, 4, 9, 12, 56}, m = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The subarray {2, 3, 4} has the minimum difference, which is 4-2 = 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr[] = {12, 4, 7, 9, 2, 23, 25, 41, 30, 40, 28, 42, 30, 10, 5}, m = 7</td>
        <td style="border: 1px solid #ccc; padding: 6px;">10</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The subarray {4, 5, 7, 9, 10, 12, 23} results in a difference of 23-4 = 19. While the sub array {23,25,28,30,30,40,41} results in a difference of 41 - 23 = 18. Considering {2, 4, 5, 7, 9, 10, 12} results in a difference of 12 - 2 = 10. </td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  **Edge Cases:** Handle cases where `m` is greater than `n`, or when either `m` or `n` is zero.
2.  **Sorting is Crucial:** Sorting the array is essential for the efficient sliding window approach.
3. **Time Complexity:** The optimal solution has a time complexity of O(n log n) due to sorting. Brute force has an additional complexity of O(n-m+1). 
4. **Constraints:** Pay attention to the constraints specified in the problem description, especially the range of values in the input array and the values of `m` and `n`. In this case we consider packets to be positive integers.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/two-sum/>Two Sum</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given an array of integers `nums` and an integer `target`, return *indices of the two numbers such that they add up to `target`*. You may assume that each input would have *exactly one solution*, and you may not use the *same* element twice. You can return the answer in any order.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the array. For each element, iterate through the rest of the array to find a pair that sums up to the target.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string solve_brute_force(vector&lt;int&gt;&amp; nums, int target) {
    vector&lt;int&gt; result;
    int n = nums.size();
    for (int i = 0; i &lt; n - 1; ++i) {
        for (int j = i + 1; j &lt; n; ++j) {
            if (nums[i] + nums[j] == target) {
                result.push_back(i);
                result.push_back(j);
                break;
            }
        }
    }
    return "[" + to_string(result[0]) + ", " + to_string(result[1]) + "]";
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Hash Map</h5>
  <p>Use a hash map to store each number and its index. Iterate through the array. For each number, check if the complement (target - number) exists in the hash map. If it does, return the indices.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string solve_optimized(vector&lt;int&gt;&amp; nums, int target) {
    unordered_map&lt;int, int&gt; numMap;
    int n = nums.size();
    for (int i = 0; i &lt; n; ++i) {
        int complement = target - nums[i];
        if (numMap.count(complement)) {
            return "[" + to_string(numMap[complement]) + ", " + to_string(i) + "]";
        }
        numMap[nums[i]] = i;
    }
    return ""; // Should not happen as per problem constraints.
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) | <b>Space Complexity:</b> O(n)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [2,7,11,15], target = 9</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[0,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">nums[0] + nums[1] == 9, so return [0, 1].</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [3,2,4], target = 6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">nums[1] + nums[2] == 6, so return [1, 2].</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [3,3], target = 6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[0,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">nums[0] + nums[1] == 6, so return [0, 1].</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The problem states that there is exactly one solution and no duplicate elements are to be considered, which simplifies the approach. The hash map approach is significantly faster than brute force.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/>Best Time to Buy and Sell Stock II</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>You are given an array prices where prices[i] is the price of a given stock on the ith day.  On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day. Find the maximum profit you can achieve.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves exploring all possible buy and sell transactions. We can iterate through all possible pairs of buy and sell days and calculate the profit. We then maximize this profit over all such pairs. This approach is inherently inefficient as it explores many redundant paths.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int maxProfitBruteForce(vector&lt;int&gt;&amp; prices) {
    int n = prices.size();
    int maxProfit = 0;

    for (int i = 0; i &lt; n; ++i) {
        for (int j = i + 1; j &lt; n; ++j) {
            int profit = prices[j] - prices[i];
            maxProfit = max(maxProfit, profit);
        }
    }

    return maxProfit;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2), where n is the number of days in the prices array. This is because we are using nested loops to check every possible buy and sell combination. | <b>Space Complexity:</b> O(1), as we are using a constant amount of extra space.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Greedy Approach</h5>
  <p>The greedy approach iterates through the prices and, on each day, checks if selling the stock on that day yields a profit. If it does, we add the profit to the total profit. The key idea is to simply add all positive differences between consecutive elements in the price array.  This simulates buying and selling on each day with a positive profit.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int maxProfitGreedy(vector&lt;int&gt;&amp; prices) {
    int maxProfit = 0;
    for (int i = 1; i &lt; prices.size(); ++i) {
        if (prices[i] &gt; prices[i - 1]) {
            maxProfit += prices[i] - prices[i - 1];
        }
    }
    return maxProfit;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the number of days. We iterate through the prices array once. | <b>Space Complexity:</b> O(1), constant extra space is used.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">prices = [7,1,5,3,6,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">7</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. Total profit = 4 + 3 = 7.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">prices = [1,2,3,4,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">prices = [7,6,4,3,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">In this case, no transaction is done, and the maximum profit is 0.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The greedy approach is optimal for this problem because we are allowed to perform multiple transactions. The goal is to maximize profit at each local point, and the greedy algorithm does just that. Key edge case: If the array is in descending order, profit will be 0. The problem statement mentions that you can buy and sell on the same day, but it doesn't change the optimal solution's approach, as the profit would be zero.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/subarray-sums-divisible-by-k/>Subarray Sums Divisible by K</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an integer array `nums` and an integer `k`, return the number of non-empty subarrays that have a sum divisible by `k`.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible subarrays and check if their sum is divisible by `k`.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int subarrayDivisibleByK_bruteForce(vector&lt;int&gt;&amp; nums, int k) {
    int count = 0;
    int n = nums.size();
    for (int i = 0; i &lt; n; ++i) {
        for (int j = i; j &lt; n; ++j) {
            int sum = 0;
            for (int l = i; l &lt;= j; ++l) {
                sum += nums[l];
            }
            if (sum % k == 0) {
                count++;
            }
        }
    }
    return count;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^3) | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Using Hashmap (Prefix Sums)</h5>
  <p>Calculate prefix sums and store the remainders when divided by k in a hashmap. If a remainder is seen before, it means the sum of the subarray between the two occurrences is divisible by k. Count the occurrences of each remainder to optimize.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int subarrayDivisibleByK_optimized(vector&lt;int&gt;&amp; nums, int k) {
    int count = 0;
    int n = nums.size();
    vector&lt;int&gt; prefix_sums(n + 1, 0);
    unordered_map&lt;int, int&gt; remainder_counts;
    remainder_counts[0] = 1; // Initialize remainder 0 with count 1 because empty subarray has sum 0.

    for (int i = 0; i &lt; n; ++i) {
        prefix_sums[i + 1] = (prefix_sums[i] + nums[i]) % k;
        if (prefix_sums[i + 1] &lt; 0) {
            prefix_sums[i + 1] += k; // Handle negative remainders
        }

        if (remainder_counts.find(prefix_sums[i + 1]) != remainder_counts.end()) {
            count += remainder_counts[prefix_sums[i + 1]];
            remainder_counts[prefix_sums[i + 1]]++;
        } else {
            remainder_counts[prefix_sums[i + 1]] = 1;
        }
    }
    return count;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) | <b>Space Complexity:</b> O(k)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [4,5,0,-2,-3,1], k = 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">7</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The subarrays are: [4, 5, 0, -2, -3, 1], [5], [5, 0], [0], [0, -2, -3], [-2, -3], [1]</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [5], k = 9</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No subarray sums divisible by 9.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  Handle negative remainders correctly by adding `k` if the remainder is negative.
2.  Initialize the hashmap with a count of 1 for remainder 0 to account for the empty prefix sum.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/find-all-duplicates-in-an-array/>Find All Duplicates in an Array</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an array of integers `nums` of length `n` where all integers are in the range `[1, n]` and each integer appears once or twice, return an array of all the integers that appear twice in `nums`.

You must write an algorithm that runs in `O(n)` time and uses only constant extra space.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the array and for each element, count how many times it appears in the array. If the count is 2, add it to the result. This approach uses nested loops.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

vector&lt;int&gt; findDuplicatesBruteForce(vector&lt;int&gt;&amp; nums) {
    vector&lt;int&gt; duplicates;
    int n = nums.size();
    for (int i = 0; i &lt; n; ++i) {
        int count = 0;
        for (int j = 0; j &lt; n; ++j) {
            if (nums[i] == nums[j]) {
                count++;
            }
        }
        if (count == 2) {
            bool found = false;
            for (int duplicate : duplicates) {
                if (duplicate == nums[i]) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                duplicates.push_back(nums[i]);
            }
        }
    }
    return duplicates;
}</code></pre>
  <p><b>Time Complexity:</b> O(n^2) | <b>Space Complexity:</b> O(1) in the best case and O(n) in worst case, to store the duplicates.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Using Array as Hash Table (In-place)</h5>
  <p>Iterate through the array. For each number `num`, take its absolute value. Use this value -1 as an index into the array. If the element at that index is positive, change it to negative. If the element at that index is negative, it means we've seen this number before, so add the absolute value of the number to the result. This approach utilizes the array itself as a hash table, taking advantage of the fact that all numbers are within the range [1, n].</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

vector&lt;int&gt; findDuplicatesOptimized(vector&lt;int&gt;&amp; nums) {
    vector&lt;int&gt; duplicates;
    for (int i = 0; i &lt; nums.size(); ++i) {
        int index = abs(nums[i]) - 1;
        if (nums[index] &lt; 0) {
            duplicates.push_back(abs(nums[i]));
        } else {
            nums[index] *= -1;
        }
    }
    return duplicates;
}</code></pre>
  <p><b>Time Complexity:</b> O(n) | <b>Space Complexity:</b> O(1)</p>
  <h5>‚û§ Using Extra Space (Hash Map)</h5>
  <p>Use a hash map (or unordered_map in C++) to store the frequency of each number. Iterate through the array and update the count of each number in the hash map. Finally, iterate through the hash map and add numbers with a count of 2 to the result.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

vector&lt;int&gt; findDuplicatesHashMap(vector&lt;int&gt;&amp; nums) {
    vector&lt;int&gt; duplicates;
    unordered_map&lt;int, int&gt; counts;
    for (int num : nums) {
        counts[num]++;
    }
    for (auto const&amp; [num, count] : counts) {
        if (count == 2) {
            duplicates.push_back(num);
        }
    }
    return duplicates;
}</code></pre>
  <p><b>Time Complexity:</b> O(n) | <b>Space Complexity:</b> O(n)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[4,3,2,7,8,2,3,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[2,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2 and 3 appear twice.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 appears twice.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No duplicates.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">All numbers from 1 to 50 appear twice.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The in-place approach is the most efficient in terms of space complexity, as it modifies the input array to store information about duplicates. The problem specifically asks for O(1) extra space, making this the preferred solution. The range [1, n] of the numbers is crucial for the in-place approach to work correctly.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/container-with-most-water/>Container With Most Water</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which together with the x-axis forms a container, such that the container contains the most water.

Notice that you may not slant the container.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>This approach considers all possible pairs of lines and calculates the area formed by each pair. The maximum area is then returned.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int maxArea_brute_force(vector&lt;int&gt;&amp; height) {
    int max_area = 0;
    int n = height.size();

    for (int i = 0; i &lt; n; ++i) {
        for (int j = i + 1; j &lt; n; ++j) {
            int width = j - i;
            int h = min(height[i], height[j]);
            max_area = max(max_area, width * h);
        }
    }
    return max_area;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Two-Pointer Approach</h5>
  <p>This approach uses two pointers, one at the beginning and one at the end of the array. At each step, it calculates the area between the lines pointed to by the pointers. The pointer pointing to the shorter line is then moved inward. This is because moving the shorter line potentially allows the area to increase (by possibly finding a taller line) while moving the longer line can only decrease the area.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int maxArea_optimized(vector&lt;int&gt;&amp; height) {
    int max_area = 0;
    int left = 0;
    int right = height.size() - 1;

    while (left &lt; right) {
        int width = right - left;
        int h = min(height[left], height[right]);
        max_area = max(max_area, width * h);

        if (height[left] &lt; height[right]) {
            left++;
        } else {
            right--;
        }
    }

    return max_area;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,8,6,2,5,4,8,3,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">49</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The container with the maximum area is formed by the lines at index 1 and 7 (heights 8 and 7, respectively), with an area of 49.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The container is formed by the two lines with heights 1 and 1. The area is 1.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[4,3,2,1,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">16</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The container is formed by lines at index 0 and 4, forming area 16.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to the optimized solution is to realize that the area is limited by the shorter line. Therefore, moving the pointer of the shorter line is more likely to increase the area. Edge cases include input arrays with zero or one element. Also consider cases where the heights are equal, which would not affect the solution, and hence does not affect performance.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/3sum/>3Sum</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`. Notice that the solution set must not contain duplicate triplets.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible combinations of three numbers and check if their sum is equal to zero. Use a set to store the triplets to avoid duplicates.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

string print_vector(vector&lt;vector&lt;int&gt;&gt; &amp;v) {
    string s = "";
    s += "[";
    for (int i = 0; i &lt v.size(); ++i) {
        s += "[";
        for (int j = 0; j &lt v[i].size(); ++j) {
            s += to_string(v[i][j]);
            if (j != v[i].size() - 1) {
                s += ", ";
            }
        }
        s += "]";
        if (i != v.size() - 1) {
            s += ", ";
        }
    }
    s += "]";
    return s;
}

vector&lt;vector&lt;int&gt;&gt; threeSum_brute_force(vector&lt;int&gt;&amp; nums) {
    vector&lt;vector&lt;int&gt;&gt; result;
    set&lt;vector&lt;int&gt;&gt; uniqueTriplets;
    int n = nums.size();

    for (int i = 0; i &lt n - 2; ++i) {
        for (int j = i + 1; j &lt n - 1; ++j) {
            for (int k = j + 1; k &lt n; ++k) {
                if (nums[i] + nums[j] + nums[k] == 0) {
                    vector&lt;int&gt; triplet = {nums[i], nums[j], nums[k]};
                    sort(triplet.begin(), triplet.end());
                    uniqueTriplets.insert(triplet);
                }
            }
        }
    }

    for (const auto& triplet : uniqueTriplets) {
        result.push_back(triplet);
    }

    return result;
}

// int main() {
//     vector&lt;int&gt; nums = {-1, 0, 1, 2, -1, -4};
//     vector&lt;vector&lt;int&gt;&gt; result = threeSum_brute_force(nums);
//     cout &lt;&lt; print_vector(result) &lt;&lt; endl;
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(n^3 log n) - where n is the number of elements in nums. Sorting the triplets takes O(log n) time. | <b>Space Complexity:</b> O(n^3) - in the worst case, we can store up to n^3 triplets in the set. O(n) to store set</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Two Pointers with Sorting</h5>
  <p>Sort the array. Iterate through the array, and for each element, use two pointers to find the remaining two numbers that sum up to the negative of the current element. Skip duplicate elements.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

string print_vector(vector&lt;vector&lt;int&gt;&gt; &amp;v) {
    string s = "";
    s += "[";
    for (int i = 0; i &lt v.size(); ++i) {
        s += "[";
        for (int j = 0; j &lt v[i].size(); ++j) {
            s += to_string(v[i][j]);
            if (j != v[i].size() - 1) {
                s += ", ";
            }
        }
        s += "]";
        if (i != v.size() - 1) {
            s += ", ";
        }
    }
    s += "]";
    return s;
}

vector&lt;vector&lt;int&gt;&gt; threeSum_optimized(vector&lt;int&gt;&amp; nums) {
    vector&lt;vector&lt;int&gt;&gt; result;
    sort(nums.begin(), nums.end());
    int n = nums.size();

    for (int i = 0; i &lt n - 2; ++i) {
        // Skip duplicate elements for the first number
        if (i &gt 0 &amp;&amp; nums[i] == nums[i - 1]) {
            continue;
        }

        int left = i + 1;
        int right = n - 1;

        while (left &lt right) {
            int sum = nums[i] + nums[left] + nums[right];

            if (sum == 0) {
                result.push_back({nums[i], nums[left], nums[right]});
                // Skip duplicate elements for the second number
                while (left &lt right &amp;&amp; nums[left] == nums[left + 1]) {
                    left++;
                }
                // Skip duplicate elements for the third number
                while (left &lt right &amp;&amp; nums[right] == nums[right - 1]) {
                    right--;
                }
                left++;
                right--;
            } else if (sum &lt 0) {
                left++;
            } else {
                right--;
            }
        }
    }

    return result;
}

// int main() {
//     vector&lt;int&gt; nums = {-1, 0, 1, 2, -1, -4};
//     vector&lt;vector&lt;int&gt;&gt; result = threeSum_optimized(nums);
//     cout &lt;&lt; print_vector(result) &lt;&lt; endl;
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) - where n is the number of elements in nums. Sorting takes O(n log n), and the nested loops take O(n^2). | <b>Space Complexity:</b> O(1) - excluding the space for the output, as we are modifying the input array in place.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [-1,0,1,2,-1,-4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[-1,-1,2],[-1,0,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The triplets that sum up to zero are [-1, -1, 2] and [-1, 0, 1].</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [0,1,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No triplets sum up to zero.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [0,0,0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0,0,0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The only triplet that sums up to zero is [0, 0, 0].</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The key to solving this problem efficiently is to sort the array first. Sorting allows us to use the two-pointer technique to find the remaining two numbers in O(n) time for each element.
2.  Handling duplicate triplets is crucial. We achieve this by skipping duplicate elements when iterating through the array and when moving the two pointers.
3. Consider cases where there are no triplets that sum up to zero or where there are only duplicate numbers.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/4sum/>4Sum</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an array of integers `nums` and an integer `target`, return *all the unique quadruplets* `[nums[a], nums[b], nums[c], nums[d]]` such that:

*   `0 &lt;= a, b, c, d &lt; nums.length`
*   `a`, `b`, `c`, and `d` are distinct.
*   `nums[a] + nums[b] + nums[c] + nums[d] == target`

You may return the answer in **any order**.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible combinations of four numbers, check if their sum equals the target, and add the unique quadruplets to the result. To avoid duplicates, sort the quadruplets and use a set to store them.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;

using namespace std;

vector&lt;vector&lt;int&gt;&gt; fourSum_brute_force(vector&lt;int&gt;&amp; nums, int target) {
    int n = nums.size();
    set&lt;vector&lt;int&gt;&gt; quadruplets;

    for (int i = 0; i &lt; n; ++i) {
        for (int j = i + 1; j &lt; n; ++j) {
            for (int k = j + 1; k &lt; n; ++k) {
                for (int l = k + 1; l &lt; n; ++l) {
                    if (nums[i] + nums[j] + nums[k] + nums[l] == target) {
                        vector&lt;int&gt; quad = {nums[i], nums[j], nums[k], nums[l]};
                        sort(quad.begin(), quad.end());
                        quadruplets.insert(quad);
                    }
                }
            }
        }
    }

    return vector&lt;vector&lt;int&gt;&gt;(quadruplets.begin(), quadruplets.end());
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^4) - Four nested loops iterate through all combinations of four numbers. | <b>Space Complexity:</b> O(n) - In the worst case, we may need to store all possible quadruplets which can be at most nC4. Also, sorting a quadruplet takes O(1) extra space.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Two Pointers with Sorting</h5>
  <p>Sort the array. Iterate through the array, fixing the first two numbers of the quadruplet.  Then, use two pointers (left and right) to find the remaining two numbers.  To avoid duplicate quadruplets, skip duplicate values for each of the four numbers.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

vector&lt;vector&lt;int&gt;&gt; fourSum_optimized(vector&lt;int&gt;&amp; nums, int target) {
    int n = nums.size();
    vector&lt;vector&lt;int&gt;&gt; result;
    sort(nums.begin(), nums.end());

    for (int i = 0; i &lt; n - 3; ++i) {
        // Skip duplicate values for the first number
        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {
            continue;
        }

        for (int j = i + 1; j &lt; n - 2; ++j) {
            // Skip duplicate values for the second number
            if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) {
                continue;
            }

            int left = j + 1;
            int right = n - 1;

            while (left &lt; right) {
                long long sum = (long long)nums[i] + nums[j] + nums[left] + nums[right];

                if (sum == target) {
                    result.push_back({nums[i], nums[j], nums[left], nums[right]});

                    // Skip duplicate values for the third number
                    while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) {
                        left++;
                    }
                    // Skip duplicate values for the fourth number
                    while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) {
                        right--;
                    }

                    left++;
                    right--;
                } else if (sum &lt; target) {
                    left++;
                } else {
                    right--;
                }
            }
        }
    }

    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^3) - Sorting takes O(n log n), and the nested loops take O(n^3). Overall the time complexity is dominated by O(n^3). | <b>Space Complexity:</b> O(1) -  The space complexity is mainly determined by the `result` vector. In the worst-case scenario (no duplicates) it can go upto O(n^4). However, the algorithm is designed to eliminate duplicate quadruplets, and the primary space usage is due to the output which will be bounded by the input size.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,0,-1,0,-2,2], target = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The quadruplets that sum to 0 are [-2,-1,1,2], [-2,0,0,2], and [-1,0,0,1].</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [2,2,2,2,2], target = 8</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[2,2,2,2]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The only quadruplet that sums to 8 is [2,2,2,2].</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [-2,-1,-1,1,1,2,2], target = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[-2,-1,1,2],[-1,-1,1,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The quadruplets that sum to 0 are [-2, -1, 1, 2] and [-1, -1, 1, 1].</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  Sorting the array is crucial for the optimized solution and for handling duplicate values. 2.  The two-pointer approach efficiently searches for the remaining two numbers after fixing the first two. 3.  Be careful to avoid integer overflow when calculating the sum. Use long long to store intermediate sum. 4. Duplicate handling is important to avoid repeated quadruplets in the result.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/>Maximum Points You Can Obtain from Cards</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>You are given an integer array `cardPoints` and an integer `k`. In one step, you can take one card from the beginning or the end of the row. You have to take exactly `k` cards. Your task is to maximize the sum of the points you get from the `k` cards. Return the maximum points you can obtain.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Try all possible combinations of taking k cards from the beginning and end of the array. For each combination, calculate the sum of the points and keep track of the maximum sum.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int maxScoreBruteForce(vector&lt;int&gt;&amp; cardPoints, int k) {
    int n = cardPoints.size();
    int maxScore = 0;
    for (int i = 0; i &lt; (1 &lt;&lt; n); ++i) {
        if (__builtin_popcount(i) != k) continue; // Only consider combinations with k cards

        int currentScore = 0;
        vector&lt;int&gt; taken;
        for (int j = 0; j &lt; n; ++j) {
            if ((i &gt;&gt; j) &amp; 1) {
                taken.push_back(j);
            }
        }

        if (taken.size() != k) continue;

        vector&lt;bool&gt; used(n, false);
        for (int index : taken) {
            used[index] = true;
        }

        //Check if we can achieve the selections, we can pick from start and end.
        bool valid = true;
        for(int p = 0; p &lt; taken.size(); ++p) {
            int ind = taken[p];
            int count = 0;
            if (ind &gt;= k || ind &lt;= n-k-1)
                count = 1;
            else
                count = 2;
            if(count &gt; 2)
                valid = false;
        }
        
        if(!valid) continue;
        
        for (int index : taken) {
            currentScore += cardPoints[index];
        }
        maxScore = max(maxScore, currentScore);
    }
    return maxScore;
}
</code></pre>
  <p><b>Time Complexity:</b> O(2^n * k), where n is the size of cardPoints. We iterate through all 2^n subsets and for each subset (combination), calculating its sum takes O(k) time. | <b>Space Complexity:</b> O(n) in worst case to store a subset of indexes.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Sliding Window</h5>
  <p>The problem can be solved efficiently using the sliding window technique. Instead of taking k cards, we can view it as keeping a window of size n-k in the middle of the array and minimizing the sum of the cards within the window. The maximum score then is the sum of the original array minus the minimum window sum.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int maxScoreSlidingWindow(vector&lt;int&gt;&amp; cardPoints, int k) {
    int n = cardPoints.size();
    int windowSize = n - k;
    int currentWindowSum = 0;

    // Calculate the sum of the first window
    for (int i = 0; i &lt; windowSize; ++i) {
        currentWindowSum += cardPoints[i];
    }

    int minWindowSum = currentWindowSum;
    // Slide the window and update minWindowSum
    for (int i = windowSize; i &lt; n; ++i) {
        currentWindowSum += cardPoints[i] - cardPoints[i - windowSize];
        minWindowSum = min(minWindowSum, currentWindowSum);
    }

    int totalSum = accumulate(cardPoints.begin(), cardPoints.end(), 0);
    return totalSum - minWindowSum;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the size of cardPoints. We iterate through the array twice. | <b>Space Complexity:</b> O(1), we use a constant amount of extra space.</p>
  <h5>‚û§ Prefix Sum</h5>
  <p>Calculate prefix sums for the cardPoints array. Iterate through all possible combinations of picking cards from the left and right sides. For each combination, calculate the sum and track the maximum.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int maxScorePrefixSum(vector&lt;int&gt;&amp; cardPoints, int k) {
    int n = cardPoints.size();
    vector&lt;int&gt; prefixSum(n + 1, 0);
    for (int i = 0; i &lt; n; ++i) {
        prefixSum[i + 1] = prefixSum[i] + cardPoints[i];
    }

    int maxScore = 0;
    for (int i = 0; i &lt;= k; ++i) {
        // Pick i cards from the left and k-i from the right
        int currentScore = prefixSum[i] + (prefixSum[n] - prefixSum[n - (k - i)]);
        maxScore = max(maxScore, currentScore);
    }
    return maxScore;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n + k), where n is the size of cardPoints. O(n) for calculating prefix sums, and O(k) for iterating through the possible combinations. | <b>Space Complexity:</b> O(n) for storing prefix sums.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">cardPoints = [1,2,3,4,5,6,1], k = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">12</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Take cards [6, 5, 1]. Sum is 12.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">cardPoints = [2,2,2], k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Take cards [2, 2]. Sum is 4.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">cardPoints = [9,9,7,7,9,7,7], k = 7</td>
        <td style="border: 1px solid #ccc; padding: 6px;">55</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Take all cards. Sum is 55.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The sliding window approach is the most efficient solution because it avoids nested loops and directly calculates the maximum score by finding the minimum sum within the window. Edge cases include when k equals 0 (return 0) and when k equals the size of the array (return the sum of all elements).</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/subarray-sum-equals-k/>Subarray Sum Equals K</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an array of integers `nums` and an integer `k`, return the total number of subarrays whose sum equals to `k`.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible subarrays and check if their sum is equal to k.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int subarraySumBruteForce(vector&lt;int&gt;&amp; nums, int k) {
    int count = 0;
    int n = nums.size();
    for (int i = 0; i &lt; n; i++) {
        for (int j = i; j &lt; n; j++) {
            int sum = 0;
            for (int l = i; l &lt;= j; l++) {
                sum += nums[l];
            }
            if (sum == k) {
                count++;
            }
        }
    }
    return count;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^3) - Three nested loops: outer loops for start and end indices, and inner loop to calculate the sum. | <b>Space Complexity:</b> O(1) - Constant extra space.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Hash Map (Prefix Sum)</h5>
  <p>Use a hash map to store the prefix sums and their frequencies. Iterate through the array, calculate the current prefix sum. If (prefix_sum - k) exists in the hash map, it means there's a subarray with sum k ending at the current index. Increment the count by the frequency of (prefix_sum - k). Update the frequency of current prefix sum in the hash map.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int subarraySumOptimized(vector&lt;int&gt;&amp; nums, int k) {
    int count = 0;
    int n = nums.size();
    unordered_map&lt;int, int&gt; prefixSumMap;
    prefixSumMap[0] = 1; // Initialize with prefix sum 0 having a frequency of 1
    int currentSum = 0;

    for (int i = 0; i &lt; n; i++) {
        currentSum += nums[i];
        if (prefixSumMap.find(currentSum - k) != prefixSumMap.end()) {
            count += prefixSumMap[currentSum - k];
        }
        prefixSumMap[currentSum]++;
    }
    return count;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) - Single pass through the array. | <b>Space Complexity:</b> O(n) - In the worst case, the hash map stores all prefix sums.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,1,1], k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The subarrays [1, 1] and [1, 1] have sum 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,2,3], k = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The subarrays [1, 2] and [3] have sum 3.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,-1,0], k = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The subarrays [1, -1, 0], [-1, 0], and [0] have sum 0.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Important edge cases: 
- Empty array: Should return 0.
- Array with all zeros:  Need to correctly handle the case where k=0 and potentially multiple subarrays summing to zero.
- Negative numbers: The problem can involve negative numbers, so the prefix sum approach is crucial.
- Very large numbers:  Be mindful of potential integer overflow when calculating sums.  The problem constraints usually limit the size of integers to prevent this. Consider using 'long long' if larger number are expected.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/spiral-matrix/>Spiral Matrix</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an m x n matrix, return all elements of the matrix in spiral order.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Simulate the spiral traversal directly. Maintain four boundaries (top, bottom, left, right) and move layer by layer. In each layer, traverse right, then down, then left, and finally up, updating the boundaries after each traversal.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

vector&lt;int&gt; spiralOrder_brute(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
    vector&lt;int&gt; result;
    if (matrix.empty() || matrix[0].empty()) return result;

    int top = 0, bottom = matrix.size() - 1;
    int left = 0, right = matrix[0].size() - 1;
    int direction = 0; // 0: right, 1: down, 2: left, 3: up

    while (top &lt= bottom &amp;&amp; left &lt= right) {
        if (direction == 0) {
            for (int i = left; i &lt= right; ++i) {
                result.push_back(matrix[top][i]);
            }
            top++;
        } else if (direction == 1) {
            for (int i = top; i &lt= bottom; ++i) {
                result.push_back(matrix[i][right]);
            }
            right--;
        } else if (direction == 2) {
            for (int i = right; i &gt= left; --i) {
                result.push_back(matrix[bottom][i]);
            }
            bottom--;
        } else if (direction == 3) {
            for (int i = bottom; i &gt= top; --i) {
                result.push_back(matrix[i][left]);
            }
            left++;
        }
        direction = (direction + 1) % 4;
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(m * n), where m is the number of rows and n is the number of columns in the matrix.  Each element is visited and added to the result vector exactly once. | <b>Space Complexity:</b> O(1) (excluding the output vector).  We use a constant amount of extra space to store the boundaries and the direction.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Simulation</h5>
  <p>Similar to the brute-force approach, but this is the standard optimized approach as well. Maintain boundaries and simulate the spiral traversal. The key is to correctly update the boundaries after each traversal direction (right, down, left, up) to avoid out-of-bounds access and ensure all elements are visited exactly once.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
    vector&lt;int&gt; result;
    if (matrix.empty() || matrix[0].empty()) return result;

    int top = 0, bottom = matrix.size() - 1;
    int left = 0, right = matrix[0].size() - 1;
    int dir = 0; // 0: right, 1: down, 2: left, 3: up

    while (top &lt= bottom &amp;&amp; left &lt= right) {
        if (dir == 0) {
            for (int i = left; i &lt= right; ++i) {
                result.push_back(matrix[top][i]);
            }
            top++;
        } else if (dir == 1) {
            for (int i = top; i &lt= bottom; ++i) {
                result.push_back(matrix[i][right]);
            }
            right--;
        } else if (dir == 2) {
            for (int i = right; i &gt= left; --i) {
                result.push_back(matrix[bottom][i]);
            }
            bottom--;
        } else if (dir == 3) {
            for (int i = bottom; i &gt= top; --i) {
                result.push_back(matrix[i][left]);
            }
            left++;
        }
        dir = (dir + 1) % 4;
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(m * n), where m is the number of rows and n is the number of columns. Each element is visited once. | <b>Space Complexity:</b> O(1) excluding the output array. We use a constant amount of extra space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,2,3],[4,5,6],[7,8,9]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,3,6,9,8,7,4,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The elements are traversed in a spiral order.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,2,3,4],[5,6,7,8],[9,10,11,12]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,3,4,8,12,11,10,9,5,6,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The elements are traversed in a spiral order.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Single element matrix.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Empty matrix.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  Handle edge cases: empty matrix or empty rows.
2.  The boundaries (top, bottom, left, right) are crucial for the correct traversal.
3.  Ensure the loop continues as long as top &lt= bottom and left &lt= right.
4.  The direction change is modulo 4.  This makes the logic concise and easy to follow.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/word-search/>Word Search</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an m x n grid of characters `board` and a string `word`, return `true` if `word` exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves iterating through each cell of the board and, for each cell, attempting to find the word by exploring all possible paths (up, down, left, right). This exploration is typically done using recursion or backtracking.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {
        int rows = board.size();
        int cols = board[0].size();

        for (int i = 0; i &lt rows; ++i) {
            for (int j = 0; j &lt cols; ++j) {
                if (board[i][j] == word[0] &amp;&amp; dfs(board, i, j, word, 0)) {
                    return true;
                }
            }
        }
        return false;
    }

    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int row, int col, string word, int index) {
        if (index == word.length()) {
            return true;
        }

        if (row &lt 0 || row &gt= board.size() || col &lt 0 || col &gt= board[0].size() || board[row][col] != word[index]) {
            return false;
        }

        // Mark the current cell as visited
        char temp = board[row][col];
        board[row][col] = '#'; // Mark as visited

        // Explore adjacent cells
        bool found = dfs(board, row + 1, col, word, index + 1) ||
                     dfs(board, row - 1, col, word, index + 1) ||
                     dfs(board, row, col + 1, word, index + 1) ||
                     dfs(board, row, col - 1, word, index + 1);

        // Backtrack: Restore the original character
        board[row][col] = temp;

        return found;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(m * n * 4^k), where m and n are the dimensions of the board, and k is the length of the word.  In the worst case, we may need to explore all 4 directions for each cell, up to the length of the word. | <b>Space Complexity:</b> O(k), where k is the length of the word, due to the recursion depth in the worst case.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized with Backtracking and Early Pruning</h5>
  <p>This approach is similar to the brute-force but incorporates optimizations to improve efficiency. It still uses backtracking but adds pruning techniques to avoid exploring unnecessary paths. The key optimizations include:

*   **Early Exit:** If the current cell's character does not match the expected character in the `word`, it immediately returns `false`.  This avoids unnecessary recursive calls.
*   **Visited Marking:**  Marks visited cells to avoid reusing them in the same path. This is crucial to satisfy the problem constraint.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {
        int rows = board.size();
        int cols = board[0].size();

        for (int i = 0; i &lt rows; ++i) {
            for (int j = 0; j &lt cols; ++j) {
                if (board[i][j] == word[0] &amp;&amp; dfs(board, i, j, word, 0)) {
                    return true;
                }
            }
        }
        return false;
    }

    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int row, int col, string word, int index) {
        if (index == word.length()) {
            return true;
        }

        if (row &lt 0 || row &gt= board.size() || col &lt 0 || col &gt= board[0].size() || board[row][col] != word[index]) {
            return false;
        }

        // Mark the current cell as visited
        char temp = board[row][col];
        board[row][col] = '#'; // Mark as visited

        // Explore adjacent cells
        bool found = dfs(board, row + 1, col, word, index + 1) ||
                     dfs(board, row - 1, col, word, index + 1) ||
                     dfs(board, row, col + 1, word, index + 1) ||
                     dfs(board, row, col - 1, word, index + 1);

        // Backtrack: Restore the original character
        board[row][col] = temp;

        return found;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(m * n * 4^k) in the worst case, similar to the brute force, where m and n are the dimensions of the board, and k is the length of the word. However, the pruning techniques can significantly reduce the number of explored paths in many cases, leading to better performance than the brute force on average. | <b>Space Complexity:</b> O(k), due to the recursion depth.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = "ABCCED"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The word "ABCCED" exists in the board.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = "SEE"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The word "SEE" exists in the board.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = "ABCB"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The word "ABCB" does not exist in the board because the letter 'B' cannot be reused.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Key considerations include:

*   **Backtracking:** The core algorithm uses backtracking to explore possible paths.  Each recursive call explores one step in the word.
*   **Visited Cells:**  Marking cells as visited (e.g., by changing their character temporarily) is essential to prevent revisiting the same cell during the same path.
*   **Early Exit:**  Checking whether the current cell's character matches the current character in the word is a critical optimization that helps reduce unnecessary recursive calls.  Also check board boundary conditions before exploring adjacent cells.
*   **Boundary Conditions:** Ensure that the algorithm handles boundary conditions correctly (e.g., preventing out-of-bounds access to the `board`).
*   **Edge Cases:** Consider edge cases such as an empty board or an empty word. A word consisting of a single character is also an important test case.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/jump-game/>Jump Game</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Recursively try all possible jumps from each position.  If a jump leads to the end, return true. Otherwise, return false if no jump from the current position can lead to the end.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool canJumpRecursive(vector&lt;int&gt;&amp; nums, int index) {
    if (index &gt= nums.size() - 1) {
        return true;
    }
    int maxJump = nums[index];
    for (int i = 1; i &lt= maxJump; ++i) {
        if (canJumpRecursive(nums, index + i)) {
            return true;
        }
    }
    return false;
}

bool canJumpBruteForce(vector&lt;int&gt;&amp; nums) {
    return canJumpRecursive(nums, 0);
}
</code></pre>
  <p><b>Time Complexity:</b> O(2^n) - Exponential due to the recursive exploration of all possible jump combinations. | <b>Space Complexity:</b> O(n) - Due to the recursion call stack depth in the worst case.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Greedy Approach</h5>
  <p>Iterate through the array, keeping track of the farthest reachable index. At each position, update the farthest reachable index. If the current position is beyond the farthest reachable index, it means we cannot reach this position and therefore cannot reach the end. If at any point the farthest reachable index is &gt= the last index, we've succeeded.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool canJumpGreedy(vector&lt;int&gt;&amp; nums) {
    int reachable = 0;
    for (int i = 0; i &lt nums.size(); ++i) {
        if (i &gt reachable) {
            return false; // Cannot reach current index
        }
        reachable = max(reachable, i + nums[i]);
        if (reachable &gt= nums.size() - 1) {
            return true; // Reached the end
        }
    }
    return true; // Reached the end without issues (edge case where the last element is reachable from the start)
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) - Single pass through the array. | <b>Space Complexity:</b> O(1) - Constant space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[2,3,1,1,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Jump 1 step from index 0 to 1, then 3 steps to the last index.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[3,2,1,0,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">You will always arrive at index 3 but the jump length is 0. No way to reach the last index.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">You are already at the end.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[2,0,0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Jump one step</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[0,2,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">You cannot reach any index greater than 0.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases include arrays with a single element, arrays where the first element is 0, and arrays where it's impossible to reach the end. The greedy approach offers the most efficient solution by avoiding unnecessary explorations.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/merge-sorted-array/>Merge Sorted Array</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>You are given two integer arrays `nums1` and `nums2`, sorted in non-decreasing order, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively. Merge `nums1` and `nums2` into a single array sorted in non-decreasing order. The final sorted array should not be returned as a new array, but be stored inside the array `nums1`. `nums1` has a length of `m + n` where the first `m` elements represent the elements that should be merged, and the last `n` elements are set to 0 and should be ignored. `nums2` has a length of `n`.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Combine the two arrays, sort the combined array.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

void merge_brute_force(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
    // Copy elements from nums2 into the remaining space of nums1
    for (int i = 0; i &lt; n; ++i) {
        nums1[m + i] = nums2[i];
    }

    // Sort the combined array
    sort(nums1.begin(), nums1.end());
}
</code></pre>
  <p><b>Time Complexity:</b> O((m+n)log(m+n)) due to sorting. | <b>Space Complexity:</b> O(1) - in-place modification of nums1 (excluding space for the input arrays).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Two Pointers (From End)</h5>
  <p>Use two pointers, one at the end of `nums1`'s filled portion and one at the end of `nums2`. Compare elements and place the larger element at the end of `nums1`. Decrement the pointers and repeat. Handle the case where one of the arrays is exhausted.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

void merge_optimal(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
    int p1 = m - 1; // Pointer for nums1
    int p2 = n - 1; // Pointer for nums2
    int p = m + n - 1; // Pointer for merged array

    while (p1 &gt;= 0 &amp;&amp; p2 &gt;= 0) {
        if (nums1[p1] &gt;= nums2[p2]) {
            nums1[p] = nums1[p1];
            p1--;
        } else {
            nums1[p] = nums2[p2];
            p2--;
        }
        p--;
    }

    // If nums2 still has elements, copy them to nums1
    while (p2 &gt;= 0) {
        nums1[p] = nums2[p2];
        p2--;
        p--;
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(m+n) - we iterate through the arrays at most once. | <b>Space Complexity:</b> O(1) - in-place modification.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,2,3,5,6]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The elements of nums1 after merging are [1,2,2,3,5,6] with the sorted result.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums1 = [1], m = 1, nums2 = [], n = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The final sorted array is [1].</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums1 = [0], m = 0, nums2 = [1], n = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The final sorted array is [1].</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Important edge cases include empty arrays or one array being completely empty. The solution should modify `nums1` in-place, so extra care is needed to avoid unnecessary memory allocation. Also, be careful when dealing with the 0s in nums1.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/majority-element/>Majority Element</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an array nums of size n, return the majority element. The majority element is the element that appears more than \u230a n / 2 \u230b times. You may assume that the majority element always exists in the array.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the array and for each element, count its occurrences. If the count exceeds n/2, return the element.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

int majorityElement_brute_force(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    for (int i = 0; i &lt; n; ++i) {
        int count = 0;
        for (int j = 0; j &lt; n; ++j) {
            if (nums[i] == nums[j]) {
                count++;
            }
        }
        if (count &gt; n / 2) {
            return nums[i];
        }
    }
    return -1; // Should not happen as per problem statement
}</code></pre>
  <p><b>Time Complexity:</b> O(n^2) | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Using Hash Map</h5>
  <p>Use a hash map (unordered_map in C++) to store the frequency of each element. Iterate through the array, and for each element, increment its count in the hash map. If the count of an element exceeds n/2, return that element.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

int majorityElement_hashmap(vector&lt;int&gt;&amp; nums) {
    unordered_map&lt;int, int&gt; counts;
    int n = nums.size();
    for (int num : nums) {
        counts[num]++;
        if (counts[num] &gt; n / 2) {
            return num;
        }
    }
    return -1; // Should not happen as per problem statement
}</code></pre>
  <p><b>Time Complexity:</b> O(n) | <b>Space Complexity:</b> O(n)</p>
  <h5>‚û§ Moore's Voting Algorithm</h5>
  <p>This algorithm uses a constant space.  It maintains a candidate and a counter. Iterate through the array. If the counter is 0, set the current element as the candidate. If the current element is the same as the candidate, increment the counter; otherwise, decrement the counter. After the iteration, the candidate will be the majority element.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

int majorityElement_moores_voting(vector&lt;int&gt;&amp; nums) {
    int candidate = nums[0];
    int count = 1;
    int n = nums.size();

    for (int i = 1; i &lt; n; i++) {
        if (count == 0) {
            candidate = nums[i];
            count = 1;
        } else if (nums[i] == candidate) {
            count++;
        } else {
            count--;
        }
    }

    // Verify if the candidate is actually the majority element
    count = 0;
    for (int num : nums) {
        if (num == candidate) {
            count++;
        }
    }
    if (count &gt; n / 2) {
        return candidate;
    } else {
        return -1; // Should not happen as per problem statement
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [3,2,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The number 3 appears twice in the array, and the size of the array is 3.  2 &lt;= 3/2 so 3 is the majority element.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [2,2,1,1,1,2,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The number 2 appears 4 times, and the size of the array is 7. 4 &gt; 7/2 so 2 is the majority element.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The number 1 appears once, the size is 1.  1 &gt; 1/2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Although the problem states that majority element exists, if a majority element does not exist, it can be handled by adding an extra check.  In this example no element appears &gt; n/2 times.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The problem guarantees that a majority element exists. However, the provided code for all solutions includes a check or return -1 in the case where no majority element is found to handle cases where this assumption is not true or to add extra robustness.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/reverse-pairs/>Reverse Pairs</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an array `nums`, return the number of reverse pairs in `nums`. A reverse pair is a pair `(i, j)` where `0 &lt;= i &lt; j &lt; nums.length` and `nums[i] &gt; 2 * nums[j]`.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible pairs (i, j) where i &lt; j and check if nums[i] &gt; 2 * nums[j].</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int reversePairsBruteForce(vector&lt;int&gt;&amp; nums) {
    int count = 0;
    int n = nums.size();
    for (int i = 0; i &lt; n; ++i) {
        for (int j = i + 1; j &lt; n; ++j) {
            if ((long long)nums[i] &gt; 2LL * nums[j]) {
                count++;
            }
        }
    }
    return count;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Merge Sort with Modification</h5>
  <p>Adapt the merge sort algorithm. During the merge step, count the reverse pairs before merging the two sorted subarrays. When merging, if nums[i] &gt; 2 * nums[j], then all elements from i to the end of the left subarray will also satisfy the condition. The count is updated accordingly.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt; // For sort

using namespace std;

int mergeSortAndCount(vector&lt;int&gt;&amp; nums, int left, int right) {
    if (left &gt;= right) {
        return 0;
    }

    int mid = left + (right - left) / 2;
    int count = mergeSortAndCount(nums, left, mid) + mergeSortAndCount(nums, mid + 1, right);

    int i = left, j = mid + 1;
    while (i &lt;= mid &amp;&amp; j &lt;= right) {
        if ((long long)nums[i] &gt; 2LL * nums[j]) {
            count += (mid - i + 1);
            j++;
        } else {
            i++;
        }
    }

    vector&lt;int&gt; merged;
    i = left, j = mid + 1;
    while (i &lt;= mid &amp;&amp; j &lt;= right) {
        if (nums[i] &lt;= nums[j]) {
            merged.push_back(nums[i++]);
        } else {
            merged.push_back(nums[j++]);
        }
    }
    while (i &lt;= mid) {
        merged.push_back(nums[i++]);
    }
    while (j &lt;= right) {
        merged.push_back(nums[j++]);
    }

    for (int k = 0; k &lt; merged.size(); k++) {
        nums[left + k] = merged[k];
    }

    return count;
}

int reversePairsMergeSort(vector&lt;int&gt;&amp; nums) {
    return mergeSortAndCount(nums, 0, nums.size() - 1);
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log n) | <b>Space Complexity:</b> O(n)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,3,2,3,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The reverse pairs are (1, 4) and (2, 4).</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [2,4,3,5,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The reverse pairs are (0, 4), (1, 4), and (2, 4).</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Empty array has no pairs.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Single element has no pairs.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The problem asks for pairs where nums[i] &gt; 2 * nums[j]. The multiplication might overflow, so casting to `long long` is crucial.
2.  The Merge Sort approach is efficient and elegant.  The key is to count the pairs during the merge step.
3.  Handle edge cases like empty or single-element arrays correctly.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/print-all-possible-combinations-of-r-elements-in-a-given-array-of-size-n/>Print all possible combinations of r elements in a given array of size n</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an array of size n and an integer r, find all possible combinations of r elements from the array.  A combination is a selection of items from a collection, such that the order of selection does not matter.  For example, if the input array is {1, 2, 3, 4} and r = 2, the combinations would be {1, 2}, {1, 3}, {1, 4}, {2, 3}, {2, 4}, {3, 4}.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves generating all possible subsets of the input array and then filtering for the subsets of size r.  This can be done by recursively exploring all possible combinations or by using bit manipulation to represent subsets.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Function to print a combination
void printCombination(vector&lt;int&gt; &arr, vector&lt;int&gt; &combination) {
    for (int i = 0; i &lt combination.size(); i++) {
        cout &lt&lt arr[combination[i]] &lt&lt " ";
    }
    cout &lt&lt endl;
}

// Recursive function to generate combinations
void generateCombinations(vector&lt;int&gt; &arr, int n, int r, int index, vector&lt;int&gt; &combination, int currentIndex) {
    // If combination is full, print it
    if (currentIndex == r) {
        printCombination(arr, combination);
        return;
    }

    // If there are no more elements to pick
    if (index &gt= n) {
        return;
    }

    // Include the current element
    combination[currentIndex] = index;
    generateCombinations(arr, n, r, index + 1, combination, currentIndex + 1);

    // Exclude the current element
    generateCombinations(arr, n, r, index + 1, combination, currentIndex);
}

// Function to print all combinations of r elements from an array
void printCombinations(vector&lt;int&gt; &arr, int n, int r) {
    vector&lt;int&gt; combination(r);
    generateCombinations(arr, n, r, 0, combination, 0);
}


int main() {
    vector&lt;int&gt; arr = {1, 2, 3, 4};
    int n = arr.size();
    int r = 2;
    printCombinations(arr, n, r);
    return 0;
}</code></pre>
  <p><b>Time Complexity:</b> O(nCr * r), where nCr is the number of combinations (n! / (r! * (n-r)!)).  Printing each combination of size r takes O(r) time. | <b>Space Complexity:</b> O(r) for storing the current combination during recursion. The recursion depth can be up to n.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Backtracking (Optimized)</h5>
  <p>The backtracking approach is an optimized way to generate combinations. It builds combinations incrementally.  At each step, it either includes the current element in the combination or excludes it.  If the combination is full, it prints the combination. This avoids generating and checking all possible subsets.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Function to print a combination
void printCombination(vector&lt;int&gt; &combination, vector&lt;int&gt; &arr) {
    for (int i = 0; i &lt combination.size(); i++) {
        cout &lt&lt arr[combination[i]] &lt&lt " ";
    }
    cout &lt&lt endl;
}

void findCombinationsUtil(vector&lt;int&gt; &arr, int n, int r, int index, vector&lt;int&gt; &data, int i) {
    // Current combination is ready, print it
    if (index == r) {
        printCombination(data, arr);
        return;
    }

    // When no more elements are there to put in data[]
    if (i &gt= n)
        return;

    // Current element is included, put next at next index
    data[index] = i;
    findCombinationsUtil(arr, n, r, index + 1, data, i + 1);

    // Current element is excluded, replace it with next
    // element of arr[]
    findCombinationsUtil(arr, n, r, index, data, i + 1);
}

void printCombinations(vector&lt;int&gt; &arr, int n, int r) {
    vector&lt;int&gt; data(r);
    findCombinationsUtil(arr, n, r, 0, data, 0);
}

int main() {
    vector&lt;int&gt; arr = { 1, 2, 3, 4, 5 };
    int r = 3;
    int n = arr.size();
    printCombinations(arr, n, r);
    return 0;
}</code></pre>
  <p><b>Time Complexity:</b> O(nCr), where nCr is the number of combinations.  Each combination is constructed in O(r) time to be printed.  In practice, it's dominated by the number of combinations, so roughly O(nCr). | <b>Space Complexity:</b> O(r) for storing the current combination in the recursive calls. The maximum depth of the recursion stack will be O(r) as well.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr = {1, 2, 3, 4}, r = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 2 
1 3 
1 4 
2 3 
2 4 
3 4 </td>
        <td style="border: 1px solid #ccc; padding: 6px;">The code iterates through all possible combinations of 2 elements from the array {1, 2, 3, 4}.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr = {1, 2, 3, 4, 5}, r = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 2 3 
1 2 4 
1 2 5 
1 3 4 
1 3 5 
1 4 5 
2 3 4 
2 3 5 
2 4 5 
3 4 5 </td>
        <td style="border: 1px solid #ccc; padding: 6px;">The code generates all combinations of 3 elements from the array {1, 2, 3, 4, 5}.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr = {1,2,3}, r = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 
2 
3 
</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Combinations with r=1</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The order of elements within a combination does not matter.  Duplicate elements in the input array can lead to duplicate combinations, which can be handled by using sets or additional checks during combination generation if duplicates are not desired.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/game-of-life/>Game of Life</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a 2D board representing the game of life, update the board in-place according to these rules:

- Any live cell with fewer than two live neighbors dies (underpopulation).
- Any live cell with two or three live neighbors lives on to the next generation.
- Any live cell with more than three live neighbors dies (overpopulation).
- Any dead cell with exactly three live neighbors becomes a live cell (reproduction).

The neighbors of a cell are those eight cells adjacent to it (horizontally, vertically, and diagonally).

You are given the board represented by a 2D array, and you need to modify the board in-place.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through each cell of the board. For each cell, count its live neighbors. Based on the count and the cell's current state (live or dead), determine its next state. Store the next state in a temporary board. After iterating through all cells, update the original board with the next states from the temporary board.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

void gameOfLife_bruteForce(vector&lt;vector&lt;int&gt;&gt;&amp; board) {
    int rows = board.size();
    int cols = board[0].size();
    vector&lt;vector&lt;int&gt;&gt; next_board = board; // Temporary board to store the next state

    int neighbors[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};

    for (int row = 0; row &lt; rows; row++) {
        for (int col = 0; col &lt; cols; col++) {
            int live_neighbors = 0;

            // Count live neighbors
            for (int i = 0; i &lt; 8; i++) {
                int r = row + neighbors[i][0];
                int c = col + neighbors[i][1];
                if (r &gt;= 0 &amp;&amp; r &lt; rows &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; cols &amp;&amp; (board[r][c] == 1 || board[r][c] == 2)) {
                    live_neighbors++;
                }
            }

            // Apply game rules
            if (board[row][col] == 1) {
                if (live_neighbors &lt; 2 || live_neighbors &gt; 3) {
                    next_board[row][col] = 0;
                }
            } else {
                if (live_neighbors == 3) {
                    next_board[row][col] = 1;
                }
            }
        }
    }
    board = next_board;
}
</code></pre>
  <p><b>Time Complexity:</b> O(m * n * 8), where m is the number of rows and n is the number of columns, and 8 is the maximum number of neighbours to check. Essentially O(m*n) | <b>Space Complexity:</b> O(m * n) for the temporary board (next_board)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized In-place with Extra States</h5>
  <p>Use the existing board itself to store both the current and next states by using extra states. Introduce two extra states to encode the next state of the cell:

- 2: Represents a cell that was alive in the current generation and will be alive in the next.
- 3: Represents a cell that was dead in the current generation and will be alive in the next.

- Iterate through the board and calculate the next state of each cell based on the rules. Instead of creating a new board, we can encode the next state in the existing board.
- If a cell is currently alive and should die, set it to 2.
- If a cell is currently dead and should become alive, set it to 3.
- After the initial iteration, iterate through the board again and update all cells to their next states:
  - If a cell is 2, change it to 0 (dead).
  - If a cell is 3, change it to 1 (alive).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

void gameOfLife_optimized(vector&lt;vector&lt;int&gt;&gt;&amp; board) {
    int rows = board.size();
    int cols = board[0].size();
    int neighbors[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};

    // Step 1: Encode next state in current board
    for (int row = 0; row &lt; rows; row++) {
        for (int col = 0; col &lt; cols; col++) {
            int live_neighbors = 0;
            // Count live neighbors
            for (int i = 0; i &lt; 8; i++) {
                int r = row + neighbors[i][0];
                int c = col + neighbors[i][1];
                if (r &gt;= 0 &amp;&amp; r &lt; rows &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; cols &amp;&amp; (board[r][c] == 1 || board[r][c] == 2)) {
                    live_neighbors++;
                }
            }

            // Apply game rules using extra states
            if (board[row][col] == 1) {
                if (live_neighbors &lt; 2 || live_neighbors &gt; 3) {
                    board[row][col] = 2; // Mark as dying
                }
            } else {
                if (live_neighbors == 3) {
                    board[row][col] = 3; // Mark as becoming alive
                }
            }
        }
    }

    // Step 2: Update board with next state
    for (int row = 0; row &lt; rows; row++) {
        for (int col = 0; col &lt; cols; col++) {
            if (board[row][col] == 2) {
                board[row][col] = 0; // Dying cell becomes dead
            }
            if (board[row][col] == 3) {
                board[row][col] = 1; // Dead cell becomes alive
            }
        }
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(m * n), where m is the number of rows and n is the number of columns. We iterate over the board twice. | <b>Space Complexity:</b> O(1). We modify the board in place without any extra space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0,1,0],[0,0,1],[1,1,1],[0,0,0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The cell (1, 1) has three live neighbors, so it survives. The cell (0, 1) has one live neighbor, so it dies. The cell (1, 2) has three live neighbors, so it survives. The cell (2, 1) and (2, 2) has more than 3 live neighbours so it dies. The cell (0, 0), (0, 2), (3, 0), (3, 1), (3, 2) will have 0 live neighbors so the dead cell with exactly three live neighbors becomes a live cell.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,1],[1,0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,1],[1,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The live cells at (0,0) and (0,1) are alive in the next generation, as they have exactly two live neighbours. The live cell at (1,0) will be alive because (0,0) and (0,1) cells are alive which forms reproduction criteria.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. The in-place optimization using extra states is crucial for efficient memory usage.
2. Handling edge cases at the board boundaries is important when calculating neighbors.
3. The extra states (2 and 3) provide a smart mechanism to avoid conflicts and update the board correctly during the second pass.
4. Make sure to only update the next generation values during the second pass.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/max-value-of-equation/>Max Value of Equation</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the maximum value of the equation yi + yj + |xi - xj| where the condition |xi - xj| &lt= k and i &lt j holds.  If there is no such pair (i, j), return -Infinity.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible pairs (i, j) where i &lt j.  For each pair, check if |xi - xj| &lt= k. If it satisfies the condition, calculate yi + yj + |xi - xj| and update the maximum value found so far. This is a straightforward but inefficient approach.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int findMaxValueOfEquation(vector&lt;vector&lt;int&gt;&gt;& points, int k) {
    int max_val = INT_MIN;
    int n = points.size();
    for (int i = 0; i &lt n; ++i) {
        for (int j = i + 1; j &lt n; ++j) {
            if (abs(points[i][0] - points[j][0]) &lt= k) {
                max_val = max(max_val, points[i][1] + points[j][1] + abs(points[i][0] - points[j][0]));
            }
        }
    }
    if (max_val == INT_MIN) return -2147483648; // -Infinity
    return max_val;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2), where n is the number of points. | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized with Monotonic Queue</h5>
  <p>The problem can be efficiently solved using a monotonic decreasing queue (deque). The goal is to find a pair (i, j) where j &gt i that maximizes the value yi + yj + |xi - xj| = yi + yj + xj - xi (since xj &gt= xi). We maintain a deque of indices. When processing a point j, we iterate through the queue. For each index i in the queue, we check if it is within k distance of j. If it is, we update the max_val. Otherwise, we remove the indices from the queue. When adding a new point j, we add the index j to the queue after removing all indices i where yi &lt= yj, and then only keep the index j if the distance condition is fulfilled.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int findMaxValueOfEquation(vector&lt;vector&lt;int&gt;&gt;& points, int k) {
    int max_val = INT_MIN;
    deque&lt;int&gt; dq;
    for (int j = 0; j &lt points.size(); ++j) {
        while (!dq.empty() &amp;&amp; points[j][0] - points[dq.front()][0] &gt k) {
            dq.pop_front();
        }
        if (!dq.empty()) {
            max_val = max(max_val, points[j][1] + points[dq.front()][1] + points[j][0] - points[dq.front()][0]);
        }
        while (!dq.empty() &amp;&amp; points[j][1] &gt= points[dq.back()][1]) {
            dq.pop_back();
        }
        if(!dq.empty() &amp;&amp; abs(points[j][0] - points[dq.back()][0]) &gt; k) {
            dq.clear();
            dq.push_back(j);
        } else {
            dq.push_back(j);
        }
    }
    if (max_val == INT_MIN) return -2147483648; // -Infinity
    return max_val;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the number of points. Each point is added and removed from the deque at most once. | <b>Space Complexity:</b> O(n), for the deque.</p>
  <h5>‚û§ Optimized with Binary Search and Monotonic Queue (Slightly different implementation)</h5>
  <p>This approach uses a similar idea of maintaining a monotonic decreasing queue but adds a binary search component to speed up the search when popping from the queue. This could also improve the time performance in the worst case, though it does not change the overall complexity.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int findMaxValueOfEquation(vector&lt;vector&lt;int&gt;&gt;& points, int k) {
    int max_val = INT_MIN;
    deque&lt;int&gt; dq; // Stores indices of points

    for (int j = 0; j &lt points.size(); ++j) {
        // Remove points that are too far away (x distance > k)
        while (!dq.empty() &amp;&amp; points[j][0] - points[dq.front()][0] &gt k) {
            dq.pop_front();
        }

        // Calculate potential max value and update
        if (!dq.empty()) {
            max_val = max(max_val, points[j][1] + points[dq.front()][1] + points[j][0] - points[dq.front()][0]);
        }

        // Maintain decreasing order of y values in deque
        while (!dq.empty() &amp;&amp; points[j][1] &gt= points[dq.back()][1]) {
            dq.pop_back();
        }

        dq.push_back(j);
    }
    if (max_val == INT_MIN) return -2147483648; // -Infinity
    return max_val;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n). The deque operations take O(n) time in total. Each point is added and removed at most once. | <b>Space Complexity:</b> O(n). In the worst case, the deque can store all indices.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">points = [[1,3],[2,0],[5,10],[6,-10]], k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The equation is yi + yj + |xi - xj|.  The optimal pair is (1, 2) with value 0 + 10 + |5 - 2| = 4.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">points = [[0,0],[3,0],[9,2]], k = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The optimal pair is (0, 1) with value 0 + 0 + |3 - 0| = 3.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">points = [[-19,9],[-15,-13],[-2,15],[-3,-7],[-17,20],[-14,14],[-5,-3],[15,-16],[5,11]], k = 12</td>
        <td style="border: 1px solid #ccc; padding: 6px;">36</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Example from LeetCode.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases to consider include empty input, k being 0, and the points being far apart.  The deque approach ensures that we only consider points within the specified x-distance, which optimizes the computation.  The use of -Infinity as the default value for max_val is also crucial to handle the case where no pair satisfies the distance constraint.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/>Insert Delete GetRandom O(1) - Duplicates allowed</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Design a data structure that supports all following operations in O(1) time complexity. Implement the `RandomizedCollection` class:

*   `RandomizedCollection()`: Initializes the `RandomizedCollection` object.
*   `bool insert(int val)`: Inserts an item `val` into the collection, possibly a duplicate. Returns `true` if the collection did not already contain the specified element. 
*   `bool remove(int val)`: Removes an item `val` from the collection if present. Returns `true` if the collection contained the specified element. 
*   `int getRandom()`: Returns a random element from the current collection of elements. The probability of each element being returned is linearly related to the number of same values the collection contains.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Use a vector to store the elements. For insert, simply push the element to the vector. For remove, iterate through the vector to find the element to remove and remove it. For getRandom, generate a random index and return the element at that index. This approach is inefficient for remove operations.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

class RandomizedCollection {
private:
    vector&lt;int&gt; nums;

public:
    RandomizedCollection() {
        
    }

    bool insert(int val) {
        bool found = false;
        for (int x : nums) {
            if (x == val) {
                found = true;
                break;
            }
        }
        nums.push_back(val);
        return !found;
    }

    bool remove(int val) {
        for (int i = 0; i &lt; nums.size(); ++i) {
            if (nums[i] == val) {
                nums.erase(nums.begin() + i);
                return true;
            }
        }
        return false;
    }

    int getRandom() {
        return nums[rand() % nums.size()];
    }
};
</code></pre>
  <p><b>Time Complexity:</b> insert: O(1), remove: O(N), getRandom: O(1) | <b>Space Complexity:</b> O(N)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Hash Map and Vector</h5>
  <p>Use a vector `nums` to store the elements and a hash map `valToIndex` to store the value and their indices in the vector. When inserting, add the value to `nums` and update `valToIndex`. When removing, find the last element of the vector, replace the element to be removed with the last element, and update the hash map and vector. For getRandom, generate a random index and return the corresponding element.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

class RandomizedCollection {
private:
    vector&lt;int&gt; nums;
    unordered_map&lt;int, unordered_set&lt;int&gt;&gt; valToIndex;

public:
    RandomizedCollection() {
        
    }

    bool insert(int val) {
        nums.push_back(val);
        valToIndex[val].insert(nums.size() - 1);
        return valToIndex[val].size() == 1;
    }

    bool remove(int val) {
        if (valToIndex.find(val) == valToIndex.end()) {
            return false;
        }
        int indexToRemove = *valToIndex[val].begin();
        valToIndex[val].erase(valToIndex[val].begin());
        
        int lastElement = nums.back();
        nums[indexToRemove] = lastElement;
        nums.pop_back();

        if (val != lastElement) {
            valToIndex[lastElement].erase(nums.size());
            valToIndex[lastElement].insert(indexToRemove);
        }

        if (valToIndex[val].empty()) {
            valToIndex.erase(val);
        }
        
        return true;
    }

    int getRandom() {
        return nums[rand() % nums.size()];
    }
};
</code></pre>
  <p><b>Time Complexity:</b> insert: O(1), remove: O(1), getRandom: O(1) | <b>Space Complexity:</b> O(N)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["RandomizedCollection","insert","insert","insert","getRandom","remove","getRandom"]\n[[],[1],[1],[2],[],[1],[]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[null,true,false,true,2,true,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">RandomizedCollection randomizedCollection = new RandomizedCollection();
randomizedCollection.insert(1); // Inserts 1 to the collection. Returns true as the collection did not contain 1.
randomizedCollection.insert(1); // Inserts another 1 to the collection. Returns false as the collection contained 1.
randomizedCollection.insert(2); // Inserts 2 to the collection. Returns true as the collection did not contain 2.
randomizedCollection.getRandom(); // getRandom should return 1 with probability 2/3, and 2 with probability 1/3.
randomizedCollection.remove(1); // Removes 1 from the collection. Returns true.
randomizedCollection.getRandom(); // getRandom should return 1 and 2 both equally likely.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["RandomizedCollection","insert","remove","insert","getRandom","remove","insert","getRandom"]\n[[],[0],[0],[1],[],[0],[2],[]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[null,true,true,true,1,false,true,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Explanation for each operation.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to achieving O(1) time complexity for remove is to swap the element to be removed with the last element in the vector and then remove the last element. This avoids shifting other elements in the vector.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/largest-rectangle-in-histogram/>Largest Rectangle in Histogram</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible starting and ending points of rectangles. For each rectangle, calculate its area by finding the minimum height within that range and multiplying it by the width. Keep track of the maximum area found so far.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int largestRectangleAreaBruteForce(vector&lt;int&gt;&amp; heights) {
    int maxArea = 0;
    int n = heights.size();

    for (int i = 0; i &lt; n; ++i) {
        for (int j = i; j &lt; n; ++j) {
            // Calculate width
            int width = j - i + 1;
            // Find min height within the range
            int minHeight = heights[i];
            for (int k = i + 1; k &lt;= j; ++k) {
                minHeight = min(minHeight, heights[k]);
            }
            // Calculate area
            int area = minHeight * width;
            maxArea = max(maxArea, area);
        }
    }
    return maxArea;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^3). Outer loops iterate n times each, the inner loop to find min height iterates at max n times. | <b>Space Complexity:</b> O(1). Constant extra space.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized with Stack</h5>
  <p>Use a stack to store the indices of the bars. The stack maintains increasing order of bar heights. Iterate through the heights array.  If the current bar's height is less than the top of the stack, pop elements from the stack until the condition is met, calculating the area for each popped bar.  After iterating through the array, process any remaining elements in the stack.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int largestRectangleAreaOptimized(vector&lt;int&gt;&amp; heights) {
    int maxArea = 0;
    int n = heights.size();
    stack&lt;int&gt; s;

    for (int i = 0; i &lt;= n; ++i) {
        // Handle the end of the array by treating the height as 0
        int height = (i == n) ? 0 : heights[i];

        while (!s.empty() &amp;&amp; height &lt; heights[s.top()]) {
            int top = s.top();
            s.pop();
            int width = s.empty() ? i : i - s.top() - 1;
            maxArea = max(maxArea, heights[top] * width);
        }
        s.push(i);
    }

    return maxArea;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n).  Each element is pushed and popped at most once. | <b>Space Complexity:</b> O(n).  In the worst-case, the stack can store all the indices.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[2,1,5,6,2,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">10</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The largest rectangle is formed by the bars with heights 5 and 6, with a total area of 10.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[2,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The largest rectangle is formed by the bar with height 4, with a total area of 4.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There are no rectangles so the area is 0.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The stack-based approach is significantly more efficient. It's crucial to consider the edge cases like the end of the input array, handled by appending a 0 height, and the beginning when the stack is empty.  Also handling cases of equal heights are important for correctness.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/max-value-of-equation/>Max Value of Equation</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given an array of points where points[i] = [xi, yi] and an integer k, return the maximum value of the equation yi + yj + |xi - xj| where |xi - xj| &lt;= k and i &lt; j.  That is, find two points (i, j) within the given range such that the equation's value is maximized.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible pairs of points (i, j) such that i &lt; j and |xi - xj| &lt;= k. Calculate the value of the equation for each pair and track the maximum value.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;

using namespace std;

int maxValueOfEquation(vector&lt;vector&lt;int&gt;&gt;& points, int k) {
    int max_val = INT_MIN;
    int n = points.size();

    for (int i = 0; i &lt; n; ++i) {
        for (int j = i + 1; j &lt; n; ++j) {
            if (abs(points[i][0] - points[j][0]) &lt;= k) {
                max_val = max(max_val, points[i][1] + points[j][1] + abs(points[i][0] - points[j][0]));
            }
        }
    }

    return max_val;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2), where n is the number of points. | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized with Monotonic Queue</h5>
  <p>Utilize a monotonic queue (specifically, a deque) to store potential candidate points. The deque stores indices of points. Iterate through the points. For each point, remove points from the front of the deque that are outside the k-distance.  Also, remove points from the back of the deque whose yi - xi value is less than or equal to the current point's yi - xi value (maintaining a decreasing order). Calculate the equation's value using the front of the deque and update the maximum value. Add the current point to the deque.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;deque&gt;

using namespace std;

int maxValueOfEquation(vector&lt;vector&lt;int&gt;&gt;& points, int k) {
    int max_val = INT_MIN;
    deque&lt;int&gt; dq;

    for (int i = 0; i &lt; points.size(); ++i) {
        // Remove points outside the k distance
        while (!dq.empty() &amp;&amp; points[i][0] - points[dq.front()][0] &gt; k) {
            dq.pop_front();
        }

        // Calculate value if any valid previous point exists
        if (!dq.empty()) {
            max_val = max(max_val, points[i][1] + points[dq.front()][1] + abs(points[i][0] - points[dq.front()][0]));
        }

        // Maintain decreasing order of (yi - xi)
        while (!dq.empty() &amp;&amp; points[i][1] - points[i][0] &gt;= points[dq.back()][1] - points[dq.back()][0]) {
            dq.pop_back();
        }

        dq.push_back(i);
    }

    return max_val;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the number of points. Each point is visited at most twice (once when added to the deque and once when removed). | <b>Space Complexity:</b> O(n) in the worst case, where n is the number of points, for the deque.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">points = [[1,3],[2,0],[5,10],[6,-10]], k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The optimal pair is (1, 2) with value 0 + 10 + |2 - 5| = 13.  However the constraint makes the selection of pair (1,2) not valid.
(1,3) is invalid (2-6). Hence, pairs (0,1) = 3+0+|1-2|=4 is the optimal.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">points = [[0,0],[3,0],[9,2]], k = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The optimal pair is (0, 1) with value 0 + 0 + |0 - 3| = 3.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">points = [[-19,-12],[-13,16],[-12,18],[-11,-7],[-8,16],[-7,19],[-5,-9],[3,13],[7,-2], [19,19]], k = 10</td>
        <td style="border: 1px solid #ccc; padding: 6px;">42</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The optimal pair is (-7,7) with value 19+(-2)+|7-(-7)| = 42.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The core idea is to reduce the time complexity of the nested loops.  The monotonic queue helps keep track of the best candidate point for the equation, optimizing the search process. The constraint |xi - xj| &lt;= k simplifies the search space.</p>
</div>
<hr style="margin: 40px 0;">
<h2>Strings</h2>
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/valid-parentheses/>Valid Parentheses</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given a string `s` containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.  A string is valid if:

1.  Open brackets must be closed by the same type of brackets.
2.  Open brackets must be closed in the correct order.
3.  Every close bracket has a corresponding open bracket of the same type.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach would involve checking all possible permutations of the brackets to determine if they are valid. However, this is inefficient because the order matters, and we are not just checking for the presence of brackets. This approach is thus not a viable solution.</p>
  <pre><code class="language-python">// Not applicable for this problem due to the nature of the problem and inefficiencies of brute force for bracket matching.
// Brute force here would involve checking all permutations which is unnecessary and inefficient.</code></pre>
  <p><b>Time Complexity:</b> O(N!), where N is the length of the string. This is due to the permutations, which makes it highly inefficient. | <b>Space Complexity:</b> O(N), due to the permutations calls could potentially store all characters.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Stack-based Approach</h5>
  <p>This approach uses a stack to keep track of the opening brackets. When an opening bracket is encountered, it is pushed onto the stack. When a closing bracket is encountered, the top element of the stack is checked. If the stack is empty or the top element doesn't match the corresponding opening bracket, the string is invalid. If the top element matches, it's popped from the stack. Finally, if the stack is empty at the end, the string is valid; otherwise, it's invalid.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt

using namespace std;

bool isValid(string s) {
    stack&ltchar&gt st;
    for (char c : s) {
        if (c == '(' || c == '[' || c == '{') {
            st.push(c);
        } else {
            if (st.empty()) {
                return false;
            }
            char top = st.top();
            st.pop();
            if ((c == ')' &amp;&amp; top != '(') || (c == ']' &amp;&amp; top != '[') || (c == '}' &amp;&amp; top != '{')) {
                return false;
            }
        }
    }
    return st.empty();
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the length of the string. We iterate through the string once. | <b>Space Complexity:</b> O(N) in the worst-case scenario where the string consists of only opening brackets.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">()</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The parentheses are properly matched.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">()[]{}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">All bracket types are properly matched and ordered.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">(]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The closing bracket ']' does not match the opening bracket '('.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">([)]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The closing brackets are not in the correct order.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">{[]}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The brackets are correctly matched and ordered.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The closing bracket has no corresponding opening bracket.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Important edge cases:

1.  Empty string: Should return `true`.
2.  String with only closing brackets: Should return `false`.
3.  Unmatched brackets: Ensure proper handling of unmatched opening or closing brackets.
4. Order of brackets: Parentheses must be closed in the correct order. Consider the stack's behavior, and make sure that the order of opening and closing characters is respected.
5. Different types of brackets: Handle different bracket types { [ ( properly.
6.  Mixed brackets: Test cases like '{[()]}' should be covered.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/print-all-the-duplicates-in-the-input-string/>Print all the duplicates in the input string</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given a string, the task is to print all the duplicate characters in the input string. For example, given the string "test string", the output should be 't', 's', 'r', 'i', 'n', 'g'.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the string. For each character, iterate through the rest of the string to count its occurrences. If the count is greater than 1, and the character hasn't been printed yet (to avoid duplicates in output), print it.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

void printDuplicatesBruteForce(string str) {
    int n = str.length();
    unordered_set&ltchar&gt printed;
    for (int i = 0; i &lt n; i++) {
        int count = 1;
        for (int j = i + 1; j &lt n; j++) {
            if (str[i] == str[j]) {
                count++;
            }
        }
        if (count &gt 1 &amp;&amp; printed.find(str[i]) == printed.end()) {
            cout &lt&lt str[i] &lt&lt " ";
            printed.insert(str[i]);
        }
    }
    cout &lt&lt endl;
}

int main() {
    string str = "test string";
    printDuplicatesBruteForce(str);
    return 0;
}</code></pre>
  <p><b>Time Complexity:</b> O(n^2), where n is the length of the string.  Nested loops iterate through the string. | <b>Space Complexity:</b> O(k), where k is the number of distinct duplicate characters (to store in the `printed` set).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Using a Hash Map</h5>
  <p>Use a hash map (unordered_map in C++) to store the frequency of each character in the string. Iterate through the string, and for each character, increment its count in the hash map. After counting the frequency of each character, iterate through the hash map, and print the characters with a frequency greater than 1.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

void printDuplicatesOptimized(string str) {
    int n = str.length();
    unordered_map&ltchar, int&gt charCount;
    for (char c : str) {
        charCount[c]++;
    }
    for (auto const& [key, val] : charCount) {
        if (val &gt 1) {
            cout &lt&lt key &lt&lt " ";
        }
    }
    cout &lt&lt endl;
}

int main() {
    string str = "test string";
    printDuplicatesOptimized(str);
    return 0;
}</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the length of the string. We iterate through the string twice in the worst case. First to build the hashmap, and then to iterate through the map to check the occurrences | <b>Space Complexity:</b> O(k), where k is the number of unique characters in the string.  The hash map stores character frequencies.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">test string</td>
        <td style="border: 1px solid #ccc; padding: 6px;">t s r i n g </td>
        <td style="border: 1px solid #ccc; padding: 6px;">The characters 't', 's', 'r', 'i', 'n', 'g' appear more than once.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">geeksforgeeks</td>
        <td style="border: 1px solid #ccc; padding: 6px;">g e k s </td>
        <td style="border: 1px solid #ccc; padding: 6px;">The characters 'g', 'e', 'k', and 's' appear more than once.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">aabbcde</td>
        <td style="border: 1px solid #ccc; padding: 6px;">a b </td>
        <td style="border: 1px solid #ccc; padding: 6px;">The characters 'a' and 'b' appear more than once.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The optimized approach using a hash map is generally preferred for its better time complexity.  Consider case sensitivity (e.g., 'A' and 'a' considered duplicates or not) based on problem requirements.  The output can include spaces, so the prompt should be checked for proper format requirements. Empty input strings should be handled correctly (e.g., no output). In this solution, duplicates are printed once.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/implement-strstr/>Implement strStr()</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given two strings `haystack` and `needle`, return the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`.  The function should return 0 if `needle` is an empty string.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the `haystack` string.  At each position, check if the `needle` string matches the substring of `haystack` starting at that position.  If a match is found, return the starting index. If the entire `haystack` is traversed without a match, return -1.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int strStr_brute_force(string haystack, string needle) {
    int n = haystack.length();
    int m = needle.length();

    if (m == 0) {
        return 0;
    }

    for (int i = 0; i &lt;= n - m; i++) {
        int j;
        for (j = 0; j &lt; m; j++) {
            if (haystack[i + j] != needle[j]) {
                break;
            }
        }
        if (j == m) {
            return i;
        }
    }

    return -1;
}
</code></pre>
  <p><b>Time Complexity:</b> O(m * n), where n is the length of `haystack` and m is the length of `needle`. In the worst case, we might need to compare `needle` with every substring of `haystack`. | <b>Space Complexity:</b> O(1), as we are only using a constant amount of extra space.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach (Sliding Window)</h5>
  <p>The sliding window approach uses a similar concept as brute force but avoids unnecessary character comparisons by carefully checking and comparing substrings. If a character mismatch occurs, the window moves to the next position. We compare the `needle` string to the substrings of the `haystack` string one by one. This approach has a better time complexity.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int strStr_optimized(string haystack, string needle) {
    int n = haystack.length();
    int m = needle.length();

    if (m == 0) {
        return 0;
    }

    for (int i = 0; i &lt;= n - m; i++) {
        if (haystack.substr(i, m) == needle) {
            return i;
        }
    }
    return -1;
}
</code></pre>
  <p><b>Time Complexity:</b> O(m * n), where n is the length of `haystack` and m is the length of `needle`. In the worst-case scenario, the substring comparison can take O(m) time, and we potentially iterate through all possible starting positions in the `haystack`, leading to O(n) iterations. This approach uses a higher constant factor than the brute force method, but achieves the same time complexity. | <b>Space Complexity:</b> O(1), as we only use a constant amount of extra space. The `substr` function may create temporary strings, but it depends on the underlying implementation and its complexity does not affect our total space complexity.</p>
  <h5>‚û§ KMP Algorithm (Knuth-Morris-Pratt)</h5>
  <p>The Knuth-Morris-Pratt (KMP) algorithm is a more advanced and optimized approach that achieves linear time complexity. It preprocesses the `needle` string to create a 'longest proper prefix suffix' (LPS) array. This array helps determine how much to shift the pattern when a mismatch occurs, thus avoiding unnecessary comparisons and significantly optimizing the search process. The algorithm takes O(n) and O(m) time for preprocessing, but has an overall time complexity of O(n + m), where n is the length of `haystack` and m is the length of `needle`.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Function to calculate the LPS array
vector&lt;int&gt; computeLPSArray(string needle) {
    int m = needle.length();
    vector&lt;int&gt; lps(m, 0);
    int len = 0;
    int i = 1;

    while (i &lt; m) {
        if (needle[i] == needle[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    return lps;
}

int strStr_kmp(string haystack, string needle) {
    int n = haystack.length();
    int m = needle.length();

    if (m == 0) {
        return 0;
    }

    vector&lt;int&gt; lps = computeLPSArray(needle);
    int i = 0; // index for haystack
    int j = 0; // index for needle

    while (i &lt; n) {
        if (needle[j] == haystack[i]) {
            j++;
            i++;
        }

        if (j == m) {
            return i - j;
            j = lps[j - 1];
        } else if (i &lt; n &amp;&amp; needle[j] != haystack[i]) {
            if (j != 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
    }
    return -1;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n + m), where n is the length of `haystack` and m is the length of `needle`. The LPS array calculation takes O(m) and the search operation takes O(n). | <b>Space Complexity:</b> O(m), for the LPS array.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">haystack = "sadbutsad", needle = "sad"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The substring "sad" is found at the beginning of the string "sadbutsad".</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">haystack = "leetcode", needle = "leeto"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The substring "leeto" is not present in "leetcode".</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">haystack = "", needle = ""</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Empty string is considered to be present at index 0.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">haystack = "abc", needle = "c"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The substring "c" is found at index 2.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  Handle the edge case where `needle` is an empty string.
2.  Consider the case where `needle` is not found in `haystack` and return -1.
3.  The KMP algorithm is the most efficient solution but is more complex to implement.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/longest-common-prefix/>Longest Common Prefix</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given an array of strings `strs`, find the longest common prefix string amongst the strings. If there is no common prefix, return an empty string "".</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the strings, character by character. For each character index, check if all strings have the same character at that index. If they do, append the character to the prefix. If not, or if any string is shorter than the current index, return the prefix found so far.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string longestCommonPrefixBruteForce(vector&lt;string&gt;&amp; strs) {
    if (strs.empty()) {
        return "";
    }

    string prefix = "";
    for (int i = 0; ; ++i) {
        char currentChar = '\0';
        for (int j = 0; j &lt; strs.size(); ++j) {
            if (i &gt;= strs[j].length()) {
                return prefix;
            }
            if (j == 0) {
                currentChar = strs[j][i];
            } else if (strs[j][i] != currentChar) {
                return prefix;
            }
        }
        prefix += currentChar;
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(S), where S is the sum of all characters in all strings. In the worst-case scenario, all strings have the same prefix. | <b>Space Complexity:</b> O(1). We use constant extra space.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Horizontal Scanning</h5>
  <p>Iterate through the array of strings. Initialize the prefix to the first string. Then, for each subsequent string, update the prefix by comparing it with the current string. Remove characters from the end of the prefix until it matches the beginning of the current string. If the prefix becomes empty at any point, return an empty string.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string longestCommonPrefixHorizontalScanning(vector&lt;string&gt;&amp; strs) {
    if (strs.empty()) {
        return "";
    }

    string prefix = strs[0];
    for (int i = 1; i &lt; strs.size(); ++i) {
        while (strs[i].find(prefix) != 0) {
            prefix = prefix.substr(0, prefix.length() - 1);
            if (prefix.empty()) {
                return "";
            }
        }
    }
    return prefix;
}
</code></pre>
  <p><b>Time Complexity:</b> O(S), where S is the sum of all characters in all strings. In the worst-case, all strings are almost identical, and the inner loop iterates many times. However, the best case would be O(m * n) where m is the average string length and n is the number of strings. (If strings are very different, find() finds no match early.) | <b>Space Complexity:</b> O(1). We use constant extra space.</p>
  <h5>‚û§ Vertical Scanning</h5>
  <p>Iterate through the characters of the first string. For each character, check if all other strings have the same character at the same index. If any string is shorter or has a different character, return the prefix found so far. Otherwise, continue to the next character.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string longestCommonPrefixVerticalScanning(vector&lt;string&gt;&amp; strs) {
    if (strs.empty()) {
        return "";
    }

    string prefix = "";
    for (int i = 0; i &lt; strs[0].length(); ++i) {
        char currentChar = strs[0][i];
        for (int j = 1; j &lt; strs.size(); ++j) {
            if (i &gt;= strs[j].length() || strs[j][i] != currentChar) {
                return prefix;
            }
        }
        prefix += currentChar;
    }
    return prefix;
}
</code></pre>
  <p><b>Time Complexity:</b> O(S), where S is the sum of all characters in all strings. In the worst case, all strings are almost identical. | <b>Space Complexity:</b> O(1). We use constant extra space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["flower","flow","flight"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">fl</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The common prefix is "fl".</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["dog","racecar","car"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;"></td>
        <td style="border: 1px solid #ccc; padding: 6px;">There is no common prefix.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["", ""]</td>
        <td style="border: 1px solid #ccc; padding: 6px;"></td>
        <td style="border: 1px solid #ccc; padding: 6px;">Empty strings, the common prefix is empty.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["abc"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">abc</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Single string, the common prefix is the string itself.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["abab","aba","abc"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">ab</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The longest common prefix is "ab".</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Consider edge cases like empty input array, empty strings in the array, and single-element arrays. The vertical scanning approach is generally preferred for its clarity and efficiency.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/valid-palindrome-ii/>Valid Palindrome II</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given a string s, return true if the s can be a palindrome after deleting at most one character from it.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the string and for each character, try deleting it and checking if the remaining string is a palindrome. If any deletion results in a palindrome, return true.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool isPalindrome(string s, int l, int r) {
    while (l &lt r) {
        if (s[l] != s[r]) {
            return false;
        }
        l++;
        r--;
    }
    return true;
}

bool validPalindrome(string s) {
    int n = s.length();
    for (int i = 0; i &lt n; i++) {
        string temp = s.substr(0, i) + s.substr(i + 1);
        if (isPalindrome(temp, 0, temp.length() - 1)) {
            return true;
        }
    }
    return isPalindrome(s, 0, n - 1);
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2), where n is the length of the string.  The isPalindrome function takes O(n) time, and we potentially call it n times. | <b>Space Complexity:</b> O(n), for the temporary string created in each iteration.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Two Pointers with Deletion</h5>
  <p>Use two pointers, one at the beginning and one at the end.  If the characters at the pointers match, move the pointers inward. If they don't match, try deleting either the left or the right character and check if the remaining substring is a palindrome.  If either deletion makes it a palindrome, return true.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool isPalindrome(string s, int l, int r) {
    while (l &lt r) {
        if (s[l] != s[r]) {
            return false;
        }
        l++;
        r--;
    }
    return true;
}

bool validPalindrome(string s) {
    int l = 0, r = s.length() - 1;
    while (l &lt r) {
        if (s[l] != s[r]) {
            // Try deleting left or right character
            return isPalindrome(s, l + 1, r) || isPalindrome(s, l, r - 1);
        }
        l++;
        r--;
    }
    return true;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the length of the string.  We iterate through the string at most twice. | <b>Space Complexity:</b> O(1), constant extra space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">"aba"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The string is already a palindrome.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">"abca"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">You can delete the 'c'.  The remaining string is "aba".</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">"abc"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Deleting any single character won't make it a palindrome.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">"ebcbbececabbacecbbcbe"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Deleting the first 'e' makes it a palindrome.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key insight is to recognize that if a single character deletion can solve the problem, it means that, at most, one pair of mismatched characters needs to be resolved. Optimize by using two pointers and by trying to delete either of the mismatch characters in case of a mismatch.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/integer-to-roman/>Integer to Roman</a> <span style="font-size:14px; color:#888;">Medium </span></h3>
  <p>Given an integer, convert it to a roman numeral. You are guaranteed that the input integer is within the range from 1 to 3999.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the number, subtracting values corresponding to Roman numerals (M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I) as many times as possible and appending the corresponding Roman numeral to the result string.  This is a straightforward approach that directly implements the conversion process.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string intToRomanBruteForce(int num) {
    string result = "";
    vector&lt;int&gt; values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    vector&lt;string&gt; symbols = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};

    for (int i = 0; num &gt; 0; ++i) {
        while (num &gt;= values[i]) {
            result += symbols[i];
            num -= values[i];
        }
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(1), due to the fixed upper bound of the input (3999). The loop iterates a maximum of 13 times, and the operations inside are constant time. | <b>Space Complexity:</b> O(1), constant extra space is used.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Greedy with Predefined Values</h5>
  <p>Similar to the brute force approach, but still uses the predefined values and symbols, which makes it efficient. The core logic iterates through the value and symbol lists, subtracting the largest possible value at each step.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string intToRomanOptimized(int num) {
    string result = "";
    vector&lt;int&gt; values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    vector&lt;string&gt; symbols = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};

    for (int i = 0; i &lt; values.size(); ++i) {
        while (num &gt;= values[i]) {
            result += symbols[i];
            num -= values[i];
        }
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(1), because the number of iterations is bounded (maximum of 13 iterations). | <b>Space Complexity:</b> O(1), constant space is used for storing values and symbols.</p>
  <h5>‚û§ Using a Map</h5>
  <p>We can also use a map to store the Roman numeral values along with corresponding integers. This doesn't offer a significant performance boost, but showcases an alternative way to organize the mapping.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string intToRomanMap(int num) {
    string result = "";
    map&lt;int, string&gt; romanMap = {
        {1000, "M"},
        {900, "CM"},
        {500, "D"},
        {400, "CD"},
        {100, "C"},
        {90, "XC"},
        {50, "L"},
        {40, "XL"},
        {10, "X"},
        {9, "IX"},
        {5, "V"},
        {4, "IV"},
        {1, "I"}
    };

    for (auto const&amp; [value, symbol] : romanMap) {
        while (num &gt;= value) {
            result += symbol;
            num -= value;
        }
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(1) due to the fixed size of the map. | <b>Space Complexity:</b> O(1) because the space used by the map is constant.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">III</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3 is represented as three 1s.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">58</td>
        <td style="border: 1px solid #ccc; padding: 6px;">LVIII</td>
        <td style="border: 1px solid #ccc; padding: 6px;">L = 50, V = 5, III = 3.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1994</td>
        <td style="border: 1px solid #ccc; padding: 6px;">MCMXCIV</td>
        <td style="border: 1px solid #ccc; padding: 6px;">M = 1000, CM = 900, XC = 90, IV = 4.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The input integer is guaranteed to be within the range [1, 3999]. This constraint ensures that the solution will have a limited number of Roman numeral combinations to consider. Special cases like 4, 9, 40, 90, 400, and 900 (e.g., IV, IX, XL, XC, CD, CM) should be handled correctly.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/generate-parentheses/>Generate Parentheses</a> <span style="font-size:14px; color:#888;">Medium </span></h3>
  <p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Generate all possible sequences of '(' and ')' of length 2n, and then filter out the invalid ones. A sequence is valid if, at any point, the number of '(' is greater than or equal to the number of ')', and the total number of '(' equals the total number of ')'.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

using namespace std;

// Function to check if a parenthesis string is valid
bool isValid(const string& s) {
    int balance = 0;
    for (char c : s) {
        if (c == '(') {
            balance++;
        } else if (c == ')') {
            balance--;
        }
        if (balance &lt; 0) {
            return false;
        }
    }
    return balance == 0;
}

// Brute-force approach to generate all parenthesis combinations
vector&lt;string&gt; generateParenthesis_bruteForce(int n) {
    vector&lt;string&gt; result;
    string s(2 * n, ' ');

    // Generate all possible combinations of '(' and ')'
    for (int i = 0; i &lt; (1 &lt;&lt; (2 * n)); ++i) {
        int open = 0, close = 0;
        for (int j = 0; j &lt; 2 * n; ++j) {
            if ((i & (1 &lt;&lt; j)) == 0) {
                s[j] = '(';
                open++;
            } else {
                s[j] = ')';
                close++;
            }
        }

        // Check if the generated string is valid and if it has equal number of '(' and ')'
        if (open == n &amp;&amp; close == n &amp;&amp; isValid(s)) {
            result.push_back(s);
        }
    }

    return result;
}

</code></pre>
  <p><b>Time Complexity:</b> O(2^(2n) * n).  Generating all possible strings takes O(2^(2n)) and checking each string for validity takes O(n). | <b>Space Complexity:</b> O(n) for the string and O(2^(2n)) to store all valid parenthesis combinations in the worst case.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Backtracking</h5>
  <p>The problem can be solved using backtracking.  We keep track of the number of open and close parentheses used. At each step, we have two choices: add an open parenthesis if we haven't used all the open parentheses, or add a close parenthesis if the number of close parentheses is less than the number of open parentheses.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

using namespace std;

// Backtracking function to generate all parenthesis combinations
void backtrack(vector&lt;string&gt;&amp; result, string current, int open, int close, int n) {
    // Base case: If we've used all parentheses, add the current string to the result
    if (current.length() == 2 * n) {
        result.push_back(current);
        return;
    }

    // If we can add an open parenthesis, do so
    if (open &lt; n) {
        backtrack(result, current + '(', open + 1, close, n);
    }

    // If we can add a close parenthesis, do so
    if (close &lt; open) {
        backtrack(result, current + ')', open, close + 1, n);
    }
}

// Optimized approach to generate all parenthesis combinations using backtracking
vector&lt;string&gt; generateParenthesis_optimized(int n) {
    vector&lt;string&gt; result;
    backtrack(result, "", 0, 0, n);
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(4^n / sqrt(n)).  The time complexity is related to the nth Catalan number, which is the number of valid parentheses combinations. | <b>Space Complexity:</b> O(n). The space complexity is for the recursion stack and for storing the result. The recursion depth is at most n.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">["((()))","(()())","(())()","()(())","()()()"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The function generates all valid combinations of 3 pairs of parentheses.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">["()"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The function generates the single valid combination for 1 pair of parentheses.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">["()()","(())"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The function generates all valid combinations of 2 pairs of parentheses.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The number of valid parenthesis combinations for n pairs is given by the nth Catalan number, which grows exponentially.  The backtracking approach is much more efficient than the brute-force approach.  Consider edge cases like n = 0, which should return an empty string or "". Also consider the case where n &lt; 0 - though not explicitly stated, the function should likely return an empty vector in this scenario or throw an exception.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/simplify-path/>Simplify Path</a> <span style="font-size:14px; color:#888;">Medium </span></h3>
  <p>Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, simplify it. In a Unix-style file system, a period '.' refers to the current directory, and two periods '..' refer to the parent directory. Return the simplified canonical path.

The canonical path should have the following format:

*   The path starts with a single slash '/'.
*   Any two directories are separated by a single slash '/'.
*   The path does not end with a trailing '/'.
*   The path only contains the directories on the path from the root to the target file or directory (i.e., no '.' or '..').

Note that the canonical path must not contain any leading or trailing slashes, or multiple consecutive slashes.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves splitting the path string by '/' to get individual directory or file names. Then, iterate through these names. If a name is '.', ignore it. If it's '..', go back to the previous directory (if there is one). Otherwise, add the directory to the result. Finally, construct the simplified path by joining the remaining directories with '/'.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

string simplifyPathBruteForce(string path) {
    vector&lt;string&gt; components;
    stringstream ss(path);
    string component;

    while (getline(ss, component, '/')) {
        if (!component.empty()) {
            components.push_back(component);
        }
    }

    vector&lt;string&gt; stack;
    for (const string&amp; comp : components) {
        if (comp == "." || comp.empty()) {
            continue;
        } else if (comp == "..") {
            if (!stack.empty()) {
                stack.pop_back();
            }
        } else {
            stack.push_back(comp);
        }
    }

    string result = "/";
    for (const string&amp; dir : stack) {
        result += dir + "/";
    }

    if (result.length() &gt; 1) {
        result.pop_back(); // Remove trailing slash if not just "/"
    }

    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the length of the input path.  Splitting the string, iterating and manipulating the stack all take linear time. | <b>Space Complexity:</b> O(N) in the worst case, where N is the length of the input path.  The stack can store up to N elements (all the directory/file names).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Using Stack</h5>
  <p>This approach is similar to the brute-force, but it's optimized by not splitting the path initially but by directly processing each component after tokenization by '/'.  We use a stack to store the directory names.

1.  Split the path string by '/'.
2.  Iterate through the components:
    *   If the component is '.', ignore it.
    *   If the component is '..', pop the top element from the stack if the stack is not empty.
    *   Otherwise, push the component onto the stack.
3.  Construct the simplified path by joining the remaining elements in the stack with '/'. Add a leading '/'.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

string simplifyPath(string path) {
    vector&lt;string&gt; components;
    stringstream ss(path);
    string component;

    while (getline(ss, component, '/')) {
        if (!component.empty()) {
            components.push_back(component);
        }
    }

    vector&lt;string&gt; stack;
    for (const string&amp; comp : components) {
        if (comp == ".") {
            continue;
        } else if (comp == "..") {
            if (!stack.empty()) {
                stack.pop_back();
            }
        } else {
            stack.push_back(comp);
        }
    }

    string result = "/";
    for (const string&amp; dir : stack) {
        result += dir + "/";
    }

    if (result.length() &gt; 1) {
        result.pop_back();
    }

    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the length of the input path. The string splitting and stack operations take linear time. | <b>Space Complexity:</b> O(N) in the worst case, where N is the length of the input path. The stack can store up to N elements.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">/home/</td>
        <td style="border: 1px solid #ccc; padding: 6px;">/home</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Trailing slash is removed.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">/../</td>
        <td style="border: 1px solid #ccc; padding: 6px;">/</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Going up from root results in root.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">/home//foo/</td>
        <td style="border: 1px solid #ccc; padding: 6px;">/home/foo</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Consecutive slashes are collapsed to single slash.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">/a/./b/../../c/</td>
        <td style="border: 1px solid #ccc; padding: 6px;">/c</td>
        <td style="border: 1px solid #ccc; padding: 6px;">'.' means current directory, '..' means move up one level.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">/a/../../b/../c//.//</td>
        <td style="border: 1px solid #ccc; padding: 6px;">/c</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Another example using '.' and '..' </td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Important edge cases to consider:

*   Handle multiple consecutive slashes correctly.
*   Handle the cases where '..' appears at the root (e.g., "/../").
*   Be mindful of leading and trailing slashes in the result.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/reverse-words-in-a-string/>Reverse Words in a String</a> <span style="font-size:14px; color:#888;">Medium </span></h3>
  <p>Given an input string `s`, reverse the order of the words. A word is defined as a sequence of non-space characters. The words in `s` will be separated by at least one space. Return a string of the words in reverse order concatenated by a single space.  Also, the reversed string should not have leading or trailing spaces and multiple spaces between words should be reduced to a single space.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Split the string by spaces, filter out empty strings (spaces), reverse the resulting word list, and join them back with single spaces.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string reverseWordsBruteForce(string s) {
    vector&lt;string&gt; words;
    string word;
    for (char c : s) {
        if (c == ' ') {
            if (!word.empty()) {
                words.push_back(word);
                word = "";
            }
        } else {
            word += c;
        }
    }
    if (!word.empty()) {
        words.push_back(word);
    }

    reverse(words.begin(), words.end());

    string result;
    for (int i = 0; i &lt words.size(); ++i) {
        result += words[i];
        if (i &lt words.size() - 1) {
            result += ' ';
        }
    }

    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the length of the string (split, trim, reverse, and join operations). | <b>Space Complexity:</b> O(N), to store the words in the vector.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized with In-place Reverse and Trimming</h5>
  <p>1. Remove leading/trailing spaces.
2. Remove extra spaces between words.
3. Reverse the entire string.
4. Reverse each word in place.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Helper function to remove extra spaces
string removeExtraSpaces(string s) {
    string result = "";
    bool spaceFound = false;
    for (char c : s) {
        if (c == ' ') {
            if (!result.empty() && result.back() != ' ') {
                result += c;
                spaceFound = true;
            }
        } else {
            result += c;
            spaceFound = false;
        }
    }

    if (!result.empty() && result.back() == ' ') {
        result.pop_back(); // remove trailing space
    }
    return result;
}

// Helper function to reverse a string
void reverseString(string& s, int start, int end) {
    while (start &lt end) {
        swap(s[start], s[end]);
        start++;
        end--;
    }
}

string reverseWordsOptimized(string s) {
    s = removeExtraSpaces(s);
    reverseString(s, 0, s.length() - 1);
    int start = 0;
    for (int i = 0; i &lt s.length(); ++i) {
        if (s[i] == ' ') {
            reverseString(s, start, i - 1);
            start = i + 1;
        }
    }
    reverseString(s, start, s.length() - 1);
    return s;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the length of the string. | <b>Space Complexity:</b> O(1), in-place modifications.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">the sky is blue</td>
        <td style="border: 1px solid #ccc; padding: 6px;">blue is sky the</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The words are reversed in order.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">  hello world  </td>
        <td style="border: 1px solid #ccc; padding: 6px;">world hello</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Leading and trailing spaces are removed, and multiple spaces between words are handled.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">a good   example</td>
        <td style="border: 1px solid #ccc; padding: 6px;">example good a</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Multiple spaces are collapsed to a single space.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">  Bob    Loves  Alice   </td>
        <td style="border: 1px solid #ccc; padding: 6px;">Alice Loves Bob</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Leading and trailing spaces are removed, and multiple spaces between words are handled.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases include leading/trailing spaces, multiple spaces between words, and empty input strings. The in-place approach is preferred for its space efficiency.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/>Rabin-Karp Algorithm for Pattern Searching</a> <span style="font-size:14px; color:#888;">Medium </span></h3>
  <p>The Rabin-Karp algorithm is a string searching algorithm that uses hashing to find the occurrence of a pattern within a text. The algorithm works by calculating the hash value of the pattern and comparing it with the hash values of all the substrings of the text that are the same length as the pattern. If the hash values match, then the algorithm performs a character-by-character comparison to confirm whether it is a true match or a collision. The goal is to find all occurrences of the pattern in the given text.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach iterates through the text and, for each position, checks if the substring of the text starting at that position matches the pattern. This involves comparing the pattern with every possible substring of the text.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

vector&lt;int&gt; bruteForceSearch(string text, string pattern) {
    vector&lt;int&gt; occurrences;
    int n = text.length();
    int m = pattern.length();

    for (int i = 0; i &lt= n - m; ++i) {
        bool match = true;
        for (int j = 0; j &lt m; ++j) {
            if (text[i + j] != pattern[j]) {
                match = false;
                break;
            }
        }
        if (match) {
            occurrences.push_back(i);
        }
    }
    return occurrences;
}

// int main() {
//     string text = "ABABDABACDABABCABAB";
//     string pattern = "ABABCABAB";
//     vector&lt;int&gt; result = bruteForceSearch(text, pattern);
//     if (result.empty()) {
//         cout &lt&lt "Pattern not found\n";
//     } else {
//         cout &lt&lt "Pattern found at indices: ";
//         for (int index : result) {
//             cout &lt&lt index &lt&lt " ";
//         }
//         cout &lt&lt endl;
//     }
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(m*n), where n is the length of the text and m is the length of the pattern. In the worst case, the inner loop (comparing characters) runs m times for each of the n-m+1 possible starting positions. | <b>Space Complexity:</b> O(1) - constant extra space. O(k) if we consider storing all indices found, where k is number of times the pattern is present</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Rabin-Karp Algorithm</h5>
  <p>The Rabin-Karp algorithm uses a rolling hash function to efficiently search for the pattern.  It calculates the hash value for the pattern and the first substring of the text.  It then slides a window of the pattern's length across the text. Instead of recalculating the hash for each substring, it uses the previous hash value and efficiently updates it based on the new character entering and the old character leaving the window. If the hashes match, it performs a character-by-character comparison to confirm the match, addressing potential hash collisions.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// d is the number of characters in the input alphabet
// q is a prime number
#define d 256

vector&lt;int&gt; rabinKarpSearch(string text, string pattern, int q) {
    vector&lt;int&gt; occurrences;
    int n = text.length();
    int m = pattern.length();
    int i, j;
    int p = 0; // hash value for pattern
    int t = 0; // hash value for text
    int h = 1;

    // The value of h would be "pow(d, M-1)%q"
    for (i = 0; i &lt m - 1; i++)
        h = (h * d) % q;

    // Calculate the hash value of pattern and first window of text
    for (i = 0; i &lt m; i++) {
        p = (d * p + pattern[i]) % q;
        t = (d * t + text[i]) % q;
    }

    // Slide the pattern over text one by one
    for (i = 0; i &lt= (n - m); i++) {

        // Check the hash values of current window of text and
        // pattern. If the hash values match then only
        // check for characters one by one
        if (p == t) {
            /* Check for characters one by one */
            for (j = 0; j &lt m; j++) {
                if (text[i + j] != pattern[j])
                    break;
            }

            // if p == t and pat[0...M-1] = txt[i, i+1, ...i+M-1]
            if (j == m)
                occurrences.push_back(i);
        }

        // Calculate hash value for next window of text:
        // Remove leading digit, add trailing digit
        if (i &lt (n - m)) {
            t = (d * (t - text[i] * h) + text[i + m]) % q;

            // We might get negative value of t, converting it to positive
            if (t &lt 0)
                t = (t + q);
        }
    }
    return occurrences;
}

// int main() {
//     string text = "ABABDABACDABABCABAB";
//     string pattern = "ABABCABAB";
//     int q = 101; // A prime number
//     vector&lt;int&gt; result = rabinKarpSearch(text, pattern, q);
//     if (result.empty()) {
//         cout &lt&lt "Pattern not found\n";
//     } else {
//         cout &lt&lt "Pattern found at indices: ";
//         for (int index : result) {
//             cout &lt&lt index &lt&lt " ";
//         }
//         cout &lt&lt endl;
//     }
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(n+m) on average and in the best case.  In the worst case (e.g., many hash collisions), it becomes O(m*n). | <b>Space Complexity:</b> O(1) - constant extra space. O(k) if we consider storing all indices found, where k is number of times the pattern is present</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">text = "THIS IS A TEST TEXT", pattern = "TEST"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Pattern found at index 10</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The pattern "TEST" is found at index 10 in the text.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">text = "ABABDABACDABABCABAB", pattern = "ABABCABAB"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Pattern found at index 10</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The pattern "ABABCABAB" is found at index 10 in the text.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">text = "AAAAAAA", pattern = "AAA",</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Pattern found at indices: 0 1 2 3 4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The pattern "AAA" is found at indices 0, 1, 2, 3 and 4.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. The Rabin-Karp algorithm's efficiency hinges on a good hash function that minimizes collisions.  2. The choice of the prime number `q` is important. If `q` is small and the alphabet size `d` is large, there could be many collisions. 3. The algorithm is particularly efficient when the pattern appears frequently in the text, as it avoids redundant character comparisons due to the rolling hash.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/group-anagrams/>Group Anagrams</a> <span style="font-size:14px; color:#888;">Medium </span></h3>
  <p>Given an array of strings `strs`, group the anagrams together. You can return the answer in any order.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the array. For each string, compare it with every other string to see if they are anagrams. If an anagram is found, group them together. Repeat until all strings are processed.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool isAnagram(string s1, string s2) {
    if (s1.length() != s2.length()) {
        return false;
    }
    sort(s1.begin(), s1.end());
    sort(s2.begin(), s2.end());
    return s1 == s2;
}

vector&lt;vector&lt;string&gt;&gt; groupAnagrams_bruteForce(vector&lt;string&gt;&amp; strs) {
    vector&lt;vector&lt;string&gt;&gt; result;
    vector&lt;bool&gt; used(strs.size(), false);

    for (int i = 0; i &lt; strs.size(); ++i) {
        if (!used[i]) {
            vector&lt;string&gt; group;
            group.push_back(strs[i]);
            used[i] = true;

            for (int j = i + 1; j &lt; strs.size(); ++j) {
                if (!used[j] &amp;&amp; isAnagram(strs[i], strs[j])) {
                    group.push_back(strs[j]);
                    used[j] = true;
                }
            }
            result.push_back(group);
        }
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2 * k log k), where n is the number of strings, and k is the average length of the strings. isAnagram takes O(k log k) to sort and compare strings. | <b>Space Complexity:</b> O(n * k) in worst case, where n is the number of strings and k is the average length of strings. For storing result.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Hash Map (Character Count)</h5>
  <p>Use a hash map to store character counts as keys and groups of anagrams as values. Iterate through the input array. For each string, compute the character count (e.g., using a 26-element array representing the frequency of each letter). Use this character count (converted to a string) as the key in the hash map. If the key exists, add the current string to the corresponding group. If the key doesn't exist, create a new group with the current string.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

vector&lt;vector&lt;string&gt;&gt; groupAnagrams_optimized(vector&lt;string&gt;&amp; strs) {
    unordered_map&lt;string, vector&lt;string&gt;&gt; anagramGroups;

    for (const string&amp; str : strs) {
        string key = string(26, '0'); // Initialize with 26 zeros
        for (char c : str) {
            key[c - 'a']++; // Increment count for each character
        }
        anagramGroups[key].push_back(str);
    }

    vector&lt;vector&lt;string&gt;&gt; result;
    for (auto&amp; [key, group] : anagramGroups) {
        result.push_back(group);
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n * k), where n is the number of strings, and k is the average length of the strings.  Iterating through the array of strings and computing the character counts take O(n*k) in the worst case, where each string has at most k characters. | <b>Space Complexity:</b> O(n * k), in the worst case, where n is the number of strings and k is the average length of the strings. To store all the strings in the hashmap if they are not anagrams.</p>
  <h5>‚û§ Hash Map (Sorted String)</h5>
  <p>Sort each string in the input array. Use the sorted string as the key in a hash map. Add the original string to the value (a list of strings) associated with the sorted string. Return the values of the hash map as the grouped anagrams.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

vector&lt;vector&lt;string&gt;&gt; groupAnagrams_optimized_sorted(vector&lt;string&gt;&amp; strs) {
    unordered_map&lt;string, vector&lt;string&gt;&gt; anagramGroups;

    for (const string&amp; str : strs) {
        string sortedStr = str;
        sort(sortedStr.begin(), sortedStr.end());
        anagramGroups[sortedStr].push_back(str);
    }

    vector&lt;vector&lt;string&gt;&gt; result;
    for (auto&amp; [key, group] : anagramGroups) {
        result.push_back(group);
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n * k log k), where n is the number of strings, and k is the average length of the strings. Sorting each string takes O(k log k), and we do this for each of the n strings. | <b>Space Complexity:</b> O(n * k), in the worst case, where n is the number of strings and k is the average length of the strings. To store all the strings in the hashmap if they are not anagrams.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["eat", "tea", "tan", "ate", "nat", "bat"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[["bat"], ["nat", "tan"], ["ate", "eat", "tea"]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The anagrams are grouped together.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[""]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[""]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">An empty string is an anagram of itself.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["a"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[["a"]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">A single-character string is an anagram of itself.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The order of the output groups and the order of strings within the groups does not matter. Edge cases include empty strings, single-character strings, and strings with repeated characters. Using a hash map is the most efficient approach. Consider character frequency count instead of sorting because sorting might be less efficient for very long strings.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/word-wrap1646/1>Word Wrap</a> <span style="font-size:14px; color:#888;">Medium </span></h3>
  <p>Given a sequence of words and a line width, the task is to arrange the words in such a way that the lines are not longer than the given line width. The cost of a line is the square of the number of extra spaces in the line. The task is to minimize the total cost, which is the sum of the costs of all lines.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves trying all possible combinations of word arrangements on lines. This is done by recursively considering all possible breakpoints for each line. Calculate the cost for each arrangement and find the minimum cost.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int solve(vector&lt;int&gt;&amp; words, int lineWidth, int index, int remaining, vector&lt;vector&lt;int&gt;&gt;&amp; dp) {
    if (index == words.size()) {
        return 0;
    }

    if (dp[index][remaining] != -1) {
        return dp[index][remaining];
    }

    int cost = INT_MAX;
    if (remaining &gt;= words[index]) {
        int nextRemaining = remaining - words[index] - (index + 1 &lt; words.size() ? 1 : 0);
        int currentCost = solve(words, lineWidth, index + 1, nextRemaining, dp);
        if (currentCost != INT_MAX) {
            cost = min(cost, currentCost);
        }
    }

    if (remaining == lineWidth) {
        cost = min(cost, 1 + solve(words, lineWidth, index + 1, lineWidth - words[index] - (index + 1 &lt; words.size() ? 1 : 0), dp));
    }

    int extraSpaces = remaining - words[index];
    if (extraSpaces &gt;= 0) {
        int currentCost = (extraSpaces * extraSpaces) + solve(words, lineWidth, index + 1, lineWidth - words[index] - (index + 1 &lt; words.size() ? 1 : 0), dp);
         if (currentCost != INT_MAX) {
             cost = min(cost, currentCost);
         }
    }

    return dp[index][remaining] = cost;
}

int wordWrap(vector&lt;int&gt; words, int lineWidth) {
    int n = words.size();
    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(lineWidth + 1, -1));
    return solve(words, lineWidth, 0, lineWidth, dp);
}
</code></pre>
  <p><b>Time Complexity:</b> O(2^n), where n is the number of words.  This is because, in the worst-case scenario, each word can either be on the current line or start a new line. The time complexity is exponential due to exploring all possible combinations. | <b>Space Complexity:</b> O(n), due to the recursion depth. Can be improved using memoization.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming (Bottom-Up)</h5>
  <p>This approach uses dynamic programming to avoid redundant calculations. It builds a table (dp) where dp[i] stores the minimum cost to arrange the first i words. The algorithm iterates through the words and considers all possible breakpoints for the last line, calculating the cost for each arrangement and updating the dp table accordingly.</p>
  <pre><code class="language-python">#include &lt;bits/stdc++.h&gt;
using namespace std;

int wordWrap(vector&lt;int&gt; &amp;words, int lineWidth) {
    int n = words.size();
    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(lineWidth + 1, INT_MAX));
    dp[0][0] = 0;

    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt;= lineWidth; j++) {
            if (dp[i][j] == INT_MAX) continue;

            // Try placing words[i] on the same line
            if (j &gt;= words[i]) {
                int nextRemaining = j - words[i];
                dp[i + 1][nextRemaining] = min(dp[i + 1][nextRemaining], dp[i][j]);
            }

            // Try placing words[i] on a new line
            int nextRemaining = lineWidth - words[i] - (i + 1 &lt; n ? 1 : 0);
            if (nextRemaining &gt;= 0) {
                int extraSpaces = nextRemaining;
                 if (extraSpaces == 0) {
                     if(dp[i + 1][lineWidth] != INT_MAX)
                       dp[i+1][lineWidth] = min(dp[i+1][lineWidth], dp[i][j] + 0);
                     else
                       dp[i + 1][lineWidth] = dp[i][j] + 0;
                }
                else {
                 int cost = extraSpaces * extraSpaces;
                   if(dp[i + 1][lineWidth] != INT_MAX)
                     dp[i + 1][lineWidth] = min(dp[i + 1][lineWidth], dp[i][j] + cost);
                   else
                    dp[i + 1][lineWidth] = dp[i][j] + cost;
                }
            }
        }
    }

    int minCost = INT_MAX;
    for(int j = 0; j &lt;=lineWidth; ++j) {
        minCost = min(minCost, dp[n][j]);
    }

    return minCost;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n * lineWidth^2), where n is the number of words and lineWidth is the maximum line width. We have nested loops that iterate through the words and the possible line lengths. | <b>Space Complexity:</b> O(n * lineWidth), to store the dp table.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">words = {3, 2, 2, 5}, lineWidth = 6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">10</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Line 1: {3, 2} (extra spaces = 1, cost = 1)
Line 2: {2, 5} (extra spaces = 1, cost = 1)
Total cost = 1 + 1 = 2</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">words = {1, 2, 3, 4, 5}, lineWidth = 6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">8</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Line 1: 1 2 3 (extra spaces = 0, cost = 0)
Line 2: 4 5 (extra spaces = 1, cost = 1)
Total cost = 0 + 1 = 1.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">words = {3, 4, 5, 6, 7, 8}, lineWidth = 15</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">All words can fit in one line, extra spaces = 0, cost = 0</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The edge cases to consider include cases where the width of a single word is greater than the line width, or all words can be placed on a single line with no extra spaces. The goal is to minimize the cost (sum of squared extra spaces), which means minimizing extra spaces as much as possible.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/basic-calculator-ii/>Basic Calculator II</a> <span style="font-size:14px; color:#888;">Medium </span></h3>
  <p>Given a string `s` which represents an expression, evaluate this expression and return its value. The integer division should truncate toward zero.

You may assume that the given expression is always valid. All intermediate results will be in the range of [-2^31, 2^31 - 1].

Note: You are not allowed to use the `eval()` built-in function.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves iterating through the string, parsing numbers and operators, and performing calculations based on operator precedence (multiplication and division before addition and subtraction). We maintain two stacks: one for numbers and one for operators.  When encountering a multiplication or division, we immediately perform the operation. After processing the entire string, we process addition and subtraction from left to right.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int calculate_brute_force(string s) {
    vector&lt;int&gt; nums;
    char sign = '+';
    int num = 0;
    for (int i = 0; i &lt; s.length(); i++) {
        if (isdigit(s[i])) {
            num = num * 10 + (s[i] - '0');
        }
        if ((!isdigit(s[i]) &amp;&amp; s[i] != ' ') || i == s.length() - 1) {
            if (sign == '+') {
                nums.push_back(num);
            } else if (sign == '-') {
                nums.push_back(-num);
            } else if (sign == '*') {
                nums.back() *= num;
            } else if (sign == '/') {
                nums.back() /= num;
            }
            sign = s[i];
            num = 0;
        }
    }
    int result = 0;
    for (int n : nums) {
        result += n;
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the length of the input string. We iterate through the string once. | <b>Space Complexity:</b> O(n), in the worst case, where all the characters are digits, resulting in storing all calculated intermediate values in the nums vector</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized with Stack Simulation</h5>
  <p>This optimized approach also processes the string from left to right, but instead of using two stacks (numbers and operators), it uses a single stack to keep track of the operands and perform the operations. It maintains the `sign` of the previous operand. During iteration, it handles digits to build numbers and, based on `sign`, performs the operation of the current number and the top of the stack. Multiplication and division are done immediately, and addition/subtraction are deferred until the end by adding or subtracting the operand to the stack (or equivalent variable).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int calculate_optimized(string s) {
    if (s.empty()) return 0;
    int n = s.length();
    int currentNumber = 0;
    char operation = '+';
    stack&lt;int&gt; nums;
    for (int i = 0; i &lt; n; i++) {
        char c = s[i];
        if (isdigit(c)) {
            currentNumber = (currentNumber * 10) + (c - '0');
        }
        if (!isdigit(c) &amp;&amp; c != ' ' || i == n - 1) {
            if (operation == '+') {
                nums.push(currentNumber);
            } else if (operation == '-') {
                nums.push(-currentNumber);
            } else if (operation == '*') {
                int top = nums.top();
                nums.pop();
                nums.push(top * currentNumber);
            } else if (operation == '/') {
                int top = nums.top();
                nums.pop();
                nums.push(top / currentNumber);
            }
            operation = c;
            currentNumber = 0;
        }
    }
    int result = 0;
    while (!nums.empty()) {
        result += nums.top();
        nums.pop();
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the length of the input string. We iterate through the string once. | <b>Space Complexity:</b> O(n), in the worst case. For example, for the input "1+2-3+4-5", all operations will be pushed on to stack, so the space complexity is O(n)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">"3+2*2"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">7</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3 + (2 * 2) = 7</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">" 3/2 "</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3 / 2 = 1 (integer division)</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">" 3+5 / 2 "</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3 + (5 / 2) = 5</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">"1-1+1"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 - 1 + 1 = 1</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">"1*2-3/4+5*6-7*8+9"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-24</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 * 2 - 3 / 4 + 5 * 6 - 7 * 8 + 9 = 2 - 0 + 30 - 56 + 9 = -24</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  Whitespace in the input string should be handled correctly (ignored).
2.  The integer division should truncate towards zero, not rounding.
3.  The input string is guaranteed to be a valid expression.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/smallest-window-in-a-string-containing-all-the-characters-of-another-string-1587115621/1>Smallest window in a string containing all the characters of another string</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given two strings s and p, find the smallest substring of s that contains all the characters of p. If no such substring exists, return "-1".</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible substrings of s. For each substring, check if it contains all characters of p. Keep track of the smallest such substring found. This involves checking substrings starting at every index and expanding to every possible end index.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

string smallestWindowBruteForce(string s, string p) {
    int n = s.length();
    int m = p.length();
    string ans = "-1";
    int minLength = INT_MAX;

    for (int i = 0; i &lt n; i++) {
        for (int j = i; j &lt n; j++) {
            string sub = s.substr(i, j - i + 1);
            bool found = true;
            for (char c : p) {
                if (sub.find(c) == string::npos) {
                    found = false;
                    break;
                }
            }
            if (found) {
                if (sub.length() &lt minLength) {
                    minLength = sub.length();
                    ans = sub;
                }
            }
        }
    }

    return ans;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^3 * m), where n is the length of s and m is the length of p.  O(n^2) to generate all substrings, O(m) to check if the substring contains all characters of p, and O(n) for string operations within the loops. | <b>Space Complexity:</b> O(1) - constant extra space</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Sliding Window with Hash Maps</h5>
  <p>Use a sliding window approach. Maintain two hash maps: one for the character frequencies in p and another for the character frequencies in the current window. Expand the window until all characters of p are present in the window. Contract the window from the left, removing characters until the window is no longer valid (i.e., it doesn't contain all characters of p). Keep track of the smallest valid window found.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

string smallestWindowOptimized(string s, string p) {
    int n = s.length();
    int m = p.length();
    if (m &gt n) return "-1";

    unordered_map&ltchar, int&gt pMap, sMap;
    for (char c : p) pMap[c]++;

    int left = 0, right = 0, required = pMap.size(), formed = 0;
    int start = -1, minLength = INT_MAX;

    while (right &lt n) {
        char c = s[right];
        sMap[c]++;
        if (pMap.count(c) &amp;&amp; sMap[c] == pMap[c]) {
            formed++;
        }
        while (formed == required &amp;&amp; left &lt= right) {
            if (right - left + 1 &lt minLength) {
                minLength = right - left + 1;
                start = left;
            }
            char leftChar = s[left];
            sMap[leftChar]--;
            if (pMap.count(leftChar) &amp;&amp; sMap[leftChar] &lt pMap[leftChar]) {
                formed--;
            }
            left++;
        }
        right++;
    }
    return (start == -1) ? "-1" : s.substr(start, minLength);
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the length of s.  We iterate through s at most twice. | <b>Space Complexity:</b> O(m), where m is the length of p.  The hash maps store the characters of p.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "timetopractice", p = "toc"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">top</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The smallest window in s containing all characters of p is "top".</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "zoomlazapzo", p = "oza"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">apzo</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The smallest window is "apzo"</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "abc", p = "abc"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">abc</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The smallest window is the entire string.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "abc", p = "abcb"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No window containing all characters of p exists.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases include:

1.  The length of p is greater than the length of s (return "-1").
2.  p contains characters not in s (return "-1").
3.  Empty strings for either s or p.
4. Duplicates in p. The solution needs to account for the frequency of the characters in p.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/valid-number/>Valid Number</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Determine if a given string represents a valid number. A valid number can include integers, decimals, and exponents. Specifically, a valid number must follow these rules:

1.  **Integer:** Can be a positive or negative integer (e.g., "123", "-42", "+10").
2.  **Decimal:** Can include a decimal point.  It can be in the form of integer.fraction (e.g., "12.34", ".1", "1.").
3.  **Exponent:** Can include an exponent denoted by 'e' or 'E'.  The exponent should be followed by an integer (e.g., "1e10", "-2e-5").

Whitespace is not allowed except at the start and end of the string. The string should conform to a basic numerical format (integer, decimal or exponent) as per the problem statement requirements.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the string and check for different components (sign, digits, decimal point, exponent). Keep track of states to validate the order and validity of components. A state machine approach can be utilized to track states such as 'start', 'integer', 'decimal', 'exponent', etc.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool isNumber(string s) {
    int n = s.length();
    int i = 0;

    // Trim leading whitespace
    while (i &lt n &amp;&amp; s[i] == ' ') {
        i++;
    }
    if (i == n) return false; // All whitespace

    bool hasDigit = false;
    bool hasDot = false;
    bool hasExp = false;

    // Handle sign
    if (s[i] == '+' || s[i] == '-') {
        i++;
    }

    while (i &lt n) {
        if (isdigit(s[i])) {
            hasDigit = true;
            i++;
        } else if (s[i] == '.') {
            if (hasDot || hasExp) return false; // Multiple dots or dot after exponent
            hasDot = true;
            i++;
        } else if (s[i] == 'e' || s[i] == 'E') {
            if (!hasDigit || hasExp) return false; // No digits before exponent or multiple exponents
            hasExp = true;
            hasDigit = false; // Reset for exponent part
            i++;
            // Handle sign after exponent
            if (i &lt n &amp;&amp; (s[i] == '+' || s[i] == '-')) {
                i++;
            }
        } else if (s[i] == ' ') {
            break; // Break at whitespace to handle trailing spaces
        } 
        else {
            return false; // Invalid character
        }
    }

    // Trim trailing whitespace
    while (i &lt n &amp;&amp; s[i] == ' ') {
        i++;
    }

    return hasDigit &amp;&amp; i == n;  // Check if all input is validated.
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the length of the input string. We iterate through the string at most a constant number of times. | <b>Space Complexity:</b> O(1), as we use a constant amount of extra space to store boolean flags and the loop counter.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ State Machine Approach</h5>
  <p>Implement a state machine with well-defined states (e.g., `start`, `integer`, `decimal`, `exponent`, `end`) and transitions based on the characters encountered.  This approach provides a structured and efficient way to validate the number format.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool isNumber(string s) {
    enum State { START, INTEGER, DECIMAL, FRACTION, EXPONENT_START, EXPONENT_NUMBER, END, SIGN_BEFORE_NUMBER, SIGN_BEFORE_EXPONENT };

    int n = s.length();
    int i = 0;
    int state = START;

    while (i &lt n) {
        char c = s[i];

        switch (state) {
            case START:
                if (c == ' ') {
                    i++;
                } else if (c == '+' || c == '-') {
                    state = SIGN_BEFORE_NUMBER;
                    i++;
                } else if (isdigit(c)) {
                    state = INTEGER;
                    i++;
                } else if (c == '.') {
                    state = FRACTION;
                    i++;
                } else {
                    return false;
                }
                break;
            case SIGN_BEFORE_NUMBER:
                if (isdigit(c)) {
                    state = INTEGER;
                    i++;
                } else if (c == '.') {
                   state = FRACTION;
                   i++;
                }else {
                    return false;
                }
                break;
            case INTEGER:
                if (isdigit(c)) {
                    i++;
                } else if (c == '.') {
                    state = FRACTION;
                    i++;
                } else if (c == 'e' || c == 'E') {
                    state = EXPONENT_START;
                    i++;
                } else if (c == ' ') {
                    state = END;
                    i++;
                } else {
                    return false;
                }
                break;
            case FRACTION:
                if (isdigit(c)) {
                    state = FRACTION;
                    i++;
                } else if (c == 'e' || c == 'E') {
                    state = EXPONENT_START;
                    i++;
                } else if (c == ' ') {
                  state = END;
                  i++;
                } else {
                   return false;
                }
                break;
            case EXPONENT_START:
                if (c == '+' || c == '-') {
                    state = SIGN_BEFORE_EXPONENT;
                    i++;
                } else if (isdigit(c)) {
                    state = EXPONENT_NUMBER;
                    i++;
                } else {
                    return false;
                }
                break;
            case SIGN_BEFORE_EXPONENT:
                if(isdigit(c)){
                  state = EXPONENT_NUMBER;
                  i++;
                } else {
                  return false;
                }
                break;
            case EXPONENT_NUMBER:
                if (isdigit(c)) {
                    i++;
                } else if (c == ' ') {
                  state = END;
                  i++;
                } else {
                    return false;
                }
                break;
            case END:
              if(c == ' ') {
                i++;
              }else {
                return false;
              }
              break;
        }
    }

    return state == INTEGER || state == FRACTION || state == EXPONENT_NUMBER || state == END && (state != START && state != SIGN_BEFORE_NUMBER); // Check for valid end states
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the length of the input string. The state machine processes each character once. | <b>Space Complexity:</b> O(1), as the state machine uses constant space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">"0"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Valid integer.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">" 0.1 "</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Valid decimal with leading and trailing whitespace.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">"abc"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Invalid characters.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">"1 a"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Invalid characters.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">"2e10"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Valid exponent.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">" -90e3   "</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Valid exponent with leading and trailing whitespace.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">" 1e "</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Invalid. Exponent without a digit.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">"e3"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Invalid. No digit before exponent.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">" 6e-1"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Valid exponent with a sign.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">" 99e2.5 "</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Invalid. Decimal after exponent.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">"1e.1"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Invalid.  decimal after exponent.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">"46.e3"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Valid decimal and exponent.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">".1"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Valid decimal format</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">"."</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Invalid. Only a decimal point.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">"3.  "</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Invalid. Trailing spaces after decimal</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">"-+3"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Invalid. Multiple signs.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">"   .  "</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Invalid. Whitespace and dot only.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Key edge cases to consider:

1.  **Leading and trailing whitespace:** The input string can have leading or trailing whitespace.
2.  **Signs:**  '+' and '-' can appear at the beginning of an integer or before the exponent.
3.  **Decimal points:** Only one decimal point is allowed, and it can appear before or after digits, or between digits.
4.  **Exponents:** The exponent ('e' or 'E') must be followed by a valid integer.
5.  **Invalid characters:**  Any character other than digits, '.', 'e', 'E', '+', '-', and whitespace are invalid.
6.  **Multiple signs:** More than one sign before a number or exponent is invalid.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/integer-to-english-words/>Integer to English Words</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Convert a non-negative integer to its English words representation. Given an integer num, return the English words representation of the integer. Constraints: 0 &lt;= num &lt;= 2^31 - 1.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>This approach involves breaking down the integer into its constituent parts (billions, millions, thousands, hundreds, etc.) and then mapping each part to its English word equivalent. This is done by creating lookup tables for numbers 0-19, 20-90, and powers of 1000. The conversion is performed recursively by processing the larger parts of the number first, and then the smaller parts.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

class Solution {
public:
    string numberToWords(int num) {
        if (num == 0) return "Zero";
        return helper(num);
    }

    string helper(int num) {
        vector&lt;string&gt; lessThan20 = {
            "", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten",
            "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"
        };
        vector&lt;string&gt; tens = {
            "", "", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"
        };
        vector&lt;string&gt; thousands = {
            "", "Thousand", "Million", "Billion"
        };

        if (num &lt; 20) {
            return lessThan20[num];
        } else if (num &lt; 100) {
            return tens[num / 10] + (num % 10 != 0 ? " " + lessThan20[num % 10] : "");
        } else if (num &lt; 1000) {
            return lessThan20[num / 100] + " Hundred" + (num % 100 != 0 ? " " + helper(num % 100) : "");
        } else {
            for (int i = 3, k = 1000000000; i &gt;= 1; i--, k /= 1000) {
                if (num / k &gt; 0) {
                    return helper(num / k) + " " + thousands[i] + (num % k != 0 ? " " + helper(num % k) : "");
                }
            }
            return helper(num % 1000);
        }
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of digits in the input number. The algorithm effectively processes each digit or group of digits once. | <b>Space Complexity:</b> O(1), as the space used by lookup tables is constant, and the recursion depth is limited by the number of digits (at most 10 for a 32-bit integer).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized approach</h5>
  <p>This approach is similar to the brute-force but is optimized by pre-calculating the string representations and reducing redundant operations. It recursively breaks down the input number into manageable chunks (billion, million, thousand, hundred) and utilizes lookup tables for the numbers, tens, and scales (thousand, million, billion).</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

class Solution {
public:
    string numberToWords(int num) {
        if (num == 0) return "Zero";
        return toWords(num);
    }

    string toWords(int num) {
        vector&lt;string&gt; lessThan20 = {
            "", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten",
            "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"
        };
        vector&lt;string&gt; tens = {
            "", "", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"
        };
        vector&lt;string&gt; thousands = {
            "", "Thousand", "Million", "Billion"
        };

        if (num &lt; 20) {
            return lessThan20[num];
        } else if (num &lt; 100) {
            return tens[num / 10] + (num % 10 != 0 ? " " + lessThan20[num % 10] : "");
        } else if (num &lt; 1000) {
            return lessThan20[num / 100] + " Hundred" + (num % 100 != 0 ? " " + toWords(num % 100) : "");
        } else {
            for (int i = 3, k = 1000000000; i &gt;= 1; i--, k /= 1000) {
                if (num / k &gt; 0) {
                    return toWords(num / k) + " " + thousands[i] + " " + toWords(num % k);
                }
            }
            return toWords(num % 1000);
        }
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of digits in the input number. | <b>Space Complexity:</b> O(1), because the extra space used by the vectors is constant and the depth of recursion is bound by the number of digits (at most 10).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">123</td>
        <td style="border: 1px solid #ccc; padding: 6px;">One Hundred Twenty Three</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The number 123 is divided into hundred, tens, and ones place. The result is "One Hundred Twenty Three".</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">12345</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Twelve Thousand Three Hundred Forty Five</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The number 12345 is divided into thousand, hundred, tens and ones place. The result is "Twelve Thousand Three Hundred Forty Five".</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1234567</td>
        <td style="border: 1px solid #ccc; padding: 6px;">One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The number 1234567 is divided into million, thousand, hundred, tens, and ones place. The result is "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven".</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Zero</td>
        <td style="border: 1px solid #ccc; padding: 6px;">When the input is 0, return "Zero".</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1000000000</td>
        <td style="border: 1px solid #ccc; padding: 6px;">One Billion</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Example for billion.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. Handle the edge case of input 0 correctly. 2. Ensure correct spacing between words. 3. Handle numbers up to billions. 4. Use helper functions to improve code readability. 5. The use of a vector for smaller numbers and tens makes lookups easy. 6. The algorithm's core logic consists of dividing the input by the appropriate scale (billion, million, thousand, hundred) and handling the remainder recursively.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/minimum-window-substring/>Minimum Window Substring</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given two strings s and t, return the minimum window in s which will contain all the characters in t. If there is no such window in s that covers all characters in t, return the empty string "". If there are multiple such windows, return the one with the minimum length.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach iterates through all possible substrings of s. For each substring, it checks if it contains all characters of t. If it does, and if it's shorter than the current minimum window, update the minimum window. This involves nested loops for substring generation and checking character counts.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string minWindowBruteForce(string s, string t) {
    if (t.length() &gt s.length()) {
        return "";
    }

    string minWindow = "";
    int minLength = INT_MAX;

    for (int i = 0; i &lt s.length(); ++i) {
        for (int j = i; j &lt s.length(); ++j) {
            string sub = s.substr(i, j - i + 1);
            if (containsAllChars(sub, t)) {
                if (sub.length() &lt minLength) {
                    minLength = sub.length();
                    minWindow = sub;
                }
            }
        }
    }

    return minWindow;
}

bool containsAllChars(string sub, string t) {
    unordered_map&ltchar, int&gt t_counts;
    for (char c : t) {
        t_counts[c]++;
    }

    unordered_map&ltchar, int&gt sub_counts;
    for (char c : sub) {
        sub_counts[c]++;
    }

    for (auto const& [key, val] : t_counts) {
        if (sub_counts[key] &lt val) {
            return false;
        }
    }
    return true;
}
</code></pre>
  <p><b>Time Complexity:</b> O(s^3 * t) -  O(s^2) for generating substrings * O(t)  for containsAllChars check in worst case. | <b>Space Complexity:</b> O(t) - for storing character counts of t and substrings.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Sliding Window</h5>
  <p>The sliding window approach uses two pointers, left and right, to define a window in s. We expand the window by moving the right pointer and contract the window by moving the left pointer. We maintain a count of characters in t that are present in the current window. When the count equals the length of t, we have a valid window. We try to minimize the window by moving the left pointer while maintaining validity. We track the start and end indices of the minimum window found so far.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string minWindowOptimized(string s, string t) {
    if (t.length() &gt s.length()) {
        return "";
    }

    unordered_map&ltchar, int&gt t_counts;
    for (char c : t) {
        t_counts[c]++;
    }

    int required = t_counts.size(); // Number of unique chars in t
    int formed = 0;  // How many unique chars in t are found in current window with required frequency

    int left = 0, right = 0;
    int start = 0, minLength = INT_MAX;

    unordered_map&ltchar, int&gt window_counts;

    while (right &lt s.length()) {
        char c = s[right];
        window_counts[c]++;

        if (t_counts.count(c) &amp;&amp; window_counts[c] == t_counts[c]) {
            formed++;
        }

        while (left &lt= right &amp;&amp; formed == required) {
            if (right - left + 1 &lt minLength) {
                minLength = right - left + 1;
                start = left;
            }

            char leftChar = s[left];
            window_counts[leftChar]--;
            if (t_counts.count(leftChar) &amp;&amp; window_counts[leftChar] &lt t_counts[leftChar]) {
                formed--;
            }
            left++;
        }
        right++;
    }

    return minLength == INT_MAX ? "" : s.substr(start, minLength);
}
</code></pre>
  <p><b>Time Complexity:</b> O(s + t) - The algorithm iterates at most twice through the string s (left and right pointers).  Creating the t_counts takes O(t). | <b>Space Complexity:</b> O(t) - Storing character counts for t and the sliding window.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "ADOBECODEBANC", t = "ABC"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">BANC</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The minimum window substring is "BANC".</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "a", t = "a"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">a</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The minimum window substring is "a".</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "a", t = "aa"</td>
        <td style="border: 1px solid #ccc; padding: 6px;"></td>
        <td style="border: 1px solid #ccc; padding: 6px;">Both the character 'a' in t must exist in s.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases include empty strings for s or t, or when t contains characters not present in s. Also, consider the case where t has duplicate characters. Make sure to handle these cases correctly. The key to the sliding window approach is efficiently expanding and contracting the window to find the minimum substring. Keep track of the required characters and the characters present in the window to optimize. Handle duplicate characters in t correctly, maintaining the count of each character in both the window and t.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/text-justification/>Text Justification</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given an array of strings `words` and a width `maxWidth`, format the text such that each line has exactly `maxWidth` characters and is fully (left and right) justified.

You should pack your words in a greedy approach; that is, pack as many words as possible in each line. Pad extra spaces ' ' when necessary so that each line has exactly `maxWidth` characters.

Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.

For the last line of text, it should be left-justified, and no extra space is inserted between words.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves trying all possible combinations of words for each line. For each combination, calculate the number of spaces needed and distribute them. This approach is not efficient due to its exponential time complexity.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// This approach is highly inefficient and not practical.
// It is provided for conceptual understanding only.
vector&lt;string&gt; fullJustifyBruteForce(vector&lt;string&gt;&amp; words, int maxWidth) {
    vector&lt;string&gt; result;
    int n = words.size();

    for (int i = 0; i &lt; n;) {
        int current_line_length = 0;
        int words_in_line = 0;
        int start = i;

        // Find words for the current line
        while (i &lt; n &amp;&amp; current_line_length + words[i].length() + words_in_line &lt;= maxWidth) {
            current_line_length += words[i].length();
            words_in_line++;
            i++;
        }

        // Handle the last line
        if (i == n) {
            string line = words[start];
            for (int j = start + 1; j &lt; i; j++) {
                line += " " + words[j];
            }
            while (line.length() &lt; maxWidth) {
                line += " ";
            }
            result.push_back(line);
            break;
        }

        // Calculate spaces
        int spaces_needed = maxWidth - current_line_length;
        if (words_in_line == 1) {
            string line = words[start];
            while (line.length() &lt; maxWidth) {
                line += " ";
            }
            result.push_back(line);
            continue;
        }

        int spaces_between_words = spaces_needed / (words_in_line - 1);
        int extra_spaces = spaces_needed % (words_in_line - 1);

        string line = "";
        for (int j = start; j &lt; i; j++) {
            line += words[j];
            if (j &lt; i - 1) {
                int spaces_to_add = spaces_between_words + (extra_spaces &gt; 0 ? 1 : 0);
                line += string(spaces_to_add, ' ');
                extra_spaces = max(0, extra_spaces - 1);
            }
        }
        result.push_back(line);
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N * 2^N) - where N is the number of words.  Due to the exponential nature of exploring combinations. | <b>Space Complexity:</b> O(N) - Space for storing the result.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Greedy Approach with Line-by-Line Justification</h5>
  <p>This approach iterates through the words, greedily forming lines. It first determines how many words can fit in a line. Then, it distributes spaces evenly between the words, handling the special cases of a single word and the last line. The last line is left-justified.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int maxWidth) {
    vector&lt;string&gt; result;
    int n = words.size();
    int i = 0;

    while (i &lt; n) {
        int current_line_length = 0; // length of words in current line
        int start = i; // starting index of words in current line
        int words_in_line = 0;

        // Determine how many words fit in the current line
        while (i &lt; n &amp;&amp; current_line_length + words[i].length() + words_in_line &lt;= maxWidth) {
            current_line_length += words[i].length();
            words_in_line++;
            i++;
        }

        // Handle the last line
        if (i == n) {
            string line = words[start];
            for (int j = start + 1; j &lt; i; j++) {
                line += " " + words[j];
            }
            while (line.length() &lt; maxWidth) {
                line += " ";
            }
            result.push_back(line);
            break;
        }

        // Calculate spaces needed
        int spaces_needed = maxWidth - current_line_length;
        // Handle single-word lines
        if (words_in_line == 1) {
            string line = words[start];
            while (line.length() &lt; maxWidth) {
                line += " ";
            }
            result.push_back(line);
            continue;
        }

        // Distribute spaces between words
        int spaces_between_words = spaces_needed / (words_in_line - 1);
        int extra_spaces = spaces_needed % (words_in_line - 1);

        string line = "";
        for (int j = start; j &lt; i; j++) {
            line += words[j];
            if (j &lt; i - 1) {
                int spaces_to_add = spaces_between_words + (extra_spaces &gt; 0 ? 1 : 0);
                line += string(spaces_to_add, ' ');
                extra_spaces = max(0, extra_spaces - 1);
            }
        }
        result.push_back(line);
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N * M) - where N is the number of words and M is the average length of the words. We iterate through the words at most once. | <b>Space Complexity:</b> O(N) - to store the result (justified lines).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">words = ["This", "is", "an", "example", "of", "text", "justification"], maxWidth = 16</td>
        <td style="border: 1px solid #ccc; padding: 6px;">["This    is    an", "example  of text", "justification   "]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The first line is justified to fill the 16-character width. 'This', 'is', and 'an' are spaced. The second line also has spaces. The last line is left-justified.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">words = ["What","must","be","acknowledgment","shall","be"], maxWidth = 16</td>
        <td style="border: 1px solid #ccc; padding: 6px;">["What   must   be","acknowledgment  ","shall be        "]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The first line has extra spaces. The second line is left justified, and the last has left padding.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">words = ["Science","is","what","we","understand","well","enough","to","explain","to","a","computer","The","first","time","we","write","the","code","we","don't","understand","what","we","are","doing"], maxWidth = 20</td>
        <td style="border: 1px solid #ccc; padding: 6px;">["Science is what we","understand well","enough to explain","to a computer The","first time we write","the code we don't","understand what we","are doing          "]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Complex case demonstrating even distribution of spaces and last line handling.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Key considerations:

1.  **Greedy Approach:** Pack as many words as possible on each line.
2.  **Space Distribution:** Distribute spaces evenly between words.
3.  **Last Line:** Left-justify the last line.
4.  **Single Word Line:** Handle cases where a line contains only one word.
5.  **Efficiency:** Optimize the algorithm to avoid nested loops where possible for better performance.  The described optimal approach addresses these points.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/boyer-moore-algorithm-for-pattern-searching/>Boyer-Moore Algorithm for Pattern Searching</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>The Boyer-Moore algorithm is a particularly efficient string-searching algorithm, and it is the standard benchmark for practical string search literature. The algorithm preprocesses the pattern to create two tables: the bad character heuristic table and the good suffix heuristic table. Given a text and a pattern, the algorithm finds the first occurrence of the pattern within the text. If the pattern is not found, the algorithm returns an indication of that.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach iterates through the text, comparing the pattern at each position.  If a mismatch occurs, the pattern shifts one position to the right, and the comparison starts again from the beginning of the pattern. This process continues until the pattern is found or the end of the text is reached.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int bruteForceSearch(string text, string pattern) {
    int n = text.length();
    int m = pattern.length();

    for (int i = 0; i &lt= n - m; ++i) {
        int j;
        for (j = 0; j &lt m; ++j) {
            if (text[i + j] != pattern[j]) {
                break;
            }
        }
        if (j == m) {
            return i; // Pattern found at index i
        }
    }
    return -1; // Pattern not found
}

// int main() {
//     string text = "ABABDABACDABABCABAB";
//     string pattern = "ABABCABAB";
//     int index = bruteForceSearch(text, pattern);
//     if (index != -1) {
//         cout &lt&lt "Pattern found at index " &lt&lt index &lt&lt endl;
//     } else {
//         cout &lt&lt "Pattern not found" &lt&lt endl;
//     }
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(m * n), where n is the length of the text and m is the length of the pattern.  In the worst-case scenario (e.g., when the pattern is nearly the same as a portion of the text, but doesn't match), every character comparison in each position is necessary. | <b>Space Complexity:</b> O(1) - Constant extra space is used.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Boyer-Moore Algorithm</h5>
  <p>The Boyer-Moore algorithm uses two main heuristics to improve efficiency: the bad character rule and the good suffix rule. The bad character rule shifts the pattern based on the last occurrence of the mismatched character in the pattern. The good suffix rule shifts based on the matching suffix of the pattern. The algorithm calculates these shifts and uses the larger of the two to maximize the shift, thus skipping irrelevant parts of the text and reducing unnecessary comparisons.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Utility function to calculate bad character heuristic
void badCharHeuristic(string pattern, int badChar[]) {
    int m = pattern.length();
    for (int i = 0; i &lt 256; i++) {
        badChar[i] = -1;
    }
    for (int i = 0; i &lt m; i++) {
        badChar[(int)pattern[i]] = i;
    }
}

int boyerMooreSearch(string text, string pattern) {
    int n = text.length();
    int m = pattern.length();

    int badChar[256];

    badCharHeuristic(pattern, badChar);

    int s = 0; // s is shift of the pattern with respect to text
    while (s &lt= (n - m)) {
        int j = m - 1;

        // Keep reducing index j of pattern while characters of pattern and text
        // are matching at this shift s
        while (j &gt= 0 &amp;&amp; pattern[j] == text[s + j]) {
            j--;
        }

        // If the pattern is present at current shift, then index j will be -1
        if (j &lt 0) {
            return s;
            // Shift the pattern so that the next character of text aligns with the last
            // occurrence of it in pattern.  If there is no such occurrence,
            // the next character of text is skipped.
            // s += (s+m &lt n)? m-badChar[text[s+m]] : 1;
        } else {
            // Shift pattern so that the bad character in text aligns with the last occurrence of
            // it in pattern.  The max function is used to make sure that the shift is at least 1.
            s += max(1, j - badChar[(int)text[s + j]]);
        }
    }
    return -1;
}

// int main() {
//     string text = "ABABDABACDABABCABAB";
//     string pattern = "ABABCABAB";
//     int index = boyerMooreSearch(text, pattern);
//     if (index != -1) {
//         cout &lt&lt "Pattern found at index " &lt&lt index &lt&lt endl;
//     } else {
//         cout &lt&lt "Pattern not found" &lt&lt endl;
//     }
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(m*n) in the worst case, but can be sublinear in practice (often close to O(n/m)).  The worst case occurs when the pattern and text have many shared characters, leading to many comparisons.  The best and average case time complexity is much better. | <b>Space Complexity:</b> O(1) - Constant extra space (excluding the badChar array, which is fixed size dependent only on alphabet size).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">text = "ABABDABACDABABCABAB", pattern = "ABABCABAB"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Pattern found at index 10</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The pattern "ABABCABAB" is found starting at index 10 in the text.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">text = "GEEKS FOR GEEKS", pattern = "FOR"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Pattern found at index 6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The pattern "FOR" is found starting at index 6.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">text = "ABABDABACDABABCABAB", pattern = "ABCDE"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Pattern not found</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The pattern "ABCDE" is not found in the text.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The Boyer-Moore algorithm is highly efficient for many practical scenarios. The performance depends heavily on the characteristics of the pattern and the text. For small alphabets, the bad character heuristic is effective. For larger alphabets the algorithm can be even more efficient because more characters can potentially cause larger shifts.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/distinct-subsequences/>Distinct Subsequences</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given two strings s and t, return the number of distinct subsequences of s which equals t. A subsequence of a string is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., "ACE" is a subsequence of "ABCDE" while "AEC" is not).</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves generating all possible subsequences of string `s` and checking if each subsequence is equal to string `t`. Since we have to compare all generated subsequences of `s` with `t`, the time complexity will be exponential in the length of `s`.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int numDistinct(string s, string t) {
    int count = 0;
    int n = s.length();
    int m = t.length();

    function&lt;void(int, int, string)&gt; generateSubsequences = 
        [&](int s_idx, int t_idx, string current) {
        if (t_idx == m) {
            count++;
            return;
        }

        if (s_idx == n) {
            return;
        }

        // Option 1: Include the current character from s if it matches t
        if (s[s_idx] == t[t_idx]) {
            generateSubsequences(s_idx + 1, t_idx + 1, current + s[s_idx]);
        }

        // Option 2: Exclude the current character from s
        generateSubsequences(s_idx + 1, t_idx, current);
    };

    generateSubsequences(0, 0, "");
    return count;
}
</code></pre>
  <p><b>Time Complexity:</b> O(2^N), where N is the length of s.  In the worst case, we explore all possible subsequences of s. | <b>Space Complexity:</b> O(N) due to recursion depth in the worst-case scenario, representing the length of s.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming - Tabulation</h5>
  <p>This approach uses dynamic programming to efficiently compute the number of distinct subsequences. We create a 2D DP table where dp[i][j] represents the number of distinct subsequences of s[0...i-1] that equals t[0...j-1].  The base cases are when j=0, dp[i][0] = 1 for all i (empty subsequence is always a subsequence of s) and when i=0 and j&gt;0, dp[0][j] = 0, because an empty s can not give t.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int numDistinct(string s, string t) {
    int n = s.length();
    int m = t.length();

    // dp[i][j] stores the number of distinct subsequences of s[0...i-1] equal to t[0...j-1]
    vector&lt;vector&lt;unsigned long long&gt;&gt; dp(n + 1, vector&lt;unsigned long long&gt;(m + 1, 0));

    // Base case: Empty t is always a subsequence
    for (int i = 0; i &lt;= n; i++) {
        dp[i][0] = 1;
    }

    // Iterate to fill the dp table
    for (int i = 1; i &lt;= n; i++) {
        for (int j = 1; j &lt;= m; j++) {
            if (s[i - 1] == t[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; // Match, add the current character
            } else {
                dp[i][j] = dp[i - 1][j]; // No match, ignore current character in s
            }
        }
    }

    return dp[n][m];
}
</code></pre>
  <p><b>Time Complexity:</b> O(M * N), where M is the length of t and N is the length of s. | <b>Space Complexity:</b> O(M * N), due to the 2D DP table.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "rabbbit", t = "rabbit"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The distinct subsequences are:
- "rabbit" (using the first 'r')
- "rabbit" (using the second 'r')
- "rabbit" (using the third 'b')</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "babgbag", t = "bag"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The distinct subsequences are:
- "bag" (using the first 'b')
- "bag" (using the first 'b', second 'g')
- "bag" (using the second 'b')
- "bag" (using the first 'b', third 'g')
- "bag" (using the second 'b', third 'g')</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "", t = ""</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Empty string t is a subsequence of the empty string s.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "", t = "abc"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">t can't be a subsequence of s</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  **Empty Strings:** Handle cases where either `s` or `t` are empty strings correctly.
2.  **Character Matching:** The core logic involves checking if characters in `s` and `t` match and deciding whether to include or exclude them.  If they match, we have two options, one includes this character and one ignores.
3.  **Optimization:** Dynamic programming is crucial for an efficient solution to avoid redundant computations. The tabulation method avoids recursion overhead of memoization.
4.  **Large Outputs:** The number of distinct subsequences can be large; using `unsigned long long` helps prevent integer overflow.</p>
</div>
<hr style="margin: 40px 0;">
<h2>Matrix Problems </h2>
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/maximum-size-rectangle-binary-sub-matrix-1s/>Maximum size rectangle in a binary sub-matrix with 1s</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a binary matrix, find the maximum size rectangle (area) containing only 1s.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible rectangles by considering every cell as a potential top-left corner and every other cell as a potential bottom-right corner. For each potential rectangle, check if all the cells within it are 1s. Keep track of the maximum area found so far.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int maxRectangle(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
    if (matrix.empty() || matrix[0].empty()) {
        return 0;
    }

    int rows = matrix.size();
    int cols = matrix[0].size();
    int maxArea = 0;

    for (int r1 = 0; r1 &lt rows; ++r1) {
        for (int c1 = 0; c1 &lt cols; ++c1) {
            for (int r2 = r1; r2 &lt rows; ++r2) {
                for (int c2 = c1; c2 &lt cols; ++c2) {
                    bool isValid = true;
                    for (int r = r1; r &lt= r2; ++r) {
                        for (int c = c1; c &lt= c2; ++c) {
                            if (matrix[r][c] == 0) {
                                isValid = false;
                                break;
                            }
                        }
                        if (!isValid) {
                            break;
                        }
                    }
                    if (isValid) {
                        int area = (r2 - r1 + 1) * (c2 - c1 + 1);
                        maxArea = max(maxArea, area);
                    }
                }
            }
        }
    }
    return maxArea;
}

</code></pre>
  <p><b>Time Complexity:</b> O(rows^3 * cols^3) - The nested loops for checking rectangles take O(rows * cols) and the loop for validating each rectangle takes O(rows * cols) in the worst case. Effectively this makes it O(rows^3 * cols^3) | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Using Dynamic Programming (DP) and Largest Rectangle in Histogram</h5>
  <p>1. **Preprocessing:** For each cell in the matrix, calculate the number of consecutive 1s to the left (inclusive of the current cell). Store these values in a new matrix `hist`. 
2. **Iterate rows:** For each row in the original matrix, treat the corresponding row in the `hist` matrix as a histogram.  Apply the algorithm to find the largest rectangle area in the histogram for each row. This algorithm uses stack to compute the largest rectangular area.
3. **Calculate Area**: For each row of histogram data, compute the area using the `largestRectangleArea` function and update `maxArea`.
4. **largestRectangleArea function**: This helper function is used to compute the area in histogram using stacks. This function has time complexity of O(n).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int largestRectangleArea(vector&lt;int&gt;&amp; heights) {
    int n = heights.size();
    stack&lt;int&gt; s;
    int maxArea = 0;
    int i = 0;
    while (i &lt;= n) {
        int height = (i == n) ? 0 : heights[i];
        if (s.empty() || height &gt;= heights[s.top()]) {
            s.push(i++);
        } else {
            int top = s.top();
            s.pop();
            int width = s.empty() ? i : i - s.top() - 1;
            maxArea = max(maxArea, heights[top] * width);
        }
    }
    return maxArea;
}

int maxRectangle(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
    if (matrix.empty() || matrix[0].empty()) {
        return 0;
    }

    int rows = matrix.size();
    int cols = matrix[0].size();
    vector&lt;vector&lt;int&gt;&gt; hist(rows, vector&lt;int&gt;(cols, 0));

    // Preprocess: Calculate the number of consecutive 1s to the left
    for (int i = 0; i &lt rows; ++i) {
        for (int j = 0; j &lt cols; ++j) {
            if (matrix[i][j] == 1) {
                hist[i][j] = (j == 0) ? 1 : hist[i][j - 1] + 1;
            }
        }
    }

    int maxArea = 0;
    for (int i = 0; i &lt rows; ++i) {
        maxArea = max(maxArea, largestRectangleArea(hist[i]));
    }
    return maxArea;
}
</code></pre>
  <p><b>Time Complexity:</b> O(rows * cols) - Preprocessing the `hist` matrix takes O(rows * cols). The largestRectangleArea function is called for each row taking O(cols). | <b>Space Complexity:</b> O(cols) - Space used by the hist matrix and stack for the largestRectangleArea function.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1, 0, 1, 0, 0],
 [1, 0, 1, 1, 1],
 [1, 1, 1, 1, 1],
 [1, 0, 0, 1, 0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The largest rectangle with all 1s has area 6 (formed by the second and third rows, and the middle three columns).</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0, 1, 1, 0],
 [1, 1, 1, 1],
 [0, 1, 1, 1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The largest rectangle has area 6.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1, 1, 1, 1],
 [1, 1, 1, 1],
 [1, 1, 1, 1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">12</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The largest rectangle has area 12.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases include empty matrices, matrices with only 0s, and matrices with only 1s. The crucial part of the optimized solution is recognizing the problem's relation to the largest rectangle area in a histogram problem, which can be efficiently solved using a stack. The preprocessing step to construct the histogram matrix is a key optimization step.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/find-number-of-islands/>Find the number of islands</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a 2D grid of size m x n, where each cell can be either a land ('1') or a water ('0'), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through each cell of the grid. If a cell is '1', perform a Depth-First Search (DFS) or Breadth-First Search (BFS) to mark the island as visited and increment the island count. This approach visits each cell and explores its neighbors, effectively identifying and counting the connected components of land.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int row, int col, int rows, int cols) {
    if (row &lt 0 || row &gt= rows || col &lt 0 || col &gt= cols || grid[row][col] == '0') {
        return;
    }
    grid[row][col] = '0'; // Mark as visited
    dfs(grid, row + 1, col, rows, cols); // Down
    dfs(grid, row - 1, col, rows, cols); // Up
    dfs(grid, row, col + 1, rows, cols); // Right
    dfs(grid, row, col - 1, rows, cols); // Left
}

int numIslands_brute(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
    if (grid.empty()) {
        return 0;
    }
    int rows = grid.size();
    int cols = grid[0].size();
    int islandCount = 0;

    for (int i = 0; i &lt rows; ++i) {
        for (int j = 0; j &lt cols; ++j) {
            if (grid[i][j] == '1') {
                dfs(grid, i, j, rows, cols);
                islandCount++;
            }
        }
    }
    return islandCount;
}
</code></pre>
  <p><b>Time Complexity:</b> O(M * N * 4), where M is the number of rows and N is the number of columns in the grid. In the worst case, the DFS might visit every cell. The DFS operation takes O(1) time per cell. | <b>Space Complexity:</b> O(M * N) in the worst case due to the recursion stack in DFS. In worst case, the entire grid is filled with land.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ DFS (Optimized)</h5>
  <p>Similar to the brute-force approach, but it utilizes DFS to traverse the grid and mark visited cells. This approach efficiently explores connected components (islands) by recursively visiting adjacent land cells and changing their value to '0' so as to mark them visited to prevent revisits.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int row, int col, int rows, int cols) {
    if (row &lt 0 || row &gt= rows || col &lt 0 || col &gt= cols || grid[row][col] == '0') {
        return;
    }
    grid[row][col] = '0'; // Mark as visited
    dfs(grid, row + 1, col, rows, cols); // Down
    dfs(grid, row - 1, col, rows, cols); // Up
    dfs(grid, row, col + 1, rows, cols); // Right
    dfs(grid, row, col - 1, rows, cols); // Left
}

int numIslands_optimized(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
    if (grid.empty()) {
        return 0;
    }
    int rows = grid.size();
    int cols = grid[0].size();
    int islandCount = 0;

    for (int i = 0; i &lt rows; ++i) {
        for (int j = 0; j &lt cols; ++j) {
            if (grid[i][j] == '1') {
                dfs(grid, i, j, rows, cols);
                islandCount++;
            }
        }
    }
    return islandCount;
}
</code></pre>
  <p><b>Time Complexity:</b> O(M * N), where M is the number of rows and N is the number of columns in the grid. Each cell is visited at most once. | <b>Space Complexity:</b> O(M * N) in the worst case due to the recursion stack in DFS, for a grid fully filled with land.</p>
  <h5>‚û§ BFS (Optimized)</h5>
  <p>This approach utilizes Breadth-First Search (BFS) to traverse the grid and mark visited cells. BFS explores the islands layer by layer. When a '1' is encountered, BFS is performed. The adjacent cells are enqueued, and then dequeued and marked '0' until all the adjacent land are visited. The island counter is then incremented.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

int numIslands_bfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
    if (grid.empty()) {
        return 0;
    }

    int rows = grid.size();
    int cols = grid[0].size();
    int islandCount = 0;

    for (int i = 0; i &lt rows; ++i) {
        for (int j = 0; j &lt cols; ++j) {
            if (grid[i][j] == '1') {
                islandCount++;
                queue&lt;pair&lt;int, int&gt;&gt; q;
                q.push({i, j});
                grid[i][j] = '0'; // Mark as visited

                while (!q.empty()) {
                    int row = q.front().first;
                    int col = q.front().second;
                    q.pop();

                    int dr[] = {0, 0, 1, -1};
                    int dc[] = {1, -1, 0, 0};

                    for (int k = 0; k &lt 4; ++k) {
                        int newRow = row + dr[k];
                        int newCol = col + dc[k];

                        if (newRow &gt= 0 &amp;&amp; newRow &lt rows &amp;&amp; newCol &gt= 0 &amp;&amp; newCol &lt cols &amp;&amp; grid[newRow][newCol] == '1') {
                            q.push({newRow, newCol});
                            grid[newRow][newCol] = '0'; // Mark as visited
                        }
                    }
                }
            }
        }
    }
    return islandCount;
}
</code></pre>
  <p><b>Time Complexity:</b> O(M * N), where M is the number of rows and N is the number of columns in the grid. Each cell is visited at most once. | <b>Space Complexity:</b> O(M * N) in the worst case, if the grid is entirely filled with '1's, the queue might store all cells.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">grid = [
  ['1','1','1','1','0'],
  ['1','1','0','1','0'],
  ['1','1','0','0','0'],
  ['0','0','0','0','0']
]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The grid has only one island formed by the connected '1's.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">grid = [
  ['1','1','0','0','0'],
  ['1','1','0','0','0'],
  ['0','0','1','0','0'],
  ['0','0','0','1','1']
]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The grid has three islands.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">grid = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The grid is empty, therefore there are no islands.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The problem can be efficiently solved using DFS or BFS. The key idea is to iterate through the grid, and whenever a '1' (land) is encountered, perform a DFS or BFS to mark the entire island as visited.  Be sure to handle empty grid edge case. The grid is modified in-place to mark the visited cells.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/given-matrix-o-x-replace-o-x-surrounded-x/>Given a matrix of O and X, replace O with X if surrounded by X</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a matrix represented as a 2D vector of characters, where each cell contains either 'O' or 'X', replace all 'O's that are surrounded by 'X's with 'X's. An 'O' is considered surrounded if it is not on the boundary of the matrix and all its adjacent cells (up, down, left, and right) contain 'X's.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the inner cells of the matrix. For each 'O', check if all its four neighbors are 'X's. If so, replace it with 'X'. This approach directly implements the problem's condition but is inefficient as it does not take into account any external factors like boundary conditions properly.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

void solveBruteForce(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
    if (board.empty() || board[0].empty()) return;

    int rows = board.size();
    int cols = board[0].size();

    for (int i = 1; i &lt rows - 1; ++i) {
        for (int j = 1; j &lt cols - 1; ++j) {
            if (board[i][j] == 'O') {
                if (board[i - 1][j] == 'X' &amp;&amp; board[i + 1][j] == 'X' &amp;&amp; board[i][j - 1] == 'X' &amp;&amp; board[i][j + 1] == 'X') {
                    board[i][j] = 'X';
                }
            }
        }
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(m * n), where m is the number of rows and n is the number of columns in the matrix. We iterate through the inner cells of the matrix. | <b>Space Complexity:</b> O(1). The algorithm uses constant extra space.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized: DFS or BFS from Boundaries</h5>
  <p>1.  **Identify Boundary 'O's:** Iterate through the boundary cells of the matrix. If a boundary cell contains 'O', start a Depth-First Search (DFS) or Breadth-First Search (BFS) from that cell.
2.  **Mark Connected 'O's:** During DFS/BFS, mark all 'O's connected to the boundary 'O's as temporarily safe (e.g., using a different character like '*'). This indicates that these 'O's are not surrounded.
3.  **Replace Remaining 'O's:** After the DFS/BFS, iterate through the entire matrix. Replace any remaining 'O's (those not marked as safe) with 'X's.  Restore the temporary markers ('*'s) back to 'O's.
This approach avoids unnecessary checks of inner elements that would be inefficient otherwise.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j) {
    int rows = board.size();
    int cols = board[0].size();

    if (i &lt 0 || i &gt= rows || j &lt 0 || j &gt= cols || board[i][j] != 'O') {
        return;
    }

    board[i][j] = '*'; // Mark as safe

    dfs(board, i + 1, j);
    dfs(board, i - 1, j);
    dfs(board, i, j + 1);
    dfs(board, i, j - 1);
}

void solveOptimized(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
    if (board.empty() || board[0].empty()) return;

    int rows = board.size();
    int cols = board[0].size();

    // 1. Check boundaries for 'O's and run DFS
    for (int i = 0; i &lt rows; ++i) {
        if (board[i][0] == 'O') dfs(board, i, 0);
        if (board[i][cols - 1] == 'O') dfs(board, i, cols - 1);
    }
    for (int j = 0; j &lt cols; ++j) {
        if (board[0][j] == 'O') dfs(board, 0, j);
        if (board[rows - 1][j] == 'O') dfs(board, rows - 1, j);
    }

    // 2. Replace surrounded 'O's with 'X' and restore '*'
    for (int i = 0; i &lt rows; ++i) {
        for (int j = 0; j &lt cols; ++j) {
            if (board[i][j] == 'O') {
                board[i][j] = 'X';
            } else if (board[i][j] == '*') {
                board[i][j] = 'O';
            }
        }
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(m * n), where m is the number of rows and n is the number of columns.  The DFS/BFS visits each cell at most once, and the other operations take O(m*n) time as well. | <b>Space Complexity:</b> O(m * n) in the worst case, due to the recursion depth of DFS or the queue size of BFS (when the entire board is filled with 'O's connected to the boundary).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">board = [['X','X','X','X'],['X','O','O','X'],['X','X','O','X'],['X','O','X','X']]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">board = [['X','X','X','X'],['X','X','X','X'],['X','X','X','X'],['X','O','X','X']]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The 'O' at (1,1) and (2,2) are surrounded by 'X's and hence flipped to 'X'.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">board = [['X']]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">board = [['X']]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No operation.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">board = [['O','X','O'],['X','O','X'],['O','X','O']]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">board = [['O','X','O'],['X','X','X'],['O','X','O']]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The 'O' at (1,1) is surrounded by 'X's and hence flipped to 'X'.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases to consider:

*   Empty board or board with zero columns/rows.
*   Board with only 'X's or only 'O's.
*   'O's on the boundary should never be flipped.
*   Use an additional character (e.g., '*') to temporarily mark safe 'O's during DFS/BFS to avoid modifying the original matrix prematurely.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/spiral-matrix/>Spiral Matrix</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an m x n matrix, return all elements of the matrix in spiral order.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Simulate the spiral traversal directly. Maintain boundaries for the top, bottom, left, and right sides of the matrix. Iterate through the matrix in a spiral fashion, moving right, down, left, and up, adjusting the boundaries after each traversal of a side.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

string matrixToString(const vector&ltvector&ltint&gt&gt;& matrix) {
    string result = "";
    for (const auto& row : matrix) {
        result += "[";
        for (int i = 0; i &lt row.size(); ++i) {
            result += to_string(row[i]);
            if (i &lt row.size() - 1) {
                result += ",";
            }
        }
        result += "] ";
    }
    return result;
}

string vectorToString(const vector&ltint&gt;& vec) {
    string result = "[";
    for (int i = 0; i &lt vec.size(); ++i) {
        result += to_string(vec[i]);
        if (i &lt vec.size() - 1) {
            result += ",";
        }
    }
    result += "]";
    return result;
}

vector&ltint&gt; spiralOrder_bruteForce(vector&ltvector&ltint&gt&gt;& matrix) {
    vector&ltint&gt; result;
    if (matrix.empty()) return result;

    int top = 0, bottom = matrix.size() - 1;
    int left = 0, right = matrix[0].size() - 1;
    int dir = 0; // 0: right, 1: down, 2: left, 3: up

    while (top &lt= bottom &amp;&amp; left &lt= right) {
        if (dir == 0) {
            for (int i = left; i &lt= right; i++) {
                result.push_back(matrix[top][i]);
            }
            top++;
        } else if (dir == 1) {
            for (int i = top; i &lt= bottom; i++) {
                result.push_back(matrix[i][right]);
            }
            right--;
        } else if (dir == 2) {
            for (int i = right; i &gt= left; i--) {
                result.push_back(matrix[bottom][i]);
            }
            bottom--;
        } else if (dir == 3) {
            for (int i = bottom; i &gt= top; i--) {
                result.push_back(matrix[i][left]);
            }
            left++;
        }
        dir = (dir + 1) % 4;
    }

    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(m * n), where m is the number of rows and n is the number of columns in the matrix. | <b>Space Complexity:</b> O(m * n) to store the result. In-place modification is not possible without affecting the final result.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Spiral Traversal</h5>
  <p>Use the same approach as brute force but with the same optimizations. Keep track of the boundaries and direction to move and update the boundaries accordingly.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

vector&ltint&gt; spiralOrder(vector&ltvector&ltint&gt;&gt;& matrix) {
    vector&ltint&gt; result;
    if (matrix.empty()) return result;

    int top = 0, bottom = matrix.size() - 1;
    int left = 0, right = matrix[0].size() - 1;
    int dir = 0; // 0: right, 1: down, 2: left, 3: up

    while (top &lt= bottom &amp;&amp; left &lt= right) {
        if (dir == 0) {
            for (int i = left; i &lt= right; i++) {
                result.push_back(matrix[top][i]);
            }
            top++;
        } else if (dir == 1) {
            for (int i = top; i &lt= bottom; i++) {
                result.push_back(matrix[i][right]);
            }
            right--;
        } else if (dir == 2) {
            for (int i = right; i &gt= left; i--) {
                result.push_back(matrix[bottom][i]);
            }
            bottom--;
        } else if (dir == 3) {
            for (int i = bottom; i &gt= top; i--) {
                result.push_back(matrix[i][left]);
            }
            left++;
        }
        dir = (dir + 1) % 4;
    }

    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(m * n), where m is the number of rows and n is the number of columns in the matrix. | <b>Space Complexity:</b> O(m * n) to store the result.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">matrix = [[1,2,3],[4,5,6],[7,8,9]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,3,6,9,8,7,4,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The spiral traversal starts from the top-left, moves right, then down, then left, and then up, going inwards until all elements are visited.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,3,4,8,12,11,10,9,5,6,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Similar to the previous example, but the matrix has different dimensions.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">matrix = [[7],[9],[6]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[7,9,6]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Test case with only one column.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">matrix = [[1,2,3]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Test case with only one row.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. Handle empty matrices correctly.
2. Properly update the boundaries (top, bottom, left, right) after each traversal of a side to avoid infinite loops.
3. The direction can be efficiently managed using the modulo operator.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/rotate-image/>Rotate Image</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Create a new matrix of the same size. Iterate through the original matrix and for each element at [row][col], place it in the new matrix at [col][n-1-row]. Then, copy the new matrix back into the original matrix.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt

using namespace std;

void rotate_brute_force(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
    int n = matrix.size();
    vector&lt;vector&lt;int&gt;&gt; rotated_matrix(n, vector&lt;int&gt;(n));

    for (int i = 0; i &lt; n; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            rotated_matrix[j][n - 1 - i] = matrix[i][j];
        }
    }

    matrix = rotated_matrix;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) | <b>Space Complexity:</b> O(n^2)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ In-place Rotation using Transpose and Reverse</h5>
  <p>1.  Transpose the matrix (swap rows and columns).  2.  Reverse each row of the transposed matrix.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt

using namespace std;

void rotate_optimized(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
    int n = matrix.size();

    // 1. Transpose the matrix
    for (int i = 0; i &lt; n; ++i) {
        for (int j = i; j &lt; n; ++j) {
            swap(matrix[i][j], matrix[j][i]);
        }
    }

    // 2. Reverse each row
    for (int i = 0; i &lt; n; ++i) {
        reverse(matrix[i].begin(), matrix[i].end());
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,2,3],[4,5,6],[7,8,9]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[7,4,1],[8,5,2],[9,6,3]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The matrix is rotated 90 degrees clockwise.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The matrix is rotated 90 degrees clockwise.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">A 1x1 matrix remains unchanged.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The in-place approach is crucial to meet the problem requirements. Transposing and reversing rows minimizes space complexity. Pay attention to the edge case of a 1x1 matrix. Understand the indexing and how elements move during the rotation.  The transposition step swaps elements across the main diagonal. The reversal step reflects each row around its center.</p>
</div>
<hr style="margin: 40px 0;">
<h2>Mathematical Problems</h2>
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/minimum-moves-to-equal-array-elements/>Minimum Moves to Equal Array Elements</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal. In one move, you can increment n - 1 elements of the array by 1.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves repeatedly incrementing all but one element until all elements become equal.  This is inefficient, as it doesn't provide any insight into an optimal solution. It would involve repeatedly finding the maximum element, incrementing all others, and repeating until all elements are equal.  This approach would be highly inefficient and is not a practical solution for this problem.</p>
  <pre><code class="language-python">// This is a conceptual illustration, not a practical solution.
// A practical brute-force implementation would be extremely inefficient.
// This example only demonstrates the idea, not a working algorithm.
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt; // Required for std::max_element

using namespace std;

int bruteForceMinMoves(vector&lt;int&gt;&amp; nums) {
    int moves = 0;
    while (true) {
        int max_val = *max_element(nums.begin(), nums.end());
        bool all_equal = true;
        for (int num : nums) {
            if (num != max_val) {
                all_equal = false;
                break;
            }
        }
        if (all_equal) {
            break;
        }
        int max_index = distance(nums.begin(), max_element(nums.begin(), nums.end()));
        for (int i = 0; i &lt; nums.size(); ++i) {
            if (i != max_index) {
                nums[i]++;
            }
        }
        moves++;
    }
    return moves;
}

// In a real-world scenario, this function would be called and tested, but it is inherently inefficient.
// A more optimized approach is clearly superior for this specific problem.
</code></pre>
  <p><b>Time Complexity:</b> O(n * (max - min)), where n is the number of elements, and max and min are the maximum and minimum values in the array. This is because, in the worst case, we might need to increment elements a considerable number of times. | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach</h5>
  <p>The core idea is that incrementing n-1 elements is equivalent to decrementing one element. Therefore, the minimum moves required is the sum of the differences between each element and the minimum element in the array. We can find the minimum element, then iterate through the array and calculate the sum of these differences.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt; // Required for std::accumulate

using namespace std;

int minMoves(vector&lt;int&gt;&amp; nums) {
    int min_val = *min_element(nums.begin(), nums.end());
    int moves = 0;
    for (int num : nums) {
        moves += (num - min_val);
    }
    return moves;
}

// int main() {
//     vector&lt;int&gt; nums = {1, 2, 3};
//     int result = minMoves(nums);
//     cout &lt;&lt; "Minimum moves: " &lt;&lt; result &lt;&lt; endl; // Output: 3
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the number of elements in the array. This is because we iterate through the array twice: once to find the minimum and once to calculate the moves. | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,2,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">We can increment the first two elements by 1 to make the array [2,2,3]. Then increment the first two elements again to make the array [3,3,3]. So the minimum moves is 2 + 1 = 3.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,1,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">All elements are already equal.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,5,10,15]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">29</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Minimum element is 1. The sum of differences: (5-1) + (10-1) + (15-1) = 4 + 9 + 14 = 27. But this is wrong example. It shouls be 24,  (15-1) + (15-5) + (15-10) = 14 + 10 + 5 = 29</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The problem highlights an important optimization technique: recognizing the equivalence of incrementing n-1 elements with decrementing a single element. This allows for a much simpler and efficient solution. The key insight is to find the minimum element, and then calculate the sum of the differences between each element and the minimum. This represents the minimum number of moves needed to equalize the array.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/add-binary/>Add Binary</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given two binary strings `a` and `b`, return their sum as a binary string.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Convert the binary strings to integers, add the integers, and then convert the sum back to a binary string.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

string addBinaryBruteForce(string a, string b) {
    // Convert binary strings to integers
    long long num_a = 0, num_b = 0;
    for (char c : a) {
        num_a = num_a * 2 + (c - '0');
    }
    for (char c : b) {
        num_b = num_b * 2 + (c - '0');
    }

    // Calculate sum
    long long sum = num_a + num_b;

    // Convert sum back to binary string
    if (sum == 0) return "0";
    string result = "";
    while (sum > 0) {
        result = to_string(sum % 2) + result;
        sum /= 2;
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(max(m, n)) where m and n are the lengths of a and b, respectively. This comes from converting the strings to integers (O(m) and O(n)), and then converting the sum back to binary (O(log(sum))). In the worst case, log(sum) is proportional to max(m, n). | <b>Space Complexity:</b> O(max(m, n)) because the binary string sum could potentially take up as much space as input.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach: Bitwise Addition with Carry</h5>
  <p>Simulate binary addition column by column, starting from the least significant bit (rightmost). Keep track of the carry.  Use bitwise operations for efficiency.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

string addBinaryOptimized(string a, string b) {
    string result = "";
    int i = a.length() - 1, j = b.length() - 1, carry = 0;

    while (i &gt= 0 || j &gt= 0 || carry) {
        int sum = carry;
        if (i &gt= 0) {
            sum += a[i] - '0';
            i--;
        }
        if (j &gt= 0) {
            sum += b[j] - '0';
            j--;
        }

        result = to_string(sum % 2) + result;
        carry = sum / 2;
    }

    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(max(m, n)) where m and n are the lengths of a and b. | <b>Space Complexity:</b> O(max(m, n)) to store the result.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">a = "11", b = "1"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">100</td>
        <td style="border: 1px solid #ccc; padding: 6px;">11 (3) + 1 (1) = 100 (4)</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">a = "1010", b = "1011"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">10101</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1010 (10) + 1011 (11) = 10101 (21)</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">a = "1", b = "0"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 + 0 = 1</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The optimized approach is preferred due to its efficiency. Edge cases to consider are when one string is much shorter than the other, or when one or both inputs are empty (handled implicitly in the optimized solution).  Also, handle the carry correctly at the end of the computation.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/maximum-product-of-three-numbers/>Maximum Product of Three Numbers</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given an integer array nums, return the maximum product of three numbers in nums. </p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible combinations of three numbers and calculate their product. Keep track of the maximum product found so far.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string maxProductOfThree_BruteForce(vector&lt;int&gt;&amp; nums) {
    long long maxProduct = LLONG_MIN;
    int n = nums.size();
    for (int i = 0; i &lt; n - 2; ++i) {
        for (int j = i + 1; j &lt; n - 1; ++j) {
            for (int k = j + 1; k &lt; n; ++k) {
                long long currentProduct = (long long)nums[i] * nums[j] * nums[k];
                maxProduct = max(maxProduct, currentProduct);
            }
        }
    }
    return to_string(maxProduct);
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^3) | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach with Sorting</h5>
  <p>Sort the array. The maximum product will either be the product of the three largest numbers or the product of the two smallest (most negative) numbers and the largest number.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string maxProductOfThree_Optimized(vector&lt;int&gt;&amp; nums) {
    sort(nums.begin(), nums.end());
    int n = nums.size();
    long long product1 = (long long)nums[n - 1] * nums[n - 2] * nums[n - 3];
    long long product2 = (long long)nums[0] * nums[1] * nums[n - 1];
    return to_string(max(product1, product2));
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log n) - due to sorting | <b>Space Complexity:</b> O(1)</p>
  <h5>‚û§ Optimized Approach without Sorting</h5>
  <p>Find the three largest and two smallest numbers in a single pass. Calculate the product of the three largest and the product of the two smallest and the largest. Return the maximum of the two.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string maxProductOfThree_Optimized_NoSort(vector&lt;int&gt;&amp; nums) {
    int min1 = INT_MAX, min2 = INT_MAX;
    int max1 = INT_MIN, max2 = INT_MIN, max3 = INT_MIN;

    for (int num : nums) {
        if (num &lt;= min1) {
            min2 = min1;
            min1 = num;
        } else if (num &lt;= min2) {
            min2 = num;
        }

        if (num &gt;= max1) {
            max3 = max2;
            max2 = max1;
            max1 = num;
        } else if (num &gt;= max2) {
            max3 = max2;
            max2 = num;
        } else if (num &gt;= max3) {
            max3 = num;
        }
    }

    long long product1 = (long long)max1 * max2 * max3;
    long long product2 = (long long)min1 * min2 * max1;
    return to_string(max(product1, product2));
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3 * 2 * 1 = 6</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,3,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">24</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4 * 3 * 2 = 24</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[-1,-2,-3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-1 * -2 * -3 = -6</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[-100,-98,-1,2,3,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">39200</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-100 * -98 * 4 = 39200 (two smallest negative numbers and the largest positive number)</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Consider the case where there are negative numbers. The product of the two smallest (most negative) numbers and the largest number might be the maximum product.  Also, handle edge cases such as an array with all negative numbers or an array with only a few elements.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/excel-sheet-column-title/>Excel Sheet Column Title</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet. For example:

1 -> A
2 -> B
3 -> C
... 
26 -> Z
27 -> AA
28 -> AB 
... 
</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach would involve repeatedly dividing the input number by 26 and converting the remainder to its corresponding character. However, because Excel uses a 1-based indexing system, the remainders need to be adjusted. Specifically, if the remainder is 0, it corresponds to 'Z', and we must decrement the quotient by 1 to account for this. This process continues until the quotient becomes 0.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string convertToTitle(int columnNumber) {
    string result = "";
    while (columnNumber &gt 0) {
        columnNumber--; // Adjust for 1-based indexing
        int remainder = columnNumber % 26;
        char character = 'A' + remainder;
        result = character + result;
        columnNumber /= 26;
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(log26(n)) where n is the input columnNumber. | <b>Space Complexity:</b> O(log26(n)) due to the space used by the result string.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach: Iterative Conversion</h5>
  <p>The optimized approach uses the same logic as the brute-force but optimizes it by efficiently manipulating the remainder and quotient to construct the column title string.  It directly calculates the characters in the title based on the remainder and updates the input number.  The primary optimization comes from reducing the overhead that might exist in a less streamlined approach.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string convertToTitle(int columnNumber) {
    string result = "";
    while (columnNumber &gt 0) {
        columnNumber--;
        result = char('A' + columnNumber % 26) + result;
        columnNumber /= 26;
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(log26(n)) where n is the input columnNumber. | <b>Space Complexity:</b> O(log26(n)) due to the space used by the result string.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">A</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The number 1 corresponds to column A.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">28</td>
        <td style="border: 1px solid #ccc; padding: 6px;">AB</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The number 28 corresponds to column AB.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">701</td>
        <td style="border: 1px solid #ccc; padding: 6px;">ZY</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The number 701 corresponds to column ZY.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">52</td>
        <td style="border: 1px solid #ccc; padding: 6px;">AZ</td>
        <td style="border: 1px solid #ccc; padding: 6px;">52 is 26 * 2, so the title is AZ</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">53</td>
        <td style="border: 1px solid #ccc; padding: 6px;">BA</td>
        <td style="border: 1px solid #ccc; padding: 6px;">53 is 26 * 2 + 1, so the title is BA</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Key points:

*   The problem requires conversion from an integer to an Excel column title (A-Z, AA-ZZ, etc.).
*   Excel column titles are based on a 26-base system with a 1-based indexing.
*   The crucial part of the solution is handling the zero remainder (which represents 'Z') and adjusting the input number accordingly.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/happy-number/>Happy Number</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given a positive integer `n`, determine if it is a happy number. A happy number is defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.

For example: 19 is a happy number.
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves repeatedly calculating the sum of squares of digits.  We need to check for cycles to avoid infinite loops.  We can do this by keeping track of the numbers we've seen before in a set. If we encounter a number already in the set, it means we're in a cycle and the number is not happy.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int sumOfSquares(int n) {
    int sum = 0;
    while (n &gt 0) {
        int digit = n % 10;
        sum += digit * digit;
        n /= 10;
    }
    return sum;
}

bool isHappyBruteForce(int n) {
    unordered_set&lt;int&gt; seen;
    while (n != 1 &amp;&amp; seen.find(n) == seen.end()) {
        seen.insert(n);
        n = sumOfSquares(n);
    }
    return n == 1;
}
</code></pre>
  <p><b>Time Complexity:</b> O(k * log n), where k is the number of iterations before finding 1 or a cycle.  In the worst case, k can be dependent on n. In the worst case when not happy, the number of iterations is proportional to the number of unique numbers formed by repeated square sum operations. Each square sum operation takes O(log n) time. | <b>Space Complexity:</b> O(k), where k is the number of unique numbers encountered during the process. In worst case, k can be proportional to n. So it will be O(log n) in average.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Floyd's Cycle-Finding Algorithm (Tortoise and Hare)</h5>
  <p>This optimized approach uses Floyd's cycle-finding algorithm, also known as the "tortoise and hare" algorithm.  This algorithm is efficient in detecting cycles in linked lists (or, in this case, in the sequence of numbers generated). We use two pointers, one (the "tortoise") that moves one step at a time and another (the "hare") that moves two steps at a time.  If there's a cycle, the hare will eventually catch the tortoise.  If the hare reaches 1, the number is happy. If the hare meets the tortoise, it means a cycle has been detected, and the number is not happy.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int sumOfSquares(int n) {
    int sum = 0;
    while (n &gt 0) {
        int digit = n % 10;
        sum += digit * digit;
        n /= 10;
    }
    return sum;
}

bool isHappyOptimized(int n) {
    int slow = n;
    int fast = sumOfSquares(n);

    while (fast != 1 &amp;&amp; slow != fast) {
        slow = sumOfSquares(slow);
        fast = sumOfSquares(sumOfSquares(fast));
    }

    return fast == 1;
}
</code></pre>
  <p><b>Time Complexity:</b> O(log n). The number of iterations is proportional to the number of steps required to reach 1 or detect the cycle which is again dependent on number of digits. The sumOfSquares function has complexity O(log n). | <b>Space Complexity:</b> O(1). This algorithm uses constant extra space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">19</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1^2 + 9^2 = 82, 8^2 + 2^2 = 68, 6^2 + 8^2 = 100, 1^2 + 0^2 + 0^2 = 1</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2^2 = 4, 4^2 = 16, 1^2 + 6^2 = 37, 3^2 + 7^2 = 58, 5^2 + 8^2 = 89, 8^2 + 9^2 = 145, 1^2 + 4^2 + 5^2 = 42, 4^2 + 2^2 = 20, 2^2 + 0^2 = 4...  (cycle)</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">It is already 1.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases to consider include the input being 1 or a number that quickly becomes 1. Also consider numbers that enter a cycle quickly. Floyd's algorithm is generally preferred due to its better space complexity.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/palindrome-number/>Palindrome Number</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given an integer x, return true if x is a palindrome, and false otherwise. An integer is a palindrome when it reads the same backward as forward. For example, 121 is a palindrome while 123 is not.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Convert the integer to a string, and then compare the string with its reverse.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool isPalindrome_bruteForce(int x) {
    if (x &lt 0) {
        return false;
    }
    string s = to_string(x);
    string reversed_s = s;
    reverse(reversed_s.begin(), reversed_s.end());
    return s == reversed_s;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the number of digits in x (due to string conversion and reversal). | <b>Space Complexity:</b> O(n), for the string representation of x.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized (Reversing Half the Number)</h5>
  <p>Reverse the second half of the number and compare it with the first half. Handle edge cases like negative numbers and numbers ending in zero (except for 0 itself).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool isPalindrome_optimized(int x) {
    if (x &lt 0 || (x % 10 == 0 && x != 0)) {
        return false;
    }

    int reversed_half = 0;
    while (x &gt reversed_half) {
        reversed_half = reversed_half * 10 + x % 10;
        x /= 10;
    }

    return x == reversed_half || x == reversed_half / 10; //Handles odd length palindrome
}
</code></pre>
  <p><b>Time Complexity:</b> O(log n), where n is the number of digits in x. The loop iterates roughly half the number of digits. | <b>Space Complexity:</b> O(1), constant space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">121</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">121 reads as 121 from left to right and from right to left.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">-121</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">From left to right, it reads -121. From right to left, it reads 121-. Therefore it is not a palindrome.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">10</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Reads 01 from right to left. Therefore it is not a palindrome.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">12321</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">12321 reads as 12321 from left to right and from right to left.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0 reads as 0 from left to right and from right to left.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases: Negative numbers are not palindromes. Numbers ending in zero (except 0 itself) cannot be palindromes because the reversed number would begin with zero. When reversing half, the result might be one digit shorter than the original if the original number had an odd number of digits. Therefore, we need to consider both x == reversed_half (for even length numbers) and x == reversed_half / 10 (for odd length numbers).</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/missing-number/>Missing Number</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the numbers from 0 to n. For each number, check if it exists in the input array. If a number is not found, return it.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string bruteForce(vector&lt;int&gt;& nums) {
    int n = nums.size();
    for (int i = 0; i &lt= n; ++i) {
        bool found = false;
        for (int j = 0; j &lt; n; ++j) {
            if (nums[j] == i) {
                found = true;
                break;
            }
        }
        if (!found) {
            return to_string(i);
        }
    }
    return ""; // Should not reach here
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Using Summation Formula</h5>
  <p>Calculate the sum of numbers from 0 to n using the formula n*(n+1)/2. Calculate the sum of the numbers in the input array. The difference between the two sums is the missing number.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string optimalSummation(vector&lt;int&gt;& nums) {
    int n = nums.size();
    int expectedSum = n * (n + 1) / 2;
    int actualSum = 0;
    for (int num : nums) {
        actualSum += num;
    }
    return to_string(expectedSum - actualSum);
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) | <b>Space Complexity:</b> O(1)</p>
  <h5>‚û§ Using XOR</h5>
  <p>Use the XOR operation. XOR all the numbers from 0 to n and XOR all the numbers in the input array. The result is the missing number.  The XOR operation cancels out duplicate numbers, and the missing number is left.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string optimalXOR(vector&lt;int&gt;& nums) {
    int missing = nums.size(); // Initialize missing with n
    for (int i = 0; i &lt; nums.size(); ++i) {
        missing ^= i ^ nums[i];
    }
    return to_string(missing);
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [3,0,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 3. The missing number is 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [0,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 2. The missing number is 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [9,6,4,2,3,5,7,0,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">8</td>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 9. The missing number is 8.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The input array will always contain n distinct numbers. The numbers are in the range [0, n]. The problem can be solved efficiently using mathematical formulas or bitwise operations. Edge cases include an empty input array (should not happen based on constraints) and an array where the missing number is 0 or n.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/reverse-integer/>Reverse Integer</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given a 32-bit signed integer, reverse its digits. If the reversed integer overflows (i.e., goes beyond the 32-bit signed integer range [-2^31, 2^31 - 1]), then return 0.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Convert the integer to a string, reverse the string, and convert the reversed string back to an integer. Handle the sign separately. Check for overflow before returning.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt; // Required for INT_MAX and INT_MIN

using namespace std;

int reverseIntegerBruteForce(int x) {
    string s = to_string(x);
    bool isNegative = (x &lt; 0);
    if (isNegative) {
        s = s.substr(1);
    }
    reverse(s.begin(), s.end());

    long long reversedNum = 0;
    try {
        reversedNum = stoll(s);
    } catch (const std::out_of_range&amp;) {
        return 0; // Overflow
    }

    if (isNegative) {
        reversedNum = -reversedNum;
    }

    if (reversedNum &lt; INT_MIN || reversedNum &gt; INT_MAX) {
        return 0; // Overflow
    }

    return (int)reversedNum;
}
</code></pre>
  <p><b>Time Complexity:</b> O(log(x)), where x is the input integer. Conversion to string, reversing, and conversion back take time proportional to the number of digits. | <b>Space Complexity:</b> O(log(x)) due to the string representation of the number.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach (Without String Conversion)</h5>
  <p>Iteratively extract the last digit of the number, build the reversed number, and check for overflow at each step. We can detect overflow before it happens by comparing the reversed number with the maximum or minimum allowed value divided by 10.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;climits&gt; // Required for INT_MAX and INT_MIN

using namespace std;

int reverseIntegerOptimized(int x) {
    int reversed = 0;
    while (x != 0) {
        int digit = x % 10;
        x /= 10;

        // Check for overflow before multiplying
        if (reversed &gt; INT_MAX / 10 || (reversed == INT_MAX / 10 &amp;&amp; digit &gt; 7)) {
            return 0; // Overflow
        }
        if (reversed &lt; INT_MIN / 10 || (reversed == INT_MIN / 10 &amp;&amp; digit &lt; -8)) {
            return 0; // Overflow
        }

        reversed = reversed * 10 + digit;
    }
    return reversed;
}
</code></pre>
  <p><b>Time Complexity:</b> O(log(x)), where x is the input integer. The while loop runs once for each digit. | <b>Space Complexity:</b> O(1), constant space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">123</td>
        <td style="border: 1px solid #ccc; padding: 6px;">321</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The reversed integer is 321.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">-123</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-321</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The reversed integer is -321.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">120</td>
        <td style="border: 1px solid #ccc; padding: 6px;">21</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The reversed integer is 21.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The reversed integer is 0.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1534236469</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The reversed integer overflows.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Important edge cases include handling negative numbers correctly, leading zeros, and overflow conditions. The most crucial part is the overflow check, which should be done before any multiplication or addition that might cause an overflow. Use INT_MAX and INT_MIN from climits to check for overflow.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/power-of-two/>Power of Two</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given an integer `n`, return `true` if it is a power of two. Otherwise, return `false`. An integer `n` is a power of two if there exists an integer `x` such that `n == 2^x`.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iteratively divide the number by 2 until it becomes 1. If at any point the remainder is not 0, then it's not a power of 2. Also handle the edge cases of n &lt;= 0</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

bool isPowerOfTwo_bruteForce(int n) {
    if (n &lt;= 0) {
        return false;
    }
    while (n % 2 == 0) {
        n /= 2;
    }
    return n == 1;
}
</code></pre>
  <p><b>Time Complexity:</b> O(log2(n)) | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Bit Manipulation</h5>
  <p>A number is a power of 2 if and only if it has only one set bit in its binary representation. We can check this using the bitwise AND operation: `n & (n - 1)` should be 0. Also, handle the edge case of n &lt;= 0. Additionally, we should handle the edge case of n == 0, which would return false, otherwise, all negative powers of 2 would also evaluate to true.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

bool isPowerOfTwo_optimized(int n) {
    if (n &lt;= 0) {
        return false;
    }
    return (n & (n - 1)) == 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(1) | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2^0 = 1</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">16</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2^4 = 16</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3 is not a power of 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0 is not a power of 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">-16</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-16 is not a power of 2, and also is &lt;=0 so it fails the initial check.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases: n &lt;= 0. Negative numbers are not powers of 2. 0 is not a power of 2. The bit manipulation approach is significantly faster because it uses a constant time operation. The brute force approach is slower as it involves iterative division.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/max-points-on-a-line/>Max Points on a Line</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an array of `points` where `points[i] = [xi, yi]` represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all pairs of points and calculate the line they define.  For each line, iterate through the remaining points to see how many lie on that line.  Keep track of the maximum count.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct Point {
    int x, y;
};

int maxPointsBruteForce(vector&lt;Point&gt;& points) {
    int n = points.size();
    if (n &lt= 2) return n;
    int max_points = 0;

    for (int i = 0; i &lt n; ++i) {
        for (int j = i + 1; j &lt n; ++j) {
            int count = 2; // At least two points on the line
            for (int k = 0; k &lt n; ++k) {
                if (k != i &amp;&amp; k != j) {
                    // Check if point k is on the line defined by i and j
                    if ((long long)(points[j].y - points[i].y) * (points[k].x - points[i].x) == (long long)(points[k].y - points[i].y) * (points[j].x - points[i].x))
                         {
                        count++;
                    }
                }
            }
            max_points = max(max_points, count);
        }
    }
    return max_points;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^3) | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Hash Map for Slope Calculation</h5>
  <p>Iterate through each point. For each point, calculate the slopes formed by the lines with all other points. Use a hash map (or unordered_map in C++) to store the slope and its count. Find the maximum count for each point and update the overall maximum.  Handle the edge cases where points are the same or when the line is vertical (infinite slope).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct Point {
    int x, y;
};

int maxPointsOptimized(vector&lt;Point&gt;& points) {
    int n = points.size();
    if (n &lt= 2) return n;
    int max_points = 0;

    for (int i = 0; i &lt n; ++i) {
        unordered_map&lt;double, int&gt; slopes;
        int same_point = 1;  // count of same points as points[i]
        int vertical_lines = 0;

        for (int j = i + 1; j &lt n; ++j) {
            if (points[i].x == points[j].x &amp;&amp; points[i].y == points[j].y) {
                same_point++;
            } else if (points[i].x == points[j].x) {
                vertical_lines++;
            } else {
                double slope = (double)(points[j].y - points[i].y) / (points[j].x - points[i].x);
                slopes[slope]++;
            }
        }

        int current_max = vertical_lines + same_point; // Handle Vertical lines
        for (auto const&amp; [slope, count] : slopes) {
            current_max = max(current_max, count + same_point);
        }
        max_points = max(max_points, current_max);
    }

    return max_points;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) | <b>Space Complexity:</b> O(n)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,1],[2,2],[3,3]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">All three points lie on the same line.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The points [1,1], [2,3], [3,2], and [4,1] lie on the same line.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0,0],[1,1],[0,0],[2,2]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Handle duplicate points correctly.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0,0],[94911151,94911152],[94911152,94911153]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Shows the integer overflow and handles floating point correctly.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  **Integer Overflow**: When calculating the slope, use long long to prevent integer overflow.  Alternatively, reduce the fraction to its lowest term using GCD to compare slopes. 
2.  **Duplicate Points**:  Handle the case of duplicate points.  A point can contribute to the maximum count multiple times if it's on the same line as other points.
3.  **Vertical Lines**: Handle the case of vertical lines (infinite slope) separately to avoid division by zero.
4.  **Edge cases**: Consider cases with 0, 1, or 2 points.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/valid-square/>Valid Square</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given the coordinates of four points in the 2D plane, return whether they represent a valid square. You can assume that the input order is not guaranteed. A valid square has four equal sides and four right angles. Note that the order of the four points does not matter.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Calculate all the distances between every pair of points. Check if there are exactly four equal side lengths and two equal diagonals. Also, ensure that the side lengths are not zero.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    double dist(vector&lt;int&gt;&amp; p1, vector&lt;int&gt;&amp; p2) {
        return sqrt(pow(p1[0] - p2[0], 2) + pow(p1[1] - p2[1], 2));
    }

    bool validSquare(vector&lt;int&gt;&amp; p1, vector&lt;int&gt;&amp; p2, vector&lt;int&gt;&amp; p3, vector&lt;int&gt;&amp; p4) {
        vector&lt;vector&lt;int&gt;&gt; points = {p1, p2, p3, p4};
        vector&lt;double&gt; distances;

        for (int i = 0; i &lt; 4; ++i) {
            for (int j = i + 1; j &lt; 4; ++j) {
                distances.push_back(dist(points[i], points[j]));
            }
        }

        sort(distances.begin(), distances.end());

        // Check for zero distances (same point)
        if (distances[0] == 0) return false;

        // Check if all 4 sides are equal and the two diagonals are equal
        return distances[0] == distances[1] && distances[1] == distances[2] && distances[2] == distances[3] &&
               distances[4] == distances[5] && distances[0] != distances[4];
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(1) - Constant time due to the fixed number of points. The operations like calculating distances and sorting take constant time. | <b>Space Complexity:</b> O(1) - Constant space. We use a fixed amount of space to store distances and points.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach</h5>
  <p>Calculate distances between all pairs of points. Then, check that exactly four distances are equal (sides) and that these are not zero and the other two distances (diagonals) are equal and also not zero. Ensure diagonals are larger than sides and are equal. Also ensures no point is the same as another.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    double distSq(vector&lt;int&gt;&amp; p1, vector&lt;int&gt;&amp; p2) {
        return pow(p1[0] - p2[0], 2) + pow(p1[1] - p2[1], 2);
    }

    bool validSquare(vector&lt;int&gt;&amp; p1, vector&lt;int&gt;&amp; p2, vector&lt;int&gt;&amp; p3, vector&lt;int&gt;&amp; p4) {
        vector&lt;vector&lt;int&gt;&gt; points = {p1, p2, p3, p4};
        vector&lt;double&gt; distances;

        for (int i = 0; i &lt; 4; ++i) {
            for (int j = i + 1; j &lt; 4; ++j) {
                distances.push_back(distSq(points[i], points[j]));
            }
        }

        sort(distances.begin(), distances.end());

        if (distances[0] == 0) return false; // Check if points are the same
        return distances[0] == distances[1] && distances[1] == distances[2] && distances[2] == distances[3] &&
               distances[4] == distances[5] && distances[0] != distances[4];
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(1) - Constant time due to the fixed number of points. | <b>Space Complexity:</b> O(1) - Constant space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">p1 = [0,0], p2 = [1,0], p3 = [1,1], p4 = [0,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The points form a valid square.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The points do not form a valid square. Diagonals are equal, but sides are not.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">p1 = [0,0], p2 = [0,0], p3 = [1,1], p4 = [1,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Two points are the same, therefore invalid square.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">p1 = [0,0], p2 = [1,0], p3 = [0,1], p4 = [1,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The points form a valid square.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. The problem requires careful consideration of edge cases like duplicate points. 2. The order of input points doesn't matter, so a robust solution should be order-agnostic. 3. Calculating squared distances avoids the need for floating-point comparisons which can be prone to precision errors.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/the-kth-factor-of-n/>The kth Factor of n</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given two positive integers n and k. A factor of n is a positive integer i such that n % i == 0. Return the kth factor of n. If n has less than k factors, return -1.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all numbers from 1 to n and check if they are factors. Keep a counter to track the kth factor. If the counter reaches k, return the current factor. If the loop finishes without finding the kth factor, return -1.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

int kthFactor_bruteforce(int n, int k) {
    int factor_count = 0;
    for (int i = 1; i &lt= n; ++i) {
        if (n % i == 0) {
            factor_count++;
            if (factor_count == k) {
                return i;
            }
        }
    }
    return -1;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach (Iterate up to sqrt(n))</h5>
  <p>Iterate from 1 to the square root of n. For each factor found, check if its pair is different. If it is, and the number of factors found reaches k, return the paired factor. Also maintain counter for the number of factors found. If the counter becomes equal to k, return the current factor itself. The advantage is we only need to iterate to sqrt(n) which decreases the computation time.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

int kthFactor_optimized(int n, int k) {
    int factor_count = 0;
    for (int i = 1; i * i &lt= n; ++i) {
        if (n % i == 0) {
            factor_count++;
            if (factor_count == k) {
                return i;
            }
            if (i * i != n) {
                if (factor_count + 1 == k) {
                    return n / i;
                }
                factor_count++;
            }
        }
    }
    return -1;
}
</code></pre>
  <p><b>Time Complexity:</b> O(sqrt(n)) | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 12, k = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Factors of 12 are [1, 2, 3, 4, 6, 12]. The 3rd factor is 3.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 7, k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">7</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Factors of 7 are [1, 7]. The 2nd factor is 7.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 4, k = 4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Factors of 4 are [1, 2, 4]. There are only 3 factors, so return -1.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 1, k = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Factors of 1 are [1]. The 1st factor is 1.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 1000, k = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Factors of 1000 are [1, 2, 4, 5, 8, 10, 20, 25, 40, 50, 100, 125, 200, 250, 500, 1000]. The 3rd factor is 4.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases include n = 1 and k = 1. Also, remember to check for the case where n has fewer than k factors, and return -1 in that case. Optimization is achieved by iterating up to the square root of n.</p>
</div>
<hr style="margin: 40px 0;">
<h2>Sorting and Searching</h2>
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/permute-two-arrays-sum-every-pair-greater-equal-k/>Permute two arrays such that sum of every pair is greater than or equal to K</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given two arrays of integers, `A` and `B`, and an integer `K`. The task is to check if it is possible to permute the arrays such that the sum of every pair `(A[i], B[i])` is greater than or equal to `K` for all `i`. If such a permutation exists, return `true`; otherwise, return `false`.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves generating all possible permutations of array `A` and then, for each permutation, trying to find a valid permutation of array `B` such that the sum condition is met. This involves nested loops and checking all combinations, leading to a high time complexity.</p>
  <pre><code class="language-python">#include &ltiostream&gt
#include &ltvector&gt
#include &ltalgorithm&gt

using namespace std;

bool canPermuteBruteForce(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, int K) {
    if (A.size() != B.size()) {
        return false;
    }
    int n = A.size();

    sort(A.begin(), A.end()); // Sort A for easier permutation checks.

    do {
        vector&lt;int&gt; B_copy = B;
        sort(B_copy.begin(), B_copy.end()); // Sort B.

        bool possible = true;
        do {
            for (int i = 0; i &lt; n; ++i) {
                if (A[i] + B_copy[i] &lt; K) {
                    possible = false;
                    break;
                }
            }
            if (possible) {
                return true;
            }
        } while (next_permutation(B_copy.begin(), B_copy.end()));

    } while (next_permutation(A.begin(), A.end()));

    return false;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N! * N * N!) where N is the size of the array. Permuting A takes O(N!) and for each permutation of A, permuting B takes O(N!). Checking the condition within each permutation takes O(N). | <b>Space Complexity:</b> O(N) for the copy of vector B.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach: Sorting and Two Pointers</h5>
  <p>The optimized approach involves sorting array `A` in ascending order and array `B` in descending order. Then, we iterate through both arrays simultaneously, checking if the sum of the corresponding elements (A[i] + B[i]) is greater than or equal to `K`. If at any point this condition fails, it means no such permutation exists, and we can return `false`. If the condition holds true for all pairs, then a valid permutation has been found and we return `true`.</p>
  <pre><code class="language-python">#include &ltiostream&gt
#include &ltvector&gt
#include &ltalgorithm&gt

using namespace std;

bool canPermuteOptimized(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, int K) {
    if (A.size() != B.size()) {
        return false;
    }
    int n = A.size();

    sort(A.begin(), A.end()); // Sort A in ascending order
    sort(B.begin(), B.end(), greater&lt;int&gt;()); // Sort B in descending order

    for (int i = 0; i &lt; n; ++i) {
        if (A[i] + B[i] &lt; K) {
            return false;
        }
    }

    return true;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N log N) due to sorting both arrays. | <b>Space Complexity:</b> O(1) as sorting is done in-place, no extra space is required.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">A = {2, 1, 3}, B = {7, 8, 9}, K = 10</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Sort A = {1, 2, 3} and B = {9, 8, 7}.  1+9 >= 10, 2+8 >= 10, 3+7 >= 10.  All conditions are met.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">A = {1, 2, 2, 1}, B = {3, 3, 3, 4}, K = 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Sort A = {1, 1, 2, 2} and B = {4, 3, 3, 3}.  1+4 >= 5, 1+3 >= 5, 2+3 >= 5, 2+3 >= 5.  All conditions are met.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">A = {1, 2, 2, 1}, B = {3, 3, 4, 1}, K = 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Sort A = {1, 1, 2, 2} and B = {4, 3, 3, 1}.  1+4 >= 5, 1+3 >= 5, 2+3 >= 5, 2+1 < 5. One or more pair's sum is less than K.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The crucial optimization is sorting the arrays in a specific order.  Sorting array A in ascending order and B in descending order is the key to efficient checking. This ensures that we pair the smallest element in A with the largest in B, the second smallest with the second largest, and so on. This maximizes the chances of meeting the sum condition and avoids the need to explore all possible permutations, unlike the brute force approach.  The edge case to consider is when the arrays have different sizes.  Also, if any pair sum is less than K, the problem can immediately return false.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/ceiling-in-a-sorted-array/>Ceiling in a Sorted Array</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given a sorted array arr[] of size N and an element key, find the ceiling of the key in the array. The ceiling of a key is the smallest element in the array greater than or equal to the key. If the key is greater than the largest element in the array, return -1.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the array and find the first element that is greater than or equal to the key. If no such element is found, return -1.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

int findCeil(int arr[], int n, int key) {
    int ceiling = -1;
    for (int i = 0; i &lt n; i++) {
        if (arr[i] &gt= key) {
            ceiling = arr[i];
            break;
        }
    }
    return ceiling;
}

// Example usage (not part of the solution, but for demonstration)
// int main() {
//     int arr[] = {1, 2, 8, 10, 10, 12, 19};
//     int n = sizeof(arr) / sizeof(arr[0]);
//     int key = 3;
//     int result = findCeil(arr, n, key);
//     cout &lt&lt "Ceiling of " &lt&lt key &lt&lt " is " &lt&lt result &lt&lt endl;
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(N) | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Binary Search</h5>
  <p>Use binary search to efficiently find the ceiling of the key. If the key is found, return the key itself. If the key is not found, the binary search will eventually narrow down to the position where the key should be, and the element at that position is the ceiling.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

int findCeil(int arr[], int n, int key) {
    int low = 0, high = n - 1;
    int ceiling = -1;

    while (low &lt= high) {
        int mid = low + (high - low) / 2;

        if (arr[mid] == key) {
            return arr[mid];
        } else if (arr[mid] &lt key) {
            low = mid + 1;
        } else {
            ceiling = arr[mid]; // Potential ceiling
            high = mid - 1;
        }
    }
    return ceiling;
}

// Example usage (not part of the solution, but for demonstration)
// int main() {
//     int arr[] = {1, 2, 8, 10, 10, 12, 19};
//     int n = sizeof(arr) / sizeof(arr[0]);
//     int key = 3;
//     int result = findCeil(arr, n, key);
//     cout &lt&lt "Ceiling of " &lt&lt key &lt&lt " is " &lt&lt result &lt&lt endl;
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(log N) | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr[] = {1, 2, 8, 10, 10, 12, 19}, key = 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">8</td>
        <td style="border: 1px solid #ccc; padding: 6px;">8 is the smallest element in the array greater than or equal to 5.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr[] = {1, 2, 8, 10, 10, 12, 19}, key = 20</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">20 is greater than the largest element in the array. Hence, ceiling does not exist.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr[] = {1, 2, 8, 10, 10, 12, 19}, key = 10</td>
        <td style="border: 1px solid #ccc; padding: 6px;">10</td>
        <td style="border: 1px solid #ccc; padding: 6px;">10 is present in the array, and thus it is the ceiling.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The array is assumed to be sorted. The binary search approach is much more efficient than brute force, especially for large arrays. Handle edge cases where the key is smaller than the smallest element (ceiling is the smallest element), or the key is greater than the largest element (no ceiling exists).</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/find-a-pair-with-the-given-difference/>Find a pair with the given difference</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given an array of integers and a target difference, find if there exists a pair of elements in the array whose difference is equal to the target difference. The pair can be (a, b) or (b, a).</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible pairs of elements in the array and check if their absolute difference equals the target difference.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool findPairWithDifferenceBruteForce(int arr[], int n, int diff) {
    for (int i = 0; i &lt n; i++) {
        for (int j = i + 1; j &lt n; j++) {
            if (abs(arr[i] - arr[j]) == diff) {
                return true;
            }
        }
    }
    return false;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Sorting and Two Pointers</h5>
  <p>Sort the array. Use two pointers, one at the beginning and one at the second element. Calculate the difference between the elements at the two pointers. If the difference equals the target, return true. If the difference is less than the target, move the right pointer. If the difference is greater than the target, move the left pointer.  Repeat until the pointers cross each other.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool findPairWithDifferenceOptimized(int arr[], int n, int diff) {
    sort(arr, arr + n);
    int left = 0, right = 1;
    while (left &lt n &amp;&amp; right &lt n) {
        if (left != right &amp;&amp; arr[right] - arr[left] == diff) {
            return true;
        } else if (arr[right] - arr[left] &lt diff) {
            right++;
        } else {
            left++;
        }
        if (left == right) {
            right++;
        }
    }
    return false;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log n) for sorting, and O(n) for two-pointer traversal, so overall O(n log n) | <b>Space Complexity:</b> O(1)</p>
  <h5>‚û§ Using a Hash Set</h5>
  <p>Iterate through the array. For each element, check if element + diff or element - diff exists in the hash set. If either exists, return true. Otherwise, add the element to the hash set.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool findPairWithDifferenceHashSet(int arr[], int n, int diff) {
    unordered_set&lt;int&gt; seen;
    for (int i = 0; i &lt n; i++) {
        if (seen.find(arr[i] + diff) != seen.end() || seen.find(arr[i] - diff) != seen.end()) {
            return true;
        }
        seen.insert(arr[i]);
    }
    return false;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) | <b>Space Complexity:</b> O(n)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr[] = {5, 20, 3, 2, 50, 80}, diff = 78</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">80 - 2 = 78</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr[] = {90, 70, 20, 80, 50}, diff = 45</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No pair found with the difference 45.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr[] = {1, 5, 3, 4, 2}, diff = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3 - 1 = 2</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The hash set approach is generally the most efficient in terms of time complexity. The sorting and two-pointer method works well when the array needs to be sorted for other purposes anyway.  Be mindful of the absolute difference requirement: the order of the pair doesn't matter.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/permute-two-arrays-sum-every-pair-greater-equal-k/>Permute two arrays such that sum of every pair is greater than or equal to K</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given two arrays of integers, A and B, and an integer K, the task is to determine if it is possible to permute the arrays such that for every index i, A[i] + B[i] &gt;= K. If a permutation exists, return true; otherwise, return false.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Generate all permutations of array A. For each permutation of A, try to pair it with array B and check if the condition A[i] + B[i] &gt;= K holds for all i. This approach is highly inefficient because of the permutation generation.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

bool canPermute(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B, int K) {
    if (A.size() != B.size()) {
        return false;
    }

    sort(A.begin(), A.end());
    sort(B.begin(), B.end(), greater&lt;int&gt;()); // Sort B in descending order

    for (int i = 0; i &lt; A.size(); ++i) {
        if (A[i] + B[i] &lt; K) {
            return false;
        }
    }

    return true;
}

</code></pre>
  <p><b>Time Complexity:</b> O(N! * N) - where N is the size of arrays (for generating permutations and checking the condition for each) | <b>Space Complexity:</b> O(1) - (excluding space for storing the arrays themselves)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Sorting and Two Pointers</h5>
  <p>Sort array A in ascending order and array B in descending order. Iterate through both arrays simultaneously using two pointers, one from the beginning of A and the other from the end of B. Check if the sum of the corresponding elements is greater than or equal to K. If at any point, the sum is less than K, it's impossible to achieve the condition.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

bool canPermuteOptimized(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B, int K) {
    if (A.size() != B.size()) {
        return false;
    }

    sort(A.begin(), A.end());
    sort(B.begin(), B.end(), greater&lt;int&gt;()); // Sort B in descending order

    for (int i = 0; i &lt; A.size(); ++i) {
        if (A[i] + B[i] &lt; K) {
            return false;
        }
    }

    return true;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N log N) - dominated by the sorting operations (N being the size of the arrays) | <b>Space Complexity:</b> O(1) - (excluding space for storing the arrays themselves)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">A = {2, 1, 3}, B = {7, 8, 9}, K = 10</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Permute A to {1, 2, 3} and B remains as {9, 8, 7}. 1+9 &gt;= 10, 2+8 &gt;= 10, 3+7 &gt;= 10.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">A = {1, 2, 2, 1}, B = {3, 3, 3, 4}, K = 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Permute A to {1, 1, 2, 2}, and B remains as {4, 3, 3, 3}. 1+4 &gt;= 5, 1+3 &lt; 5. Sorting A and B such that A = {1,1,2,2} and B = {4,3,3,3}. Now we have 1 + 4 &gt;= 5, 1+3 &lt; 5, thus we need to make B as {4,3,3,3} so result is true.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">A = {1, 2, 2, 1}, B = {3, 3, 4, 3}, K = 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">It's not possible to permute A and B such that A[i] + B[i] &gt;= 5 for all i.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to solving this problem efficiently is to realize that to maximize the chances of the sum being greater than or equal to K, we should pair the smallest element in array A with the largest element in array B, the second smallest element in A with the second largest in B, and so on. This suggests sorting the arrays and pairing them accordingly. Edge cases include empty arrays or arrays of different sizes which must be handled.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/check-reversing-sub-array-make-array-sorted/>Check if reversing a sub-array can make the array sorted</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an array of integers, determine if it's possible to sort the array by reversing a single sub-array. In other words, find a sub-array within the given array, reverse it, and check if the entire array becomes sorted in non-decreasing order. If such a sub-array exists, return 'Yes'; otherwise, return 'No'.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves iterating through all possible sub-arrays, reversing each one, checking if the resulting array is sorted, and reverting the reversal. This involves generating all possible start and end indices for sub-arrays.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool is_sorted(const vector&lt;int&gt;& arr) {
    for (size_t i = 0; i &lt arr.size() - 1; ++i) {
        if (arr[i] &gt arr[i + 1]) {
            return false;
        }
    }
    return true;
}

string check_reversal(vector&lt;int&gt; arr) {
    int n = arr.size();
    for (int i = 0; i &lt n; ++i) {
        for (int j = i; j &lt n; ++j) {
            vector&lt;int&gt; temp_arr = arr;
            reverse(temp_arr.begin() + i, temp_arr.begin() + j + 1);
            if (is_sorted(temp_arr)) {
                return "Yes";
            }
        }
    }
    return "No";
}

// int main() {
//     vector&lt;int&gt; arr1 = {1, 2, 5, 4, 3};
//     cout &lt&lt check_reversal(arr1) &lt&lt endl; // Output: Yes

//     vector&lt;int&gt; arr2 = {1, 3, 2};
//     cout &lt&lt check_reversal(arr2) &lt&lt endl; // Output: Yes

//     vector&lt;int&gt; arr3 = {1, 2, 3, 4, 5};
//     cout &lt&lt check_reversal(arr3) &lt&lt endl; // Output: Yes

//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(n^3), where n is the size of the array.  The nested loops to select sub-arrays are O(n^2) and reversing and checking for sorted takes O(n). | <b>Space Complexity:</b> O(n) because a copy of the array is created in each iteration to reverse it</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach</h5>
  <p>1.  Find the indices where the array is out of order (the start and end of the sub-array to reverse). 2.  Check if the sub-array can be reversed in a way that will sort the entire array. This involves checking if elements before and after the sub-array are in order with respect to the reversed sub-array.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool is_sorted(const vector&lt;int&gt;& arr) {
    for (size_t i = 0; i &lt arr.size() - 1; ++i) {
        if (arr[i] &gt arr[i + 1]) {
            return false;
        }
    }
    return true;
}

string check_reversal_optimized(vector&lt;int&gt; arr) {
    int n = arr.size();
    int start = -1, end = -1;

    // Find start and end indices of the unsorted portion
    for (int i = 0; i &lt n - 1; ++i) {
        if (arr[i] &gt arr[i + 1]) {
            start = i;
            break;
        }
    }

    if (start == -1) return "Yes"; // Already sorted

    for (int i = start; i &lt n - 1; ++i) {
        if (arr[i] &gt arr[i + 1]) {
            end = i + 1;
        } else {
            break;
        }
    }

    // Reverse the identified sub-array
    reverse(arr.begin() + start, arr.begin() + end + 1);

    // Check if the array is sorted after the reversal
    if (is_sorted(arr)) {
        return "Yes";
    } else {
        return "No";
    }
}

// int main() {
//     vector&lt;int&gt; arr1 = {1, 2, 5, 4, 3};
//     cout &lt&lt check_reversal_optimized(arr1) &lt&lt endl; // Output: Yes

//     vector&lt;int&gt; arr2 = {1, 3, 2};
//     cout &lt&lt check_reversal_optimized(arr2) &lt&lt endl; // Output: Yes

//     vector&lt;int&gt; arr3 = {1, 2, 3, 4, 5};
//     cout &lt&lt check_reversal_optimized(arr3) &lt&lt endl; // Output: Yes

//     vector&lt;int&gt; arr4 = {2, 1};
//     cout &lt&lt check_reversal_optimized(arr4) &lt&lt endl; // Output: Yes

//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the size of the array. It involves a constant number of passes through the array. | <b>Space Complexity:</b> O(1), as it uses a constant amount of extra space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[1, 2, 5, 4, 3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Yes</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Reversing the sub-array [5, 4, 3] makes the array sorted: [1, 2, 3, 4, 5].</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[1, 3, 2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Yes</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Reversing the sub-array [3, 2] makes the array sorted: [1, 2, 3].</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[1, 2, 3, 4, 5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Yes</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The array is already sorted.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[2, 1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Yes</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Reversing the sub-array [2, 1] makes the array sorted [1, 2]</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[1, 2, 4, 5, 3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No sub-array reversal can sort this array.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The optimized solution's efficiency stems from identifying the potential sub-array to reverse and only performing that reversal, rather than testing all possible sub-arrays. Handling edge cases where the array is already sorted or is very short is crucial. The code efficiently uses standard library functions like `reverse` and `is_sorted` to simplify the logic.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/radix-sort/>Radix Sort</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Radix sort is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping keys by the individual digits which share the same significant position and value. It processes the digits of the numbers from least significant digit (LSD) to most significant digit (MSD).</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach would involve comparing each number with every other number to determine their correct sorted order.  This approach is inefficient for large datasets.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Brute-force approach is not suitable for Radix Sort, so we'll omit it.
// It would involve pairwise comparisons, leading to O(n^2) time complexity.
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) - Not suitable for this problem. | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Radix Sort (LSD)</h5>
  <p>Radix sort works by processing the input array digit by digit, starting from the least significant digit (LSD). For each digit, it uses a stable sorting algorithm (like counting sort) to sort the numbers based on that digit. This process is repeated for each digit, from LSD to MSD.  The stable sorting is crucial because it maintains the relative order of elements with the same digit value.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Function to get the digit at a specific place value
int get_digit(int num, int place)
{
    return (num / place) % 10;
}

// Function to perform counting sort for a specific digit
void counting_sort(vector&lt;int&gt;&amp; arr, int n, int place)
{
    vector&lt;int&gt; count(10, 0);
    vector&lt;int&gt; output(n);

    // Count the occurrences of each digit
    for (int i = 0; i &lt; n; i++)
    {
        count[get_digit(arr[i], place)]++;
    }

    // Calculate the cumulative counts
    for (int i = 1; i &lt; 10; i++)
    {
        count[i] += count[i - 1];
    }

    // Build the output array
    for (int i = n - 1; i &gt;= 0; i--)
    {
        output[count[get_digit(arr[i], place)] - 1] = arr[i];
        count[get_digit(arr[i], place)]--;
    }

    // Copy the sorted elements back to the original array
    for (int i = 0; i &lt; n; i++)
    {
        arr[i] = output[i];
    }
}

// Function to perform radix sort
void radix_sort(vector&lt;int&gt;&amp; arr, int n)
{
    // Find the maximum number to know the number of digits
    int max_num = *max_element(arr.begin(), arr.end());

    // Perform counting sort for each digit, starting from LSD
    for (int place = 1; max_num / place &gt; 0; place *= 10)
    {
        counting_sort(arr, n, place);
    }
}

// Example usage:
/*
int main()
{
    vector&lt;int&gt; arr = {170, 45, 75, 90, 802, 24, 2, 66};
    int n = arr.size();
    radix_sort(arr, n);
    for (int i = 0; i &lt; n; i++)
    {
        cout &lt;&lt; arr[i] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
    return 0;
}
*/</code></pre>
  <p><b>Time Complexity:</b> O(d * (n + k)), where n is the number of elements, d is the maximum number of digits in any element, and k is the range of possible digit values (typically 10 for decimal numbers). | <b>Space Complexity:</b> O(n + k)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr = {170, 45, 75, 90, 802, 24, 2, 66}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2 24 45 66 75 90 170 802</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The array is sorted using radix sort.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr = {1, 10, 7, 9, 5, 8, 2, 3}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 2 3 5 7 8 9 10</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The array is sorted using radix sort.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr = {111, 11, 1, 100, 10, 0}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0 1 10 11 100 111</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The array is sorted using radix sort.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Radix sort is efficient when the range of numbers is known, and the number of digits is relatively small. It is a stable sorting algorithm.  It is particularly useful for sorting integers. It is not an in-place sorting algorithm because it requires auxiliary space to store intermediate results during counting sort.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/a-product-array-puzzle/>A Product Array Puzzle</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an array arr[] of n integers, construct a product array prod[] of the same size.  prod[i] should be equal to the product of all the elements of arr[] except arr[i]. Solve this without using the division operator.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the array. For each element arr[i], calculate the product of all other elements by iterating through the array again. This product becomes prod[i].</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

vector&lt;long long&gt; productArrayBruteForce(vector&lt;long long&gt; arr, int n) {
    vector&lt;long long&gt; prod(n, 1);

    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (i != j) {
                prod[i] *= arr[j];
            }
        }
    }
    return prod;
}

// int main() {
//     vector&lt;long long&gt; arr = {1, 2, 3, 4, 5};
//     int n = arr.size();
//     vector&lt;long long&gt; result = productArrayBruteForce(arr, n);
//     for (long long val : result) {
//         cout &lt;&lt; val &lt;&lt; " ";
//     }
//     cout &lt;&lt; endl;
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach (Left and Right Product Arrays)</h5>
  <p>Calculate the product of all elements to the left of each element and all elements to the right of each element. Then, the product array at index i is the product of the left product and the right product at index i.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

vector&lt;long long&gt; productArrayOptimized(vector&lt;long long&gt; arr, int n) {
    vector&lt;long long&gt; prod(n, 1);
    vector&lt;long long&gt; left(n, 1);
    vector&lt;long long&gt; right(n, 1);

    // Calculate left products
    for (int i = 1; i &lt; n; i++) {
        left[i] = left[i - 1] * arr[i - 1];
    }

    // Calculate right products
    for (int i = n - 2; i &gt;= 0; i--) {
        right[i] = right[i + 1] * arr[i + 1];
    }

    // Calculate final product array
    for (int i = 0; i &lt; n; i++) {
        prod[i] = left[i] * right[i];
    }

    return prod;
}

// int main() {
//     vector&lt;long long&gt; arr = {1, 2, 3, 4, 5};
//     int n = arr.size();
//     vector&lt;long long&gt; result = productArrayOptimized(arr, n);
//     for (long long val : result) {
//         cout &lt;&lt; val &lt;&lt; " ";
//     }
//     cout &lt;&lt; endl;
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(n) | <b>Space Complexity:</b> O(n)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr[] = {1, 2, 3, 4, 5}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">120 60 40 30 24</td>
        <td style="border: 1px solid #ccc; padding: 6px;">prod[0] = 2*3*4*5 = 120
prod[1] = 1*3*4*5 = 60
prod[2] = 1*2*4*5 = 40
prod[3] = 1*2*3*5 = 30
prod[4] = 1*2*3*4 = 24</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr[] = {10, 3, 5, 6, 2}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">180 600 360 300 900</td>
        <td style="border: 1px solid #ccc; padding: 6px;">prod[0] = 3*5*6*2 = 180
prod[1] = 10*5*6*2 = 600
prod[2] = 10*3*6*2 = 360
prod[3] = 10*3*5*2 = 300
prod[4] = 10*3*5*6 = 900</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key is to avoid division. The optimized solution avoids nested loops and calculates products efficiently.  Edge case: handle zero elements in the array; zero will cause the entire product array to be zero in most approaches, except the index where zero element exist.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/make-array-elements-equal-minimum-cost/>Make Array Elements Equal With Minimum Cost</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an array of integers `arr[]` and two integers `x` and `y`. The task is to make all the elements of the array equal. You can perform the following operations:

1.  Increment any element by 1, cost = `x`
2.  Decrement any element by 1, cost = `y`

Find the minimum cost to make all elements of the array equal.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible target values (the values that all elements could be changed to). For each target value, calculate the cost to change all elements to that target by summing the absolute difference between each element and the target, multiplied by the respective cost (`x` for increment and `y` for decrement). Keep track of the minimum cost found.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int minCostToMakeElementEqualBruteForce(vector&lt;int&gt;&amp; arr, int x, int y) {
    int minVal = *min_element(arr.begin(), arr.end());
    int maxVal = *max_element(arr.begin(), arr.end());
    int minCost = INT_MAX;

    for (int target = minVal; target &lt;= maxVal; ++target) {
        int currentCost = 0;
        for (int val : arr) {
            int diff = abs(val - target);
            currentCost += (val &lt; target) ? (diff * x) : (diff * y);
        }
        minCost = min(minCost, currentCost);
    }

    return minCost;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n * (max(arr) - min(arr))), where n is the size of the array.  We iterate through all elements for each possible target value. | <b>Space Complexity:</b> O(1) - constant extra space.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized: Using Median</h5>
  <p>The key insight is that the optimal target value is the median of the array. If we pick any value other than the median, we can always find a direction(increment/decrement) to reduce cost. If the median is not unique, any value between the two middle values will result in the minimal cost.  Calculate the cost by iterating over the array, computing the differences between each element and the median, and multiplying by the respective increment/decrement cost.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int minCostToMakeElementEqualOptimized(vector&lt;int&gt;&amp; arr, int x, int y) {
    sort(arr.begin(), arr.end());
    int n = arr.size();
    int median;
    if (n % 2 == 0) {
        median = arr[n / 2 - 1]; // Or arr[n/2], both yield the same result since any number between them is acceptable
    } else {
        median = arr[n / 2];
    }

    int minCost = 0;
    for (int val : arr) {
        int diff = abs(val - median);
        minCost += (val &lt; median) ? (diff * x) : (diff * y);
    }

    return minCost;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log n) due to sorting the array. The iteration after sorting is O(n). | <b>Space Complexity:</b> O(1) - constant extra space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr = [1, 2, 3], x = 2, y = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Target = 2.  Cost = (2-1)*2 + (2-2)*3 + (3-2)*3 = 2 + 0 + 3 = 5.  Target = 1: (1-1) *3 + (2-1)*2 + (3-1)*2= 0 + 2 + 4 = 6. Target =3: (3-1)*2 + (3-2)*3 + (3-3)*3 = 4 + 3 + 0 = 7. Consider the median (2). Cost = (2-1) *2 + (2-2) *3 + (3-2)*3 = 5. Median 2 is optimal and results in the least cost, but in other test cases, incrementing or decrementing would depend on which option is more cost effective. This one is quite simple, and the test case can be changed to observe cost differences between x and y values.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr = [1, 5, 2, 4], x = 2, y = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Median = 2 or 4. If median = 2. cost = (2-1)*2 + (5-2)*1 + (2-2)*0 + (4-2)*1 = 2+3+0+2=7. If median = 3, cost = (3-1)*2 + (5-3)*1 + (3-2)*1 + (4-3)*1 = 4+2+1+1=8. Median = 3 is not optimal. Consider median = 3: cost = (3-1)*2 + (5-3)*1 + (3-2)*1 + (4-3)*1 = 8. If median = 2, cost = (2-1)*2+(5-2)*1+(2-2)*1+(4-2)*1 = 2+3+0+2 = 7. If median = 4, cost = (4-1)*2+(5-4)*1+(4-2)*1+(4-4)*0= 6+1+2+0=9.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr = [1, 1000000000], x = 1, y = 1000000000</td>
        <td style="border: 1px solid #ccc; padding: 6px;">999999999</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Target = 1. Cost = 0 + 999999999*1000000000. Target = 1000000000: cost= 999999999 * 1 + 0 = 999999999. Here, as x &lt; y, therefore incrementing will be more beneficial.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The crucial observation is the relationship between the median and the minimum cost. Also, consider the edge case when `x` and `y` have vastly different values.  Sorting the array is essential for finding the median efficiently and to use in calculations based on whether increment/decrement would cost less.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/find-peak-element/>Find Peak Element</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an integer array `nums`, find a peak element, and return its index. A peak element is an element that is strictly greater than its neighbors.

You may assume that `nums[-1] = nums[n] = -‚àû`. In other words, an element is always considered a peak if it is at the boundaries (the first or the last element) of the array. 

You must write an algorithm that runs in O(log n) time.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the array and check if each element is a peak. An element is a peak if it's greater than both its neighbors. Special handling is required for the first and last elements.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int findPeakElement_brute_force(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    if (n == 1) return 0;

    if (nums[0] > nums[1]) return 0;
    if (nums[n - 1] > nums[n - 2]) return n - 1;

    for (int i = 1; i &lt; n - 1; ++i) {
        if (nums[i] > nums[i - 1] &amp;&amp; nums[i] > nums[i + 1]) {
            return i;
        }
    }
    return -1; // Should not reach here as there is guaranteed peak
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Binary Search</h5>
  <p>Utilize binary search. Compare the middle element with its neighbors. If the middle element is less than its right neighbor, the peak must be in the right half. If the middle element is less than its left neighbor, the peak must be in the left half. Otherwise, the middle element itself is a peak.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int findPeakElement_binary_search(vector&lt;int&gt;&amp; nums) {
    int left = 0, right = nums.size() - 1;

    while (left &lt; right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] &lt; nums[mid + 1]) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}
</code></pre>
  <p><b>Time Complexity:</b> O(log n) | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,2,3,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3 is a peak element and your function should return the index number 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,2,1,3,5,6,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 or 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Your function can return either index number 1 or 5, whose corresponding values are 2 and 6 respectively.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The only element is a peak.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [5,4,3,2,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5 is a peak at index 0.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to solving this problem efficiently is recognizing that the problem constraints allow for a binary search approach. The condition `nums[-1] = nums[n] = -‚àû` guarantees that a peak always exists. If an element is not a peak, we can always determine which side (left or right) contains a peak by comparing it to its neighbor.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/allocate-minimum-number-of-pages0937/1>Allocate minimum number of pages</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>You are given an array of integers `A` of size `N` and an integer `K`. You have to divide the array into `K` contiguous subarrays such that the maximum sum of elements in a subarray is minimized. Find the minimum possible maximum sum of a subarray.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves trying all possible combinations of dividing the array into `K` subarrays. For each combination, calculate the maximum sum of elements in any subarray and find the minimum among all such maximum sums. This approach is highly inefficient because it explores a vast search space.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Function to calculate the maximum sum of subarrays for a given division
int calculateMaxSum(const vector&lt;int&gt;&amp; arr, int k, int n) {
    int maxSum = INT_MAX;
    for (int i = 0; i &lt; (1 &lt;&lt; (n - 1)); ++i) {
        int currentSum = 0;
        int maxCurrentSum = 0;
        int count = 1;
        for (int j = 0; j &lt; n; ++j) {
            currentSum += arr[j];
            if (j &lt; n - 1 &amp;&amp; (i &amp; (1 &lt;&lt; j))) {
                maxCurrentSum = max(maxCurrentSum, currentSum);
                currentSum = 0;
                count++;
            }
        }
        maxCurrentSum = max(maxCurrentSum, currentSum);
        if (count == k) {
            maxSum = min(maxSum, maxCurrentSum);
        }
        
    }
    return maxSum;
}

// Function to allocate pages - Brute force approach - inefficient
int allocatePagesBruteForce(const vector&lt;int&gt;&amp; arr, int k) {
    int n = arr.size();
    if (k &gt; n) return -1; // Impossible to allocate
    int maxSum = INT_MAX;  
    for(int i = 0; i &lt; (1 &lt;&lt; (n-1)); ++i) {
        int currentSum = 0;
        int maxCurrent = 0;
        int count = 1;
        for(int j = 0; j &lt; n; ++j) {
            currentSum += arr[j];
            if(j &lt; n-1 &amp;&amp; (i &amp; (1&lt;&lt;j))) {
                maxCurrent = max(maxCurrent, currentSum);
                currentSum = 0;
                count++;
            }
        }
        maxCurrent = max(maxCurrent, currentSum);
        if (count == k) {
            maxSum = min(maxSum, maxCurrent);
        }
    }
    return maxSum;
}

</code></pre>
  <p><b>Time Complexity:</b> O(N * 2^N) | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Binary Search</h5>
  <p>The optimized approach uses binary search. The search space for the minimum possible maximum sum is from the maximum element in the array (lower bound) to the sum of all elements (upper bound). For each potential maximum sum (mid value), check if it's possible to divide the array into K subarrays such that the sum of each subarray doesn't exceed mid. If it's possible, try a smaller mid; otherwise, try a larger mid. This uses a helper function isPossible() to check if a given maximum sum is achievable for the specified number of students.  </p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Function to check if it's possible to allocate pages with a maximum sum
bool isPossible(const vector&lt;int&gt;&amp; arr, int k, int maxSum) {
    int students = 1; // Start with one student
    int currentSum = 0;
    for (int i = 0; i &lt; arr.size(); ++i) {
        if (arr[i] &gt; maxSum) {
            return false; // Single book exceeds max sum
        }
        if (currentSum + arr[i] &lt;= maxSum) {
            currentSum += arr[i];
        } else {
            students++;
            currentSum = arr[i];
        }
    }
    return students &lt;= k;
}

// Function to allocate pages using binary search - Optimized
int allocatePages(const vector&lt;int&gt;&amp; arr, int k) {
    int n = arr.size();
    if (k &gt; n) return -1; // Impossible to allocate

    int low = *max_element(arr.begin(), arr.end()); // Min possible max sum
    int high = accumulate(arr.begin(), arr.end(), 0);  // Max possible max sum
    int result = high; // Initialize result with max possible sum

    while (low &lt;= high) {
        int mid = low + (high - low) / 2;
        if (isPossible(arr, k, mid)) {
            result = mid;   // Found a possible solution, try to minimize
            high = mid - 1;  // Try smaller max sum
        } else {
            low = mid + 1;  // Need a larger max sum
        }
    }

    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N * log(Sum of array elements - Max element)) | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr = {10, 20, 30, 40}, k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">60</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Divide the array into two subarrays: {10, 20, 30} and {40}. The maximum sum of any subarray is 60.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr = {10, 20, 30, 40}, k = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">40</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Divide the array into three subarrays: {10}, {20}, and {30, 40}. The maximum sum of any subarray is 40.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr = {1, 2, 3, 4, 5}, k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">9</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Divide the array into two subarrays: {1, 2, 3, 4} and {5}. The maximum sum of any subarray is 9.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  **Edge Case:** If the number of students (k) is greater than the number of books (n), it is not possible to allocate the books, return -1.
2.  **Binary Search Range:** The lower bound of the binary search is the maximum element in the array (each student at least has to read this much pages) and upper bound is the sum of all elements. 
3.  **isPossible() function:** This helper function is crucial for the binary search approach; it efficiently determines if a given maximum sum is achievable with the specified number of students/subarrays. 
4.  **Contiguous Subarrays:** The subarrays must be contiguous (elements must be in their original order).</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/>Minimum number of swaps required to sort an array</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given an array of distinct elements, find the minimum number of swaps required to sort the array in ascending order.  A swap involves exchanging the positions of two elements in the array.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Generate all permutations of the array and count the swaps needed for each permutation to reach the sorted array. Return the minimum number of swaps among all permutations. This is highly inefficient.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int countSwaps(vector&lt;int&gt; arr) {
    int n = arr.size();
    vector&lt;int&gt; sortedArr = arr;
    sort(sortedArr.begin(), sortedArr.end());
    int swaps = 0;
    for (int i = 0; i &lt; n; i++) {
        if (arr[i] != sortedArr[i]) {
            for (int j = i + 1; j &lt; n; j++) {
                if (arr[j] == sortedArr[i]) {
                    swap(arr[i], arr[j]);
                    swaps++;
                    break;
                }
            }
        }
    }
    return swaps;
}

int main() {
    vector&lt;int&gt; arr = {4, 3, 2, 1};
    cout &lt;&lt; "Minimum swaps: " &lt;&lt; countSwaps(arr) &lt;&lt; endl;
    return 0;
}</code></pre>
  <p><b>Time Complexity:</b> O(n! * n) - Generating all permutations takes O(n!) time and for each permutation we perform O(n) operations | <b>Space Complexity:</b> O(n) - To store the sorted array, and could be O(n!) in some permutation generation techniques</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Cycle Detection</h5>
  <p>1. Create an auxiliary array and store the original array with their indexes.
2. Sort the auxiliary array with respect to array values. The sorted array will help you determine the correct positions of the elements.
3. Iterate the auxiliary array. For each element, check if it's in its correct position.
4. If the element is not in its correct position, swap it with the correct position element, increase swap count, and also correct the index of other elements in the cycle.
5. Repeat steps 3 and 4 until all elements are in their correct position.</p>
  <pre><code class="language-python">#include &lt;bits/stdc++.h&gt;
using namespace std;

int minSwaps(vector&lt;int&gt;&amp; arr) {
    int n = arr.size();
    vector&lt;pair&lt;int, int&gt;&gt; aux(n);
    for (int i = 0; i &lt; n; i++) {
        aux[i] = {arr[i], i};
    }
    sort(aux.begin(), aux.end());
    int swaps = 0;
    vector&lt;bool&gt; visited(n, false);
    for (int i = 0; i &lt; n; i++) {
        if (visited[i] || aux[i].second == i) {
            continue;
        }
        int cycle_size = 0;
        int j = i;
        while (!visited[j]) {
            visited[j] = true;
            j = aux[j].second;
            cycle_size++;
        }
        if (cycle_size &gt; 0) {
            swaps += (cycle_size - 1);
        }
    }
    return swaps;
}

int main() {
    vector&lt;int&gt; arr = {4, 3, 2, 1};
    cout &lt;&lt; "Minimum swaps: " &lt;&lt; minSwaps(arr) &lt;&lt; endl;
    return 0;
}</code></pre>
  <p><b>Time Complexity:</b> O(n log n) - for sorting + O(n) for cycle detection | <b>Space Complexity:</b> O(n)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr = {4, 3, 2, 1}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">We can reach the sorted array {1, 2, 3, 4} by performing 4 swaps.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr = {1, 5, 4, 3, 2}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Swapping 5 and 2, and then 4 and 3 sorts the array.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr = {10, 19, 6, 3, 5}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Swapping 19 and 3, and then 10 and 5 sorts the array.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. The Cycle Detection approach is efficient because it finds cycles in the permutation created by the array and efficiently sorts them by swaps.
2. Elements are assumed to be distinct. If there are duplicates, the cycle detection approach needs to be adjusted to consider repeated elements and their positions.
3. The auxiliary array is critical for preserving the original indices while sorting the elements.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.spoj.com/problems/AGGRCOW/>AGGRCOW - Aggressive cows</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>The problem involves placing *C* aggressive cows in *N* stalls located at different positions on a line. The goal is to maximize the minimum distance between any two cows. Given the positions of the stalls and the number of cows, the task is to find the largest minimum distance that can be maintained between the cows.

Input:
- The first line contains the number of test cases *T*. 
- For each test case:
  - The first line contains two integers *N* and *C*, where *N* is the number of stalls and *C* is the number of cows.
  - The next *N* lines contain the positions of the stalls.

Output:
- For each test case, print the largest minimum distance that can be achieved.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach would involve trying all possible combinations of cow placements and calculating the minimum distance between the cows for each combination. This would be extremely inefficient due to the exponential number of combinations.</p>
  <pre><code class="language-python">#include &ltiostream&gt
#include &ltvector&gt
#include &ltalgorithm&gt

using namespace std;

// This is a conceptual representation of a brute-force solution.  It's not efficient and would TLE.
// A complete brute-force solution would be very complex and not practical for this problem.

// int solve_brute_force(vector&lt;int&gt;&amp; stalls, int cows) {
//     // ... (Generate all combinations of cow placements and check the minimum distance)
//     return 0; // Replace with the largest min distance found
// }

int main() {
    int t;
    cin &gt&gt t;
    while (t--) {
        int n, c;
        cin &gt&gt n &gt&gt c;
        vector&lt;int&gt; stalls(n);
        for (int i = 0; i &lt n; ++i) {
            cin &gt&gt stalls[i];
        }
        sort(stalls.begin(), stalls.end());

        //Conceptual Brute force.
        cout &lt&lt "Brute force solution is too complex and inefficient for this problem." &lt&lt endl;
        // int result = solve_brute_force(stalls, c);
        // cout &lt&lt result &lt&lt endl;
    }
    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N^C * N) where N is number of stalls and C is number of cows. (Very Inefficient - would Time Limit Exceed) | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Binary Search</h5>
  <p>This approach uses binary search to find the largest minimum distance. The search space is from 1 (the minimum possible distance) to the difference between the largest and smallest stall positions (the maximum possible distance). For each potential minimum distance, we check if it's possible to place all cows with that minimum distance. This check involves iterating through the sorted stall positions and placing cows as far apart as possible. If we can place all the cows with a certain distance, we increase the distance (move the left pointer in binary search); otherwise, we decrease the distance (move the right pointer).</p>
  <pre><code class="language-python">#include &ltiostream&gt
#include &ltvector&gt
#include &ltalgorithm&gt

using namespace std;

bool can_place_cows(vector&lt;int&gt;&amp; stalls, int cows, int min_dist) {
    int placed_cows = 1;
    int last_pos = stalls[0];
    for (int i = 1; i &lt stalls.size(); ++i) {
        if (stalls[i] - last_pos &gt= min_dist) {
            placed_cows++;
            last_pos = stalls[i];
        }
    }
    return placed_cows &gt= cows;
}

int solve() {
    int n, c;
    cin &gt&gt n &gt&gt c;
    vector&lt;int&gt; stalls(n);
    for (int i = 0; i &lt n; ++i) {
        cin &gt&gt stalls[i];
    }
    sort(stalls.begin(), stalls.end());

    int left = 1;  // Minimum possible distance
    int right = stalls[n - 1] - stalls[0]; // Maximum possible distance
    int result = 0;

    while (left &lt= right) {
        int mid = left + (right - left) / 2;
        if (can_place_cows(stalls, c, mid)) {
            result = mid;
            left = mid + 1; // try for higher distance
        } else {
            right = mid - 1; // Decrease distance to fit the cows.
        }
    }
    return result;
}

int main() {
    int t;
    cin &gt&gt t;
    while (t--) {
        cout &lt&lt solve() &lt&lt endl;
    }
    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N log(max_dist - min_dist)), where N is the number of stalls. Sorting takes O(N log N) and Binary Search takes O(log(range)). can_place_cows takes O(N). | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1
5 3
1
2
4
8
9</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The stalls are at positions 1, 2, 4, 8, and 9.  We need to place 3 cows.
The optimal placement is at stalls 1, 4, and 8 (or 1, 4, 9) , giving a minimum distance of 3.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1
5 2
10
1
2
7
5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">9</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Stalls at 1, 2, 5, 7, 10, and 2 cows.
Optimal placements: 1 and 10, with distance 9.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1
6 4
10
1
2
7
5
8</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Stalls at 1, 2, 5, 7, 8, and 10.
Optimal placement: 1, 5, 7, and 10, the minimum distance would be 2.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The binary search approach is critical for solving this problem efficiently. It efficiently narrows down the search space for the optimal minimum distance. Make sure to handle edge cases such as having only one or two stalls, or the number of cows being equal to the number of stalls. The stalls need to be sorted before the algorithm starts.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/search-in-rotated-sorted-array/>Search in Rotated Sorted Array</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given an integer array `nums` of unique elements sorted in ascending order, and an integer `target`. The array `nums` has been rotated at an unknown pivot index `k` (0 &lt;= k &lt; nums.length) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (0-indexed). Return the index of `target` if it is in `nums`, or -1 if it is not in `nums`. You must write an algorithm with `O(log n)` runtime complexity.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the array and compare each element with the target. Return the index if a match is found, otherwise return -1.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int bruteForceSearch(vector&lt;int&gt;&amp; nums, int target) {
    for (int i = 0; i &lt; nums.size(); ++i) {
        if (nums[i] == target) {
            return i;
        }
    }
    return -1;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Binary Search with Modification</h5>
  <p>Adapt the binary search algorithm to handle the rotation.  The key is to determine which half of the array (left or right) is sorted. Then, check if the target falls within the sorted half. If it does, search within that half. Otherwise, search in the other half.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int searchRotatedSortedArray(vector&lt;int&gt;&amp; nums, int target) {
    int left = 0, right = nums.size() - 1;
    while (left &lt;= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        }

        // Check if the left half is sorted
        if (nums[left] &lt;= nums[mid]) {
            if (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) {
                // Target is in the left sorted half
                right = mid - 1;
            } else {
                // Target is in the right half
                left = mid + 1;
            }
        } else {
            // Right half is sorted
            if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) {
                // Target is in the right sorted half
                left = mid + 1;
            } else {
                // Target is in the left half
                right = mid - 1;
            }
        }
    }
    return -1;
}
</code></pre>
  <p><b>Time Complexity:</b> O(log n) | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [4,5,6,7,0,1,2], target = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The target is found at index 4.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [4,5,6,7,0,1,2], target = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The target is not found in the array.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1], target = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The target is not found.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,3], target = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The target is found at index 1.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The most important edge case is handling the rotated array correctly. The key is to identify which portion of the array is sorted in each iteration of the binary search and adjust the search space accordingly. Also, consider the case where the array is not rotated at all.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/count-of-smaller-numbers-after-self/>Count of Smaller Numbers After Self</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given an integer array `nums`, return an array `counts` where `counts[i]` is the number of smaller elements to the right of `nums[i]`.  In other words, for each element `nums[i]`, you need to count how many elements `nums[j]` satisfy `j > i` and `nums[j] < nums[i]`.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the array. For each element, iterate through the remaining elements to its right and count the smaller numbers.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

vector&lt;int&gt; countSmallerBruteForce(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    vector&lt;int&gt; counts(n, 0);
    for (int i = 0; i &lt; n; ++i) {
        for (int j = i + 1; j &lt; n; ++j) {
            if (nums[j] &lt; nums[i]) {
                counts[i]++;
            }
        }
    }
    return counts;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2), where n is the number of elements in the input array.  Nested loops are used. | <b>Space Complexity:</b> O(n), to store the output array 'counts'.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Merge Sort with Modifications</h5>
  <p>Use merge sort to sort a modified array that contains both the original numbers and their original indices.  During the merge step, when merging the right sub-array into the left sub-array, if an element from the right sub-array is smaller than an element from the left sub-array, increment the count for the element in the left sub-array. This leverages the sorted nature of merge sort to efficiently count smaller elements to the right. This approach avoids the need to compare with all right elements like the naive solution.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

void merge(vector&lt;pair&lt;int, int&gt;&gt;&amp; nums, vector&lt;int&gt;&amp; counts, int left, int mid, int right) {
    vector&lt;pair&lt;int, int&gt;&gt; temp(right - left + 1);
    int i = left, j = mid + 1, k = 0, smaller_count = 0;

    while (i &lt;= mid &amp;&amp; j &lt;= right) {
        if (nums[i].first &gt; nums[j].first) {
            smaller_count++;
            temp[k++] = nums[j++];
        } else {
            counts[nums[i].second] += smaller_count;
            temp[k++] = nums[i++];
        }
    }

    while (i &lt;= mid) {
        counts[nums[i].second] += smaller_count;
        temp[k++] = nums[i++];
    }

    while (j &lt;= right) {
        temp[k++] = nums[j++];
    }

    for (int l = 0; l &lt; (right - left + 1); ++l) {
        nums[left + l] = temp[l];
    }
}

void mergeSort(vector&lt;pair&lt;int, int&gt;&gt;&amp; nums, vector&lt;int&gt;&amp; counts, int left, int right) {
    if (left &lt; right) {
        int mid = left + (right - left) / 2;
        mergeSort(nums, counts, left, mid);
        mergeSort(nums, counts, mid + 1, right);
        merge(nums, counts, left, mid, right);
    }
}

vector&lt;int&gt; countSmallerMergeSort(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    vector&lt;int&gt; counts(n, 0);
    vector&lt;pair&lt;int, int&gt;&gt; indexed_nums(n);

    for (int i = 0; i &lt; n; ++i) {
        indexed_nums[i] = {nums[i], i};
    }

    mergeSort(indexed_nums, counts, 0, n - 1);

    return counts;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log n), where n is the number of elements. Merge sort is O(n log n). | <b>Space Complexity:</b> O(n), for the temporary arrays used in merge sort, and for storing `indexed_nums` and the `counts` array.</p>
  <h5>‚û§ Binary Search Tree (BST)</h5>
  <p>Iterate through the array from right to left. For each number, insert it into a Binary Search Tree.  As we insert, keep track of the number of nodes smaller than the current node. This is because when inserting into a BST, you implicitly know the number of nodes that are smaller than the current node if you keep track of how many nodes are in the left subtree during each insertion. Nodes in the right subtrees are larger than the current node, and thus contribute 0 to count. This can be optimized for duplicate numbers by tracking the count of duplicates.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct TreeNode {
    int val;
    int count;
    int leftCount;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), count(1), leftCount(0), left(nullptr), right(nullptr) {}
};

int insert(TreeNode*&amp; root, int val) {
    int smallerCount = 0;
    TreeNode* curr = root;
    while (curr) {
        if (val &gt; curr-&gt;val) {
            smallerCount += curr-&gt;count + curr-&gt;leftCount;
            if (!curr-&gt;right) {
                curr-&gt;right = new TreeNode(val);
                break;
            }
            curr = curr-&gt;right;
        } else if (val &lt; curr-&gt;val) {
            curr-&gt;leftCount++;
            if (!curr-&gt;left) {
                curr-&gt;left = new TreeNode(val);
                break;
            }
            curr = curr-&gt;left;
        } else {
            curr-&gt;count++;
            break;
        }
    }
    return smallerCount;
}

vector&lt;int&gt; countSmallerBST(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    vector&lt;int&gt; counts(n, 0);
    TreeNode* root = nullptr;
    for (int i = n - 1; i &gt;= 0; --i) {
        counts[i] = insert(root, nums[i]);
    }
    return counts;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log n) on average, O(n^2) in worst-case (when the BST degenerates to a linked list, e.g., when the input is sorted). | <b>Space Complexity:</b> O(n) for the `counts` array and the BST (in the average case; can be O(n) in the worst case when the BST is skewed).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [5,2,2,6,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[2,1,1,1,0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">To the right of 5 there are 2 smaller numbers (2 and 2).
To the right of 2 there is 1 smaller number (1).
To the right of the second 2 there is 1 smaller number (1).
To the right of 6 there is 1 smaller number (1).
To the right of 1 there is 0 smaller number (0).</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [-1,-1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[0,0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There are no numbers smaller to the right of -1.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [5,2,2,6,1, 8, 10, 1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[4, 1, 1, 2, 0, 1, 1, 0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Illustrates various scenarios. For instance, for the first '5', there are 4 smaller numbers to its right (2, 2, 1, and the other 1).</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases:  
- Empty input array: Return an empty array.
- All elements are the same: The count will be all zeros except for the last element which would always be 0.  
- Duplicates:  Handle the duplicates properly. The BST approach requires extra thought to deal with duplicates. The merge sort version deals with them naturally.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/split-array-largest-sum/>Split Array Largest Sum</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given an array of integers `nums` and an integer `k`, split the array into `k` non-empty subarrays such that the largest sum of any subarray is minimized. Return the minimized largest sum. A subarray is a contiguous part of the array.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach tries all possible ways to split the array into `k` subarrays.  For each possible split, it calculates the largest sum of any subarray and then minimizes this value across all splits. This involves generating all possible combinations of splitting points within the array.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int calculateLargestSum(const vector& nums, const vector& splits) {
    int largestSum = 0;
    int start = 0;
    for (int split : splits) {
        int currentSum = 0;
        for (int i = start; i &lt= split; ++i) {
            currentSum += nums[i];
        }
        largestSum = max(largestSum, currentSum);
        start = split + 1;
    }
    // Handle the last subarray
    int currentSum = 0;
    for (int i = start; i &lt nums.size(); ++i) {
        currentSum += nums[i];
    }
    largestSum = max(largestSum, currentSum);
    return largestSum;
}

int splitArrayBruteForce(vector& nums, int k) {
    int n = nums.size();
    if (k == 1) {
        int sum = 0;
        for (int num : nums) sum += num;
        return sum;
    }

    if (k == n) {
        int max_val = 0;
        for (int num : nums) max_val = max(max_val, num);
        return max_val;
    }

    int minLargestSum = INT_MAX;

    // Generate all possible splits (inefficient)
    for (int i = 0; i &lt (1 &lt&lt (n - 1)); ++i) {
        vector&ltint&gt splits;
        int count = 0;
        for (int j = 0; j &lt n - 1; ++j) {
            if ((i & (1 &lt&lt j)) != 0) {
                splits.push_back(j);
                count++;
            }
        }
        if (count == k-1) {
            int largestSum = calculateLargestSum(nums, splits);
            minLargestSum = min(minLargestSum, largestSum);
        }
    }

    return minLargestSum;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^(k-1) * n). For each of the n^(k-1) splits, we iterate through the array to calculate the subarray sums, which takes O(n) time. | <b>Space Complexity:</b> O(k) to store split indices, in worst case. Also O(n) for recursion stack if it's a recursive implementation. Thus, O(n) overall.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Binary Search with Greedy Approach</h5>
  <p>This approach uses binary search to find the minimized largest sum. The search space is between the maximum element in the array (the smallest possible largest sum) and the sum of all elements (the largest possible largest sum). For a given 'mid' (potential largest sum), we use a greedy approach to check if we can split the array into at most 'k' subarrays such that the sum of each subarray doesn't exceed 'mid'.  If we can, it means our 'mid' is too large, so we search for a smaller value. If not, it means 'mid' is too small, so we search for a larger value. The binary search continues until the left and right pointers converge to the optimal solution.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool canSplit(const vector& nums, int k, long long maxSum) {
    int subarrays = 1;
    long long currentSum = 0;
    for (int num : nums) {
        if (num &gt maxSum) {
            return false; // Single element exceeds maxSum
        }
        if (currentSum + num &lt= maxSum) {
            currentSum += num;
        } else {
            subarrays++;
            currentSum = num;
        }
    }
    return subarrays &lt= k;
}

int splitArrayOptimized(vector& nums, int k) {
    long long left = *max_element(nums.begin(), nums.end());
    long long right = accumulate(nums.begin(), nums.end(), 0LL);
    long long result = right;

    while (left &lt= right) {
        long long mid = left + (right - left) / 2;
        if (canSplit(nums, k, mid)) {
            result = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return (int)result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n * log(sum(nums) - max(nums))). Binary search takes O(log(range of possible sums)) time.  Inside the binary search, the 'canSplit' function takes O(n) time. | <b>Space Complexity:</b> O(1). Constant extra space is used.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [7,2,5,10,8], k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">18</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Split the array into [7,2,5] and [10,8], where the largest sum is 18.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,2,3,4,5], k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">9</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Split into [1,2,3,4] and [5] to minimize the largest sum (9).</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,4,4,4,4,4], k = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">21</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The entire array must be in a single subarray.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key insight for the optimized solution is to realize that the problem can be solved efficiently using binary search. The range of possible answers is well-defined, and the canSplit() function allows us to determine if a given potential solution is valid in O(n) time.</p>
</div>
<hr style="margin: 40px 0;">
<h2>Linked List</h2>
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/middle-of-the-linked-list/>Middle of the Linked List</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Traverse the linked list to find its length. Then, traverse the list again to the middle node (length / 2).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* middleNodeBruteForce(ListNode* head) {
    if (!head || !head->next) return head;
    int length = 0;
    ListNode* current = head;
    while (current) {
        length++;
        current = current->next;
    }
    int middleIndex = length / 2;
    current = head;
    for (int i = 0; i &lt middleIndex; ++i) {
        current = current->next;
    }
    return current;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) - two traversals of the linked list | <b>Space Complexity:</b> O(1) - constant extra space</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Fast and Slow Pointers</h5>
  <p>Use two pointers, slow and fast.  The slow pointer moves one step at a time, and the fast pointer moves two steps at a time. When the fast pointer reaches the end of the list, the slow pointer will be at the middle.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* middleNodeOptimized(ListNode* head) {
    if (!head || !head->next) return head;
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast &amp;&amp; fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) - one traversal of the linked list | <b>Space Complexity:</b> O(1) - constant extra space</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,2,3,4,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[3,4,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The middle node is the third node (index 2).</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,2,3,4,5,6]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[4,5,6]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Since the list has two middle nodes, we return the second one.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">If the list has only one node, return that node.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">If the list has two nodes, the second node is the middle node.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The fast/slow pointer approach is significantly more efficient than the brute-force method, as it requires only a single traversal of the linked list.  Handle edge cases like empty or single-node lists gracefully.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/linked-list-cycle/>Linked List Cycle</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given `head`, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. Note that `pos` is not passed as a parameter.

Return `true` if there is a cycle in the linked list. Otherwise, return `false`.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the linked list. For each node, check if it has been visited before. Use a hash table (unordered_set in C++) to store the visited nodes. If a node is encountered that is already in the hash table, it indicates a cycle. If the end of the list is reached (nullptr) without finding a cycle, return false.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

bool hasCycle_brute_force(ListNode *head) {
    unordered_set&lt;ListNode*&gt; visited;
    ListNode *current = head;

    while (current != NULL) {
        if (visited.count(current)) {
            return true; // Cycle detected
        }
        visited.insert(current);
        current = current-&gt;next;
    }

    return false; // No cycle found
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the linked list.  In the worst case, we visit all nodes. | <b>Space Complexity:</b> O(N), where N is the number of nodes in the linked list.  The hash table stores up to N nodes.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Floyd's Cycle Finding Algorithm (Tortoise and Hare)</h5>
  <p>Use two pointers: a slow pointer (tortoise) and a fast pointer (hare). The slow pointer moves one step at a time, and the fast pointer moves two steps at a time. If there's a cycle, the fast pointer will eventually catch up to the slow pointer. If the fast pointer reaches the end (nullptr), there's no cycle.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

bool hasCycle_optimized(ListNode *head) {
    if (!head || !head-&gt;next) {
        return false; // Empty or single-node list has no cycle
    }

    ListNode *slow = head;
    ListNode *fast = head;

    while (fast != NULL &amp;&amp; fast-&gt;next != NULL) {
        slow = slow-&gt;next;        // Move one step
        fast = fast-&gt;next-&gt;next;   // Move two steps

        if (slow == fast) {
            return true; // Cycle detected
        }
    }

    return false; // No cycle found
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the linked list.  In the worst-case scenario, the fast pointer traverses the list. | <b>Space Complexity:</b> O(1).  Constant space is used, as we only use two pointers.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [3,2,0,-4], pos = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There is a cycle in the list, where the tail connects to the second node.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,2], pos = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There is a cycle in the list, where the tail connects to the first node.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1], pos = -1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There is no cycle in the list.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The main edge case is an empty linked list or a list with only one node, which by definition cannot have a cycle. The `pos` variable in the problem description is only used for testing the problem; it is not actually used by any of the algorithms.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/>Convert Binary Number in a Linked List to Integer</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given the head of a singly linked list where each node has a value 0 or 1, convert the binary number represented by the linked list to an integer.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the linked list, constructing the binary string. Then, convert the binary string to an integer using the built-in `stoi` function.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

string linkedListToString(ListNode* head) {
    string s = "";
    ListNode* current = head;
    while (current != nullptr) {
        s += to_string(current-&gt;val);
        current = current-&gt;next;
    }
    return s;
}

int getDecimalValue_BruteForce(ListNode* head) {
    string binaryString = linkedListToString(head);
    return stoi(binaryString, nullptr, 2);
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the linked list. | <b>Space Complexity:</b> O(N) for storing the binary string.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Iterative with Bit Manipulation</h5>
  <p>Iterate through the linked list. In each step, multiply the current result by 2 and add the current node's value. This effectively shifts the bits to the left and adds the new bit.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

int getDecimalValue(ListNode* head) {
    int result = 0;
    ListNode* current = head;
    while (current != nullptr) {
        result = (result * 2) + current-&gt;val;
        current = current-&gt;next;
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the linked list. | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,0,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">(101) in base 2 = (5) in base 10</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">(0) in base 2 = (0) in base 10</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">(1) in base 2 = (1) in base 10</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The most efficient approach is to use bit manipulation.  Avoid converting to a string as it is less space-efficient.  Consider the edge cases where the list contains only 0s or only 1s.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/remove-duplicates-from-sorted-list/>Remove Duplicates from Sorted List</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the list and use a hash set to store encountered values. When a duplicate is found, remove the node. Since the list is sorted, we can also compare the current node's value with the next node's value.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* deleteDuplicates_brute_force(ListNode* head) {
    if (!head || !head->next) {
        return head;
    }

    ListNode* current = head;
    while (current && current->next) {
        if (current->val == current->next->val) {
            ListNode* duplicate = current->next;
            current->next = duplicate->next;
            delete duplicate;
        } else {
            current = current->next;
        }
    }
    return head;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the number of nodes in the linked list. | <b>Space Complexity:</b> O(1) - No extra space used apart from a few pointers.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Iterative Approach (Two Pointers)</h5>
  <p>Iterate through the linked list with two pointers, `current` and `next`. If `current->val` and `next->val` are the same, update `current->next` to point to `next->next`, effectively removing the duplicate. Otherwise, move `current` to `next`.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* deleteDuplicates_optimized(ListNode* head) {
    if (!head || !head->next) {
        return head;
    }

    ListNode* current = head;
    while (current && current->next) {
        if (current->val == current->next->val) {
            ListNode* next_node = current->next;
            current->next = next_node->next;
            delete next_node;
        } else {
            current = current->next;
        }
    }
    return head;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the number of nodes in the linked list. | <b>Space Complexity:</b> O(1) - No extra space is used.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The duplicate node with value 1 is removed.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,1,2,3,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Both duplicate nodes with values 1 and 3 are removed.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Empty list, return empty list.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Single node, return the same node</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The input list is guaranteed to be sorted.  The algorithm should not re-arrange the list, but should remove nodes. Edge cases to consider are empty list and a list with single node.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/sort-a-linked-list-of-0s-1s-or-2s/>Sort a linked list of 0s, 1s, or 2s</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given a linked list of integers where each node contains either 0, 1, or 2, sort the linked list in non-decreasing order. The challenge is to rearrange the nodes such that all 0s come first, followed by all 1s, and finally all 2s.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves traversing the linked list and counting the occurrences of 0s, 1s, and 2s. Then, the list is reconstructed by creating nodes with the counted number of 0s, followed by the counted number of 1s, and finally the counted number of 2s.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

Node* sortListBruteForce(Node* head) {
    if (!head || !head-&gt;next) return head; // Empty or single-node list

    int count0 = 0, count1 = 0, count2 = 0;
    Node* curr = head;

    // Count occurrences of 0, 1, and 2
    while (curr) {
        if (curr-&gt;data == 0) count0++;
        else if (curr-&gt;data == 1) count1++;
        else if (curr-&gt;data == 2) count2++;
        curr = curr-&gt;next;
    }

    // Reconstruct the list
    Node* newHead = nullptr, *tail = nullptr;

    // Add 0s
    for (int i = 0; i &lt count0; ++i) {
        Node* newNode = new Node(0);
        if (!newHead) {
            newHead = newNode;
            tail = newNode;
        } else {
            tail-&gt;next = newNode;
            tail = newNode;
        }
    }

    // Add 1s
    for (int i = 0; i &lt count1; ++i) {
        Node* newNode = new Node(1);
        if (!newHead) {
            newHead = newNode;
            tail = newNode;
        } else {
            tail-&gt;next = newNode;
            tail = newNode;
        }
    }

    // Add 2s
    for (int i = 0; i &lt count2; ++i) {
        Node* newNode = new Node(2);
        if (!newHead) {
            newHead = newNode;
            tail = newNode;
        } else {
            tail-&gt;next = newNode;
            tail = newNode;
        }
    }

    return newHead;
}

// Helper function to print the list
void printList(Node* head) {
    Node* curr = head;
    while (curr) {
        cout &lt&lt curr-&gt;data &lt&lt " ";
        curr = curr-&gt;next;
    }
    cout &lt&lt endl;
}

// Helper function to free the list
void freeList(Node* head) {
    Node* curr = head;
    while (curr) {
        Node* next = curr-&gt;next;
        delete curr;
        curr = next;
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) + O(n) = O(n), where n is the number of nodes in the list.  The first pass to count takes O(n) and the reconstruction takes O(n). | <b>Space Complexity:</b> O(1), as we are only using a constant amount of extra space to store the counts.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Counting and Replacement (One-Pass)</h5>
  <p>This approach involves traversing the linked list once and maintaining counts of 0s, 1s, and 2s. Then, in a second pass, the original list is modified. The nodes are traversed again, and based on the counts, the data values are replaced with 0s, 1s, or 2s. This optimized method only requires one full traversal for replacement.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

Node* sortListOptimized(Node* head) {
    if (!head || !head-&gt;next) return head;

    int count0 = 0, count1 = 0, count2 = 0;
    Node* curr = head;

    // Count occurrences of 0, 1, and 2
    while (curr) {
        if (curr-&gt;data == 0) count0++;
        else if (curr-&gt;data == 1) count1++;
        else if (curr-&gt;data == 2) count2++;
        curr = curr-&gt;next;
    }

    curr = head;
    // Replace data based on counts
    while (curr) {
        if (count0 &gt 0) {
            curr-&gt;data = 0;
            count0--;
        } else if (count1 &gt 0) {
            curr-&gt;data = 1;
            count1--;
        } else {
            curr-&gt;data = 2;
            count2--;
        }
        curr = curr-&gt;next;
    }

    return head;
}

// Helper function to print the list
void printList(Node* head) {
    Node* curr = head;
    while (curr) {
        cout &lt&lt curr-&gt;data &lt&lt " ";
        curr = curr-&gt;next;
    }
    cout &lt&lt endl;
}

// Helper function to free the list
void freeList(Node* head) {
    Node* curr = head;
    while (curr) {
        Node* next = curr-&gt;next;
        delete curr;
        curr = next;
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the number of nodes in the list.  We iterate twice through the list (once to count and once to replace), so the overall complexity remains linear. | <b>Space Complexity:</b> O(1), constant space for the counters.</p>
  <h5>‚û§ Three Pointers Approach</h5>
  <p>This approach uses three pointers, `zero`, `one`, and `two`, to build three separate lists: one for 0s, one for 1s, and one for 2s.  The list is traversed once and nodes are added to the respective lists.  Finally, the three lists are joined to form the sorted list. This also uses constant space.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

Node* sortListThreePointers(Node* head) {
    if (!head || !head-&gt;next) return head;

    Node* zeroHead = nullptr, *zeroTail = nullptr;
    Node* oneHead = nullptr, *oneTail = nullptr;
    Node* twoHead = nullptr, *twoTail = nullptr;

    Node* curr = head;
    while (curr) {
        if (curr-&gt;data == 0) {
            if (!zeroHead) {
                zeroHead = curr;
                zeroTail = curr;
            } else {
                zeroTail-&gt;next = curr;
                zeroTail = curr;
            }
        }
        else if (curr-&gt;data == 1) {
            if (!oneHead) {
                oneHead = curr;
                oneTail = curr;
            } else {
                oneTail-&gt;next = curr;
                oneTail = curr;
            }
        }
        else {
            if (!twoHead) {
                twoHead = curr;
                twoTail = curr;
            } else {
                twoTail-&gt;next = curr;
                twoTail = curr;
            }
        }
        curr = curr-&gt;next;
    }

    if (zeroTail) {
        if (oneHead) {
            zeroTail-&gt;next = oneHead;
        } else {
            zeroTail-&gt;next = twoHead;
            return zeroHead;
        }
    }
    if (oneTail) {
        oneTail-&gt;next = twoHead;
    }
    if (zeroHead) {
        if (oneHead || twoHead) {
          if (twoTail) twoTail-&gt;next = nullptr;
          return zeroHead;
        }
        else {
          return zeroHead;
        }
    }
    if (oneHead) {
      if(twoTail) twoTail-&gt;next = nullptr;
      return oneHead;
    }
    if(twoHead) {
      twoTail-&gt;next = nullptr;
      return twoHead;
    }
    return head;
}

// Helper function to print the list
void printList(Node* head) {
    Node* curr = head;
    while (curr) {
        cout &lt&lt curr-&gt;data &lt&lt " ";
        curr = curr-&gt;next;
    }
    cout &lt&lt endl;
}

// Helper function to free the list
void freeList(Node* head) {
    Node* curr = head;
    while (curr) {
        Node* next = curr-&gt;next;
        delete curr;
        curr = next;
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) - The list is traversed once. | <b>Space Complexity:</b> O(1) - Constant space is used.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1 -> 2 -> 0 -> 2 -> 1 -> 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0 -> 0 -> 1 -> 1 -> 2 -> 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The list is sorted such that all 0s come first, followed by 1s and then 2s.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">2 -> 2 -> 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2 -> 2 -> 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The list already contains only 2s, so no sorting is required.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">0 -> 1 -> 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0 -> 1 -> 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The list is already sorted</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The constraints specify that the list will only contain the values 0, 1, and 2. The key to optimization is to avoid nested loops and perform the sorting in a single pass or at most two passes through the list.  Handling empty lists and single-node lists are crucial edge cases.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/remove-linked-list-elements/>Remove Linked List Elements</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the linked list and remove nodes with the target value by changing the `next` pointers. This involves checking the head and subsequent nodes.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* removeElements_brute_force(ListNode* head, int val) {
    // Handle the case where the head itself needs to be removed.
    while (head != nullptr &amp;&amp; head-&gt;val == val) {
        ListNode* temp = head;
        head = head-&gt;next;
        delete temp;
    }

    // If the list is empty after removing head nodes, return nullptr.
    if (head == nullptr) {
        return nullptr;
    }

    ListNode* current = head;
    while (current-&gt;next != nullptr) {
        if (current-&gt;next-&gt;val == val) {
            ListNode* temp = current-&gt;next;
            current-&gt;next = current-&gt;next-&gt;next;
            delete temp;
        } else {
            current = current-&gt;next;
        }
    }

    return head;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the number of nodes in the linked list. We iterate through the list once. | <b>Space Complexity:</b> O(1). We only use constant extra space.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Iterative with Dummy Head</h5>
  <p>Use a dummy head node to simplify the removal of the head node. Iterate through the list, checking each node's next node. If the next node's value matches the target value, update the current node's next pointer to skip the node.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* removeElements_optimized(ListNode* head, int val) {
    ListNode* dummy = new ListNode(0); // Create a dummy node
    dummy-&gt;next = head;
    ListNode* current = dummy;

    while (current-&gt;next != nullptr) {
        if (current-&gt;next-&gt;val == val) {
            ListNode* temp = current-&gt;next;
            current-&gt;next = current-&gt;next-&gt;next;
            delete temp;
        } else {
            current = current-&gt;next;
        }
    }

    ListNode* newHead = dummy-&gt;next;
    delete dummy; // Clean up the dummy node
    return newHead;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the number of nodes in the linked list. | <b>Space Complexity:</b> O(1). We use a dummy node, which takes constant extra space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,2,6,3,4,5,6], val = 6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,3,4,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The nodes with value 6 are removed.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [], val = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The list is empty, so nothing is removed.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [7,7,7,7], val = 7</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">All nodes have value 7, so all are removed.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases to consider include: empty list, the head node(s) having the target value, and all nodes having the target value. Using a dummy head simplifies handling these cases.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/merge-two-sorted-lists/>Merge Two Sorted Lists</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given the heads of two sorted linked lists `list1` and `list2`, merge the two lists into one sorted list. The merged list should be made by splicing together the nodes of the first two lists and should be returned as the head of the merged linked list.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Create a new linked list. Iterate through both input lists, comparing nodes at each step. Append the smaller node to the merged list. Continue until both lists are exhausted. Convert the two linked list into array , sort them and again make a linked list</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* mergeTwoLists_BruteForce(ListNode* list1, ListNode* list2) {
    vector&lt;int&gt; values;
    ListNode* curr1 = list1;
    ListNode* curr2 = list2;

    // Extract values from list1
    while (curr1) {
        values.push_back(curr1-&gt;val);
        curr1 = curr1-&gt;next;
    }

    // Extract values from list2
    while (curr2) {
        values.push_back(curr2-&gt;val);
        curr2 = curr2-&gt;next;
    }

    // Sort the values
    sort(values.begin(), values.end());

    // Create the merged list
    ListNode* head = nullptr;
    ListNode* tail = nullptr;

    for (int val : values) {
        ListNode* newNode = new ListNode(val);
        if (!head) {
            head = newNode;
            tail = newNode;
        } else {
            tail-&gt;next = newNode;
            tail = newNode;
        }
    }

    return head;
}
</code></pre>
  <p><b>Time Complexity:</b> O( (m+n)log(m+n)), where m and n are the lengths of the two input lists.  This is due to converting the linked list into an array of size m+n, sorting takes O((m+n)log(m+n)) and forming the list from the sorted elements takes O(m+n). | <b>Space Complexity:</b> O(m+n) because of the extra space to store the elements of the two linked lists and extra space for the merged linked list.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Iterative Approach</h5>
  <p>Create a dummy head for the merged list. Use two pointers, one for each input list. Compare the values at the pointers. Append the smaller node to the merged list and advance the respective pointer. Repeat until one or both lists are exhausted.  Append the remaining nodes from the non-exhausted list (if any).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* mergeTwoLists_Iterative(ListNode* list1, ListNode* list2) {
    ListNode* dummyHead = new ListNode(); // Dummy node to simplify the logic
    ListNode* tail = dummyHead; // Pointer to the tail of the merged list

    while (list1 &amp;&amp; list2) {
        if (list1-&gt;val &lt;= list2-&gt;val) {
            tail-&gt;next = list1;
            list1 = list1-&gt;next;
        } else {
            tail-&gt;next = list2;
            list2 = list2-&gt;next;
        }
        tail = tail-&gt;next;
    }

    // If one list is exhausted, append the remaining nodes of the other list
    tail-&gt;next = (list1) ? list1 : list2;

    ListNode* mergedList = dummyHead-&gt;next; // Get the head of the merged list
    delete dummyHead; // Clean up the dummy node
    return mergedList;
}
</code></pre>
  <p><b>Time Complexity:</b> O(m+n), where m and n are the lengths of the two input lists. | <b>Space Complexity:</b> O(1). We are only using a constant amount of extra space.</p>
  <h5>‚û§ Recursive Approach</h5>
  <p>If either list is empty, return the other list. Otherwise, compare the values of the current nodes. Recursively merge the rest of the lists, attaching the smaller node to the result.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* mergeTwoLists_Recursive(ListNode* list1, ListNode* list2) {
    if (!list1) return list2;
    if (!list2) return list1;

    if (list1-&gt;val &lt;= list2-&gt;val) {
        list1-&gt;next = mergeTwoLists_Recursive(list1-&gt;next, list2);
        return list1;
    } else {
        list2-&gt;next = mergeTwoLists_Recursive(list1, list2-&gt;next);
        return list2;
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(m+n), where m and n are the lengths of the two input lists. | <b>Space Complexity:</b> O(m+n) due to the recursion call stack. In worst case if both linked list are having no common element.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">list1 = [1,2,4], list2 = [1,3,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,1,2,3,4,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Merged list: [1,1,2,3,4,4]</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">list1 = [], list2 = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Both lists are empty, so the merged list is empty.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">list1 = [], list2 = [0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">list1 is empty; merge list2</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The iterative approach is generally preferred for its lower space complexity.  Make sure to handle empty input lists correctly (edge case).</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/multiply-two-numbers-represented-linked-lists/>Multiply two numbers represented by linked lists</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given two numbers represented by linked lists, write a function that multiplies these two numbers and returns the product as a linked list. Each node in the linked list represents a digit, and the digits are stored in reverse order (least significant digit first).</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Convert both linked lists into integer numbers. Multiply these integers. Convert the product back into a linked list.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

long long linkedListToInt(Node* head) {
    long long num = 0;
    Node* curr = head;
    while (curr) {
        num = num * 10 + curr-&gt;data;
        curr = curr-&gt;next;
    }
    return num;
}

Node* intToLinkedList(long long num) {
    if (num == 0) return new Node(0);

    Node* head = nullptr;
    Node* tail = nullptr;
    if (num == 0) {
        return new Node(0);
    }
    while (num &gt; 0) {
        int digit = num % 10;
        Node* newNode = new Node(digit);
        if (!head) {
            head = newNode;
            tail = newNode;
        } else {
            tail-&gt;next = newNode;
            tail = newNode;
        }
        num /= 10;
    }
    return head;
}

Node* multiplyListsBruteForce(Node* head1, Node* head2) {
    long long num1 = linkedListToInt(head1);
    long long num2 = linkedListToInt(head2);
    long long product = num1 * num2;
    return intToLinkedList(product);
}
</code></pre>
  <p><b>Time Complexity:</b> O(M + N), where M and N are the lengths of the linked lists. This is due to the conversion of linked lists to integers and then back. | <b>Space Complexity:</b> O(M + N), for storing the integers and the product linked list</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach: Digit-by-Digit Multiplication with Carry</h5>
  <p>Implement the multiplication process similar to how we multiply numbers on paper. Multiply each digit of the first number with each digit of the second number. Maintain carry and handle the addition of the resulting products correctly to compute the final product represented as a linked list.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

Node* reverseList(Node* head) {
    Node* prev = nullptr;
    Node* curr = head;
    Node* next = nullptr;
    while (curr) {
        next = curr-&gt;next;
        curr-&gt;next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}

Node* addTwoLists(Node* head1, Node* head2) {
    Node* dummy = new Node(0);
    Node* tail = dummy;
    int carry = 0;

    while (head1 || head2 || carry) {
        int sum = carry;
        if (head1) {
            sum += head1-&gt;data;
            head1 = head1-&gt;next;
        }
        if (head2) {
            sum += head2-&gt;data;
            head2 = head2-&gt;next;
        }

        tail-&gt;next = new Node(sum % 10);
        tail = tail-&gt;next;
        carry = sum / 10;
    }

    Node* result = dummy-&gt;next;
    delete dummy;
    return result;
}

Node* multiplyLists(Node* head1, Node* head2) {
    if (!head1 || !head2) return nullptr;

    head1 = reverseList(head1);
    head2 = reverseList(head2);

    Node* result = nullptr;
    Node* currentResult = nullptr;

    Node* ptr2 = head2;
    int shift = 0;

    while (ptr2) {
        Node* tempResult = nullptr;
        Node* tempResultTail = nullptr;
        int carry = 0;

        Node* ptr1 = head1;
        for (int i = 0; i &lt; shift; ++i) {
            if (!tempResult) {
                tempResult = new Node(0);
                tempResultTail = tempResult;
            } else {
                tempResultTail-&gt;next = new Node(0);
                tempResultTail = tempResultTail-&gt;next;
            }
        }

        while (ptr1) {
            int product = (ptr1-&gt;data * ptr2-&gt;data) + carry;
            carry = product / 10;
            int digit = product % 10;

            if (!tempResult) {
                tempResult = new Node(digit);
                tempResultTail = tempResult;
            } else {
                tempResultTail-&gt;next = new Node(digit);
                tempResultTail = tempResultTail-&gt;next;
            }
            ptr1 = ptr1-&gt;next;
        }
        if (carry &gt; 0) {
            tempResultTail-&gt;next = new Node(carry);
        }

        if (result) {
            tempResult = reverseList(tempResult);
            result = addTwoLists(result, tempResult);
            tempResult = reverseList(tempResult);

        } else {
            result = tempResult;
        }

        ptr2 = ptr2-&gt;next;
        shift++;
    }
    if (result) {
        result = reverseList(result);
    }
    else {
        return new Node(0);
    }

    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(M * N), where M and N are the lengths of the input linked lists. Nested loops are used. | <b>Space Complexity:</b> O(M + N), mainly due to the resulting linked list</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">List1: 1-&gt;2-&gt;3 (representing 321) and List2: 4-&gt;5 (representing 54)</td>
        <td style="border: 1px solid #ccc; padding: 6px;">List: 5-&gt;4-&gt;6-&gt;3-&gt;1 (representing 17345)</td>
        <td style="border: 1px solid #ccc; padding: 6px;">321 * 54 = 17334. The output list represents the product.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">List1: 0 and List2: 1-&gt;2-&gt;3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">List: 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0 * 123 = 0</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">List1: 1-&gt;2-&gt;3 and List2: 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">List: 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">123 * 0 = 0</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The linked lists represent numbers in reverse order. 
2.  Handle edge cases, such as when one or both lists are empty (or represent zero). 
3. The approach avoids converting lists to integers to prevent integer overflow. 
4. The digit-by-digit approach is similar to the traditional multiplication algorithm, but implemented on linked lists.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/intersection-of-two-linked-lists/>Intersection of Two Linked Lists</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given the heads of two singly linked-lists `headA` and `headB`, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return `null`. For the purpose of this problem, an intersection is defined as the first node that both of the linked lists have in common. It is guaranteed that there are no cycles in either of the linked lists. The lists must retain their original structure after the function returns.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the first linked list and for each node in the first list, iterate through the second linked list to check if any node is the same. If a match is found, return that node.  If no match is found after traversing both lists, return null.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;unordered_set&gt;

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    if (!headA || !headB) return nullptr;

    ListNode *currA = headA;
    while (currA) {
        ListNode *currB = headB;
        while (currB) {
            if (currA == currB) {
                return currA;
            }
            currB = currB->next;
        }
        currA = currA->next;
    }
    return nullptr;
}
</code></pre>
  <p><b>Time Complexity:</b> O(M * N), where M and N are the lengths of the two linked lists. | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Hash Set Approach</h5>
  <p>Use a hash set to store all nodes of the first linked list.  Then, iterate through the second linked list and check if any node exists in the hash set. If a match is found, return the node. Otherwise, return null.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;unordered_set&gt;

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    if (!headA || !headB) return nullptr;

    unordered_set&lt;ListNode*&gt; visited;
    ListNode *currA = headA;
    while (currA) {
        visited.insert(currA);
        currA = currA->next;
    }

    ListNode *currB = headB;
    while (currB) {
        if (visited.count(currB)) {
            return currB;
        }
        currB = currB->next;
    }
    return nullptr;
}
</code></pre>
  <p><b>Time Complexity:</b> O(M + N), where M and N are the lengths of the two linked lists. | <b>Space Complexity:</b> O(M), where M is the length of the first linked list (in the worst case).</p>
  <h5>‚û§ Two Pointers Approach</h5>
  <p>Calculate the lengths of both linked lists. Move the pointer of the longer list ahead by the difference in lengths. Then, move both pointers simultaneously until they meet or reach the end. If they meet, the intersection node is found. Otherwise, return null.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    if (!headA || !headB) return nullptr;

    int lenA = 0, lenB = 0;
    ListNode *currA = headA, *currB = headB;

    // Calculate the lengths
    while (currA) { lenA++; currA = currA->next; }
    while (currB) { lenB++; currB = currB->next; }

    currA = headA, currB = headB;

    // Move the pointer of the longer list ahead
    if (lenA &gt; lenB) {
        for (int i = 0; i &lt; lenA - lenB; i++) {
            currA = currA->next;
        }
    } else if (lenB &gt; lenA) {
        for (int i = 0; i &lt; lenB - lenA; i++) {
            currB = currB->next;
        }
    }

    // Move both pointers simultaneously until they meet
    while (currA &amp;&amp; currB) {
        if (currA == currB) {
            return currA;
        }
        currA = currA->next;
        currB = currB->next;
    }

    return nullptr;
}
</code></pre>
  <p><b>Time Complexity:</b> O(M + N), where M and N are the lengths of the two linked lists. | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">headA = [4,1,8,4,5], headB = [5,6,1,8,4,5], intersectVal = 8, skipA = 2, skipB = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Intersection at '8'</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The two lists begin to intersect at node with value 8. Note that the intersected node's value is not 1 because the list only intersects at a specific node. Also because of the intersection, the node has to be in both lists.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">headA = [1,9,1,2,4], headB = [3,2,4], intersectVal = 2, skipA = 2, skipB = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Intersection at '2'</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The two lists begin to intersect at node with value 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">headA = [2,6,4], headB = [1,5], intersectVal = 0, skipA = 3, skipB = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No intersection</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No intersection found.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The Two Pointers approach is the most efficient in terms of space complexity.  Make sure to handle the edge cases where one or both lists are empty. Ensure that the code correctly identifies and returns the intersecting node, not just a node with the same value.  If there is no intersection, it's crucial to return `nullptr` and not any random node.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/given-only-a-pointer-to-a-node-to-be-deleted-in-a-singly-linked-list-how-do-you-delete-it/>Delete a node in a Linked List without head pointer</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given a singly linked list and a pointer to a node in the list, delete that node. You are not given a pointer to the head of the list, and you cannot traverse the list from the beginning.  You are only given the node to be deleted.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>This problem cannot be solved directly using a brute force approach because we don't have access to the head or the previous node. Standard deletion requires us to modify the previous node's `next` pointer.  Without knowing the previous node, we can't use a simple iterative traversal to find the previous node and then update its `next` pointer.  Therefore, a brute-force approach doesn't apply here.</p>
  <pre><code class="language-python">// Brute-force is not applicable in this scenario.</code></pre>
  <p><b>Time Complexity:</b> N/A | <b>Space Complexity:</b> N/A</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Copy Data from Next Node</h5>
  <p>The given node's data is overwritten with the data from the *next* node. Then, the *next* node is deleted. This effectively deletes the given node while maintaining the linked list structure.  This approach requires the given node to not be the last node in the linked list, as the next node will be a null pointer dereference.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

void deleteNode(Node* node) {
    if (node == nullptr || node-&gtnext == nullptr) {
        return; // Cannot delete if node is null or the last node
    }

    Node* nextNode = node-&gtnext;
    node-&gtdata = nextNode-&gtdata;
    node-&gtnext = nextNode-&gtnext;
    delete nextNode;
}

// Helper function to print the linked list
void printList(Node* head) {
    Node* current = head;
    while (current != nullptr) {
        cout &lt&lt current-&gtdata &lt&lt " ";
        current = current-&gtnext;
    }
    cout &lt&lt endl;
}
</code></pre>
  <p><b>Time Complexity:</b> O(1) | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">Linked List: 1 -&gt 2 -&gt 3 -&gt 4. Node to delete: node containing value 3.</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 -&gt 2 -&gt 4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The node containing 3 is replaced by the value of node 4, and then node 4 is effectively removed. The list becomes 1 -&gt 2 -&gt 4.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">Linked List: 1 -&gt 2 -&gt 3. Node to delete: node containing value 2.</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 -&gt 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The node containing 2 is replaced by the value of node 3, and then node 3 is effectively removed.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">Linked List: 1. Node to delete: node containing value 1.</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Cannot delete (because its a single node and we can't modify it this way.)</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Edge case: If the node to be deleted is the only node in the linked list or is the last node, it cannot be deleted using this approach because the next pointer is null.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. **Edge Case:** The given approach does not work if the node to be deleted is the last node in the linked list or if the given node is NULL, because you will attempt to access the data of a nullptr.
2. **Constraint:** You *cannot* change the pointer of the node to be deleted to NULL; the solution must maintain the integrity of the linked list structure.
3. **Alternative**: If the problem permitted the last node deletion, we could iterate and swap node data and then change the last node's next pointer to nullptr. But the given problem conditions don't allow modifying the last node to delete, thus our optimal solution is to swap with the next node. </p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/palindrome-linked-list/>Palindrome Linked List</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given the head of a singly linked list, determine if it is a palindrome. Return true if it is a palindrome, and false otherwise.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Convert the linked list to a vector (or array), then check if the vector is a palindrome.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

bool isPalindrome_bruteForce(ListNode* head) {
    vector&lt;int&gt; vals;
    ListNode* curr = head;

    while (curr != nullptr) {
        vals.push_back(curr-&gt;val);
        curr = curr-&gt;next;
    }

    int left = 0, right = vals.size() - 1;
    while (left &lt right) {
        if (vals[left] != vals[right]) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the linked list.  Converting to a vector takes O(N) and checking the palindrome takes O(N). | <b>Space Complexity:</b> O(N), for storing the values in the vector.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized: Reverse Second Half</h5>
  <p>1. Find the middle of the linked list using slow and fast pointers.
2. Reverse the second half of the linked list.
3. Compare the first half and the reversed second half.
4. Restore the linked list by reversing the second half again.
</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* curr = head;
    ListNode* nextNode = nullptr;

    while (curr != nullptr) {
        nextNode = curr-&gt;next;
        curr-&gt;next = prev;
        prev = curr;
        curr = nextNode;
    }
    return prev;
}

bool isPalindrome_optimized(ListNode* head) {
    if (head == nullptr || head-&gt;next == nullptr) {
        return true; // Empty or single-node list is a palindrome
    }

    // Find the middle of the linked list using slow and fast pointers
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }

    // Reverse the second half of the linked list
    ListNode* secondHalfHead = reverseList(slow-&gt;next);
    ListNode* firstHalfHead = head;

    // Compare the first half and the reversed second half
    bool isPalindrome = true;
    while (secondHalfHead != nullptr) {
        if (firstHalfHead-&gt;val != secondHalfHead-&gt;val) {
            isPalindrome = false;
            break;
        }
        firstHalfHead = firstHalfHead-&gt;next;
        secondHalfHead = secondHalfHead-&gt;next;
    }

    // Restore the linked list by reversing the second half again
    slow-&gt;next = reverseList(secondHalfHead);

    return isPalindrome;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the linked list. Traversing to find the middle is O(N), reversing the second half is O(N), and comparing is O(N).  The final reversal to restore the list is also O(N). | <b>Space Complexity:</b> O(1).  We only use a few pointers.  Although the reversal of the second half modifies the list temporarily, it doesn't use extra space proportionally to the input size.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,2,2,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The list is a palindrome.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The list is not a palindrome.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,2,3,2,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The list is a palindrome.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Single element list is a palindrome</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Empty list is a palindrome</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases to consider: empty list, single-node list, even and odd length lists. The optimized solution restores the original list, which is important for some problem contexts.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/reverse-linked-list/>Reverse Linked List</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given the `head` of a singly linked list, reverse the list, and return the reversed list.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the linked list and store the values in a vector. Then, create a new linked list by iterating through the vector in reverse order.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* reverseListBruteForce(ListNode* head) {
    if (!head || !head-&gt;next) return head;

    vector&lt;int&gt; values;
    ListNode* curr = head;
    while (curr) {
        values.push_back(curr-&gt;val);
        curr = curr-&gt;next;
    }

    ListNode* reversedHead = new ListNode(values.back());
    ListNode* reversedCurr = reversedHead;
    for (int i = values.size() - 2; i &gt;= 0; --i) {
        reversedCurr-&gt;next = new ListNode(values[i]);
        reversedCurr = reversedCurr-&gt;next;
    }
    return reversedHead;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the number of nodes in the linked list, due to iterating through the list twice. | <b>Space Complexity:</b> O(n), because we store all node values in a vector.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Iterative Reversal</h5>
  <p>Iteratively reverse the linked list by changing the `next` pointers of each node. Maintain three pointers: `prev`, `curr`, and `next`. `prev` initially points to `nullptr`, `curr` to the head, and `next` to the next node of `curr`. In each iteration, point `curr-&gt;next` to `prev`, update `prev` to `curr`, and `curr` to `next`.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* reverseListIterative(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* curr = head;
    ListNode* next = nullptr;

    while (curr) {
        next = curr-&gt;next;
        curr-&gt;next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the number of nodes in the linked list, as we iterate through each node once. | <b>Space Complexity:</b> O(1), as we only use a constant amount of extra space for pointers.</p>
  <h5>‚û§ Recursive Reversal</h5>
  <p>Recursively reverse the linked list. The base case is when the head is null or only has one node. In each recursive step, reverse the rest of the list starting from head-&gt;next and then change the next pointer of the reversed tail node to point to the head, effectively linking it.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* reverseListRecursive(ListNode* head) {
    if (!head || !head-&gt;next) {
        return head;
    }
    ListNode* newHead = reverseListRecursive(head-&gt;next);
    head-&gt;next-&gt;next = head;
    head-&gt;next = nullptr;
    return newHead;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), as we visit each node once. | <b>Space Complexity:</b> O(n), in the worst case, due to recursive call stack depth (for a completely linear linked list).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,2,3,4,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[5,4,3,2,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The linked list is reversed successfully.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[2,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The linked list is reversed correctly.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">An empty linked list remains empty after reversing.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases include empty linked lists and linked lists with a single node. The iterative approach is generally preferred for its lower space complexity, avoiding the overhead of recursion.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/add-two-numbers/>Add Two Numbers</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Convert the linked lists to integers, add them, and then convert the result back into a linked list.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* addTwoNumbers_BruteForce(ListNode* l1, ListNode* l2) {
    long long num1 = 0, num2 = 0;
    long long powerOfTen = 1;

    // Convert l1 to integer
    ListNode* curr = l1;
    while (curr != nullptr) {
        num1 += curr->val * powerOfTen;
        powerOfTen *= 10;
        curr = curr->next;
    }

    // Convert l2 to integer
    powerOfTen = 1;
    curr = l2;
    while (curr != nullptr) {
        num2 += curr->val * powerOfTen;
        powerOfTen *= 10;
        curr = curr->next;
    }

    // Calculate the sum
    long long sum = num1 + num2;

    // Create a new linked list from the sum
    ListNode* head = nullptr, *tail = nullptr;
    if (sum == 0) {
        head = new ListNode(0);
        return head;
    }

    while (sum > 0) {
        int digit = sum % 10;
        ListNode* newNode = new ListNode(digit);
        if (head == nullptr) {
            head = newNode;
            tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
        sum /= 10;
    }

    return head;
}
</code></pre>
  <p><b>Time Complexity:</b> O(max(m, n)), where m and n are the lengths of the two linked lists. Conversion to integers and conversion back takes O(m) and O(n) respectively. | <b>Space Complexity:</b> O(max(m, n)), because of the linked list created to represent the sum. Potentially O(1) if it is in-place modification</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Iterative Approach</h5>
  <p>Iterate through both lists simultaneously, adding the corresponding digits along with any carry from the previous addition. Create a new linked list to store the result. </p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    ListNode* dummyHead = new ListNode(0); // Dummy head to simplify code
    ListNode* tail = dummyHead;
    int carry = 0;

    while (l1 != nullptr || l2 != nullptr || carry) {
        int digit1 = (l1 != nullptr) ? l1->val : 0;
        int digit2 = (l2 != nullptr) ? l2->val : 0;

        int sum = digit1 + digit2 + carry;
        int digit = sum % 10;
        carry = sum / 10;

        tail->next = new ListNode(digit);
        tail = tail->next;

        l1 = (l1 != nullptr) ? l1->next : nullptr;
        l2 = (l2 != nullptr) ? l2->next : nullptr;
    }

    ListNode* result = dummyHead->next;
    delete dummyHead; // Clean up the dummy node
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(max(m, n)), where m and n are the lengths of the two linked lists, as we iterate at most once through the longer list. | <b>Space Complexity:</b> O(max(m, n)), in the worst-case scenario when the sum requires creating a new linked list of the same length.</p>
  <h5>‚û§ Recursive Approach</h5>
  <p>Recursively add the nodes of the linked lists. Similar to the iterative approach, carry over the carry to the next recursive call. Base case is when both lists and carry are null.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* addTwoNumbers_recursive(ListNode* l1, ListNode* l2, int carry = 0) {
    if (!l1 && !l2 && !carry) {
        return nullptr;
    }

    int sum = carry;
    if (l1) {
        sum += l1->val;
        l1 = l1->next;
    }
    if (l2) {
        sum += l2->val;
        l2 = l2->next;
    }

    ListNode* node = new ListNode(sum % 10);
    node->next = addTwoNumbers_recursive(l1, l2, sum / 10);

    return node;
}
</code></pre>
  <p><b>Time Complexity:</b> O(max(m, n)), where m and n are the lengths of the linked lists. | <b>Space Complexity:</b> O(max(m, n)), due to the recursive call stack.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">l1 = [2,4,3], l2 = [5,6,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[7,0,8]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">342 + 465 = 807. The digits are stored in reverse order.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">l1 = [0], l2 = [0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0 + 0 = 0.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[8,9,9,9,0,0,0,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">9999999 + 9999 = 10009998</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases to consider:
1.  Empty lists.
2.  Lists of different lengths.
3.  Carry at the end.
4.  One or both lists might start with zero, but only the result can start with zero. The initial input values won't have leading zeros, excluding the number 0 itself.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/copy-list-with-random-pointer/>Copy List with Random Pointer</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given the head of a linked list with a random pointer, return a deep copy of the list. Each node in the linked list has two pointers: `next` and `random`. The `next` pointer points to the next node in the list, and the `random` pointer can point to any node in the list or be `null`. You need to create a copy of the linked list, including the `next` and `random` pointers. The copy should have the same structure and values as the original list, but it should be a completely separate list in memory.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Create a new node for each node in the original list and store it in a hash map. Iterate through the original list again. For each node, update the `next` and `random` pointers of the new node using the hash map to look up the corresponding copied nodes.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;

    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};

Node* copyRandomListBruteForce(Node* head) {
    if (!head) return nullptr;

    unordered_map&ltNode*, Node*&gt; map;

    // Create copies of all nodes and store in map
    Node* curr = head;
    while (curr) {
        map[curr] = new Node(curr-&gt;val);
        curr = curr-&gt;next;
    }

    // Set next and random pointers for each copied node
    curr = head;
    while (curr) {
        Node* copyNode = map[curr];
        copyNode-&gt;next = (curr-&gt;next) ? map[curr-&gt;next] : nullptr;
        copyNode-&gt;random = (curr-&gt;random) ? map[curr-&gt;random] : nullptr;
        curr = curr-&gt;next;
    }

    return map[head];
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the list.  We iterate through the list twice. | <b>Space Complexity:</b> O(N), for the hash map to store the mapping between original and copied nodes.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized with Interweaving</h5>
  <p>1. **Interweave the copied nodes:** Create a new node for each original node and insert it immediately after the original node (e.g., A -> A' -> B -> B' -> C -> C').
2. **Set the random pointers:** Iterate through the modified list. For each copied node (A'), set its random pointer to the copied version of the original node's random pointer (A-&gt;random).  If A-&gt;random points to B, then A'-&gt;random should point to B'. This can be done as A'-&gt;random = A-&gt;random-&gt;next
3. **Separate the lists:**  Extract the copied list from the interleaved list and restore the original list.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;

    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};

Node* copyRandomListOptimized(Node* head) {
    if (!head) return nullptr;

    // 1. Interweave copies
    Node* curr = head;
    while (curr) {
        Node* copyNode = new Node(curr-&gt;val);
        Node* nextNode = curr-&gt;next;
        curr-&gt;next = copyNode;
        copyNode-&gt;next = nextNode;
        curr = nextNode;
    }

    // 2. Set random pointers
    curr = head;
    while (curr) {
        if (curr-&gt;random) {
            curr-&gt;next-&gt;random = curr-&gt;random-&gt;next;
        }
        curr = curr-&gt;next-&gt;next;
    }

    // 3. Separate lists
    curr = head;
    Node* newHead = head-&gt;next;
    Node* newCurr = newHead;
    while (curr) {
        curr-&gt;next = newCurr-&gt;next;
        curr = curr-&gt;next;
        if (curr) {
            newCurr-&gt;next = curr-&gt;next;
            newCurr = newCurr-&gt;next;
        }
    }

    return newHead;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes. We iterate through the list a constant number of times. | <b>Space Complexity:</b> O(1). We only use a constant amount of extra space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [[7,null],[13,0],[13,0],[11,null],[2,null]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[7,null],[13,0],[10,4],[11,2],[2,0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The input represents a linked list with nodes having values and random pointers. The output is a deep copy of this linked list.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [[1,1],[2,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,1],[2,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">A linked list where the random pointers of each node point to the node itself.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [[3,null],[3,0],[3,null]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[3,null],[3,0],[3,null]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">A linked list where some random pointers are null.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The interweaving approach is the most efficient because it avoids the use of extra space for a hash map. The main edge case is handling null random pointers correctly. The crucial aspect is to correctly traverse the list and update the `next` and `random` pointers of the newly created nodes.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/add-two-numbers-ii/>Add Two Numbers II</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Convert both linked lists to integers, add the integers, and then convert the result back into a linked list. This is straightforward, but the integers can become very large and potentially exceed the integer limit, leading to overflow issues. This approach is generally not recommended for problems involving large numbers as it lacks scalability.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

// Function to convert a linked list to an integer (potential overflow)
long long listToInt(ListNode* head) {
    long long num = 0;
    while (head) {
        num = num * 10 + head-&gtval;
        head = head-&gtnext;
    }
    return num;
}

// Function to convert an integer to a linked list
ListNode* intToList(long long num) {
    if (num == 0) return new ListNode(0);
    ListNode* head = nullptr;
    while (num &gt 0) {
        ListNode* node = new ListNode(num % 10);
        node-&gtnext = head;
        head = node;
        num /= 10;
    }
    return head;
}

ListNode* addTwoNumbersBruteForce(ListNode* l1, ListNode* l2) {
    long long num1 = listToInt(l1);
    long long num2 = listToInt(l2);
    long long sum = num1 + num2;
    return intToList(sum);
}
</code></pre>
  <p><b>Time Complexity:</b> O(M + N) to convert lists to int, O(1) for addition, O(K) to convert sum to linked list, where M and N are the lengths of the input lists, and K is the number of digits in the sum. However, due to the potential overflow, the time complexity can become unpredictable. | <b>Space Complexity:</b> O(M + N) for the integers' storage. O(K) for the resulting list, where K is the number of digits in the sum.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Using Stacks</h5>
  <p>1. Use stacks to store the values of each linked list in reverse order (i.e., the least significant digit is at the top). 2. Pop from the stacks and add the digits, handling the carry as needed. 3. Create a new linked list to store the sum. This approach avoids the potential overflow issues of converting to integers and is more efficient.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* addTwoNumbersOptimized(ListNode* l1, ListNode* l2) {
    stack&lt;int&gt; s1, s2;
    while (l1) {
        s1.push(l1-&gtval);
        l1 = l1-&gtnext;
    }
    while (l2) {
        s2.push(l2-&gtval);
        l2 = l2-&gtnext;
    }

    int carry = 0;
    ListNode* head = nullptr;
    while (!s1.empty() || !s2.empty() || carry) {
        int sum = carry;
        if (!s1.empty()) {
            sum += s1.top();
            s1.pop();
        }
        if (!s2.empty()) {
            sum += s2.top();
            s2.pop();
        }

        ListNode* node = new ListNode(sum % 10);
        carry = sum / 10;
        node-&gtnext = head;
        head = node;
    }
    return head;
}
</code></pre>
  <p><b>Time Complexity:</b> O(M + N), where M and N are the lengths of the input lists. The algorithm iterates through the lists twice to push elements into stacks, and at most, iterates a third time to construct the result. | <b>Space Complexity:</b> O(M + N) for storing the nodes in the stacks.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">l1 = [7,2,4,3], l2 = [5,6,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[7,8,0,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3427 + 465 = 7807</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">l1 = [2,4,3], l2 = [5,6,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[8,0,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">342 + 465 = 807</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">l1 = [0], l2 = [0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0 + 0 = 0</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key is to handle the linked lists in reverse order, which is naturally achieved by using stacks. Avoid converting linked lists to integers directly because of the possibility of integer overflow, especially when dealing with numbers with a large number of digits.  Pay close attention to the carry during addition. Consider the edge case of one list being significantly longer than the other or cases with leading zeros.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/reverse-linked-list-ii/>Reverse Linked List II</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given the `head` of a singly linked list and two integers `left` and `right` where `left &lt= right`, reverse the nodes of the list from position `left` to position `right`, and return the reversed list.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>1. Traverse to the node at position `left - 1`. 
2. Iterate from `left` to `right` and store the values in an array.
3. Reverse the array.
4. Replace the values of the nodes from `left` to `right` with the reversed array's values.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* reverseBetween(ListNode* head, int left, int right) {
    if (left == right) return head;

    ListNode* current = head;
    ListNode* prev = nullptr;

    // Traverse to the node before the left node
    for (int i = 1; i &lt left; i++) {
        prev = current;
        current = current-&gtnext;
    }

    ListNode* leftNode = prev; // Node before the start of reversal
    ListNode* rightNode = current; // Node at the start of the reversal

    // Reverse the portion of the list
    ListNode* next = nullptr;
    for (int i = left; i &lt= right; i++) {
        next = current-&gtnext;
        current-&gtnext = rightNode-&gtnext;
        rightNode-&gtnext = current;
        current = next;
    }
    
    if(leftNode != nullptr) {
        leftNode-&gtnext = rightNode;
    } else {
        head = rightNode;
    }
    
    return head;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N) where N is the number of nodes in the linked list. | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Iterative Reversal</h5>
  <p>1. Traverse to the node before the `left` position.  This is where we'll 'attach' the reversed segment.
2. Reverse the sublist from `left` to `right` iteratively.  Maintain pointers: `prev`, `current`, and `next`.
3. Connect the reversed sublist back to the original list.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* reverseBetween(ListNode* head, int left, int right) {
    if (left == right) return head;

    ListNode* dummy = new ListNode(0); // Add a dummy node to handle the case where left == 1
    dummy-&gtnext = head;
    ListNode* prev = dummy;  // Pointer to the node *before* the sublist to be reversed

    // 1. Traverse to the node before the 'left' position
    for (int i = 0; i &lt left - 1; i++) {
        prev = prev-&gtnext;
    }

    // 2. Reverse the sublist
    ListNode* current = prev-&gtnext;
    ListNode* next = nullptr;

    for (int i = 0; i &lt right - left + 1; i++) {
        next = current-&gtnext;
        current-&gtnext = prev-&gtnext;
        prev-&gtnext = current;
        current = next;
    }

    // After the loop 'current' will be right+1 and prev->next will be the new head of the reversed portion
    // Now, we need to reattach the reversed portion. Let's first store the next node
    ListNode* temp = prev-&gtnext;

    // The node after the reversed list should point to current
    while(temp-&gtnext != nullptr) {
      temp = temp-&gtnext;
    }
    temp-&gtnext = current;
    return dummy-&gtnext; // Return the head of the modified list
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the linked list. | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,2,3,4,5], left = 2, right = 4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,4,3,2,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The sublist [2,3,4] is reversed resulting in [4,3,2]. The rest of the list remains the same.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [5], left = 1, right = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No reversal needed as left and right are same.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,2,3,4,5], left = 1, right = 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[5,4,3,2,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Reverses the entire list.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. **Dummy Node:** A dummy node is crucial when `left` is 1, as it simplifies the code by avoiding special handling of the head.
2. **Iterative Reversal:**  The iterative approach is preferred for its space efficiency.
3. **Edge Cases:** Consider edge cases such as `left == right` and reversing the entire list.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/reorder-list/>Reorder List</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given the head of a singly linked list, reorder the list. The reordered list should be in the following order: L0 -> Ln -> L1 -> Ln-1 -> L2 -> Ln-2 -> ...  You must do this in-place without altering the nodes' values. For example: Given 1->2->3->4, reorder it to 1->4->2->3.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Extract the values of the linked list into an array. Then, create a new linked list by interleaving elements from the beginning and end of the array.  This involves creating new nodes and linking them together.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

void reorderListBruteForce(ListNode* head) {
    if (!head || !head-&gt;next) return;

    vector&lt;ListNode*&gt; nodes;
    ListNode* curr = head;
    while (curr) {
        nodes.push_back(curr);
        curr = curr-&gt;next;
    }

    int n = nodes.size();
    ListNode* dummy = new ListNode();
    ListNode* tail = dummy;
    int left = 0, right = n - 1;
    while (left &lt;= right) {
        tail-&gt;next = nodes[left];
        tail = tail-&gt;next;
        left++;

        if (left &lt;= right) {
            tail-&gt;next = nodes[right];
            tail = tail-&gt;next;
            right--;
        }
    }
    tail-&gt;next = nullptr; //Important: Set the last node's next pointer to null.
    head = dummy-&gt;next; // Assign the reordered list head to the original head
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the number of nodes in the linked list.  This is due to iterating through the list to store node pointers in an array and then constructing the reordered list. | <b>Space Complexity:</b> O(n) due to the space used to store the nodes in the vector.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach: Using Slow and Fast Pointers, Reversing the Second Half, and Merging</h5>
  <p>1. Find the middle of the linked list using slow and fast pointers. 2. Reverse the second half of the linked list. 3. Merge the first half and the reversed second half.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

// Function to reverse a linked list
ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* curr = head;
    ListNode* next = nullptr;
    while (curr) {
        next = curr-&gt;next;
        curr-&gt;next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}

void reorderListOptimized(ListNode* head) {
    if (!head || !head-&gt;next) return;

    // 1. Find the middle node using slow and fast pointers
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }

    // 2. Reverse the second half of the list
    ListNode* secondHalf = slow-&gt;next;
    slow-&gt;next = nullptr; // Important: Split the list
    secondHalf = reverseList(secondHalf);

    // 3. Merge the two halves
    ListNode* firstHalf = head;
    ListNode* second = secondHalf;
    while (second) {
        ListNode* temp1 = firstHalf-&gt;next;
        ListNode* temp2 = second-&gt;next;
        firstHalf-&gt;next = second;
        second-&gt;next = temp1;
        firstHalf = temp1;
        second = temp2;
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the number of nodes.  The algorithm involves traversing the list to find the middle, reversing a portion, and merging.  Each step takes O(n) time. | <b>Space Complexity:</b> O(1) - Constant space is used.  We are only modifying the pointers in place.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1->2->3->4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1->4->2->3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The list is reordered by taking the first element, then the last, then the second, then the second to last, and so on.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1->2->3->4->5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1->5->2->4->3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Similar to the previous example, the list is reordered by interleaving elements from the front and the back.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Handles the edge case with a single node, no change is required.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1->2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1->2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Handles the edge case of 2 nodes.  No rearrangement is required.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  **Edge Cases:** Consider empty lists and lists with only one or two nodes. 
2.  **In-place Modification:** The problem requires modifying the list in-place, which means you should not create new nodes; instead, modify the 'next' pointers of existing nodes. 
3.  **Splitting the List:**  When finding the middle node, carefully split the list to avoid creating cycles.  This is done by setting the 'next' pointer of the middle node to null before reversing the second half.
4. **Reversing the second half:** Make sure to handle reversal correctly using prev, curr and next pointers. 
5.  **Merging:** When merging, correctly link the nodes by alternating nodes from the two halves.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/remove-nth-node-from-end-of-list/>Remove Nth Node From End of List</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given the head of a linked list, remove the nth node from the end of the list and return its head. </p>

  <h4>üß† Brute Force Approach</h4>
  <p>First, calculate the length of the linked list. Then, traverse the list again to the node just before the node to be removed.  Update the `next` pointer of this node to skip the nth node from the end. Handle edge cases like removing the head.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* removeNthFromEnd_brute_force(ListNode* head, int n) {
    if (!head) return nullptr;

    // Calculate the length of the list
    int len = 0;
    ListNode* curr = head;
    while (curr) {
        len++;
        curr = curr-&gt;next;
    }

    // If n is greater than or equal to the length, remove the head
    if (n &gt;= len) {
        ListNode* temp = head-&gt;next;
        delete head;
        return temp;
    }

    // Find the node before the node to be removed
    int steps = len - n - 1;
    curr = head;
    for (int i = 0; i &lt; steps; ++i) {
        curr = curr-&gt;next;
    }

    // Remove the nth node
    ListNode* toDelete = curr-&gt;next;
    curr-&gt;next = toDelete-&gt;next;
    delete toDelete;

    return head;
}
</code></pre>
  <p><b>Time Complexity:</b> O(L), where L is the length of the linked list. We traverse the list twice. | <b>Space Complexity:</b> O(1) - Constant extra space is used.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Two Pointers</h5>
  <p>Use two pointers, `slow` and `fast`. Move `fast` pointer `n` steps ahead.  Then, move both `slow` and `fast` pointers one step at a time until `fast` reaches the end.  `slow` will then be pointing to the node *before* the node to be removed. Handle the edge case where `fast` reaches the end before moving `n` steps (i.e., removing the head).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* removeNthFromEnd_optimized(ListNode* head, int n) {
    if (!head) return nullptr;

    ListNode* dummy = new ListNode(0); // Create a dummy node to handle removing the head.
    dummy-&gt;next = head;
    ListNode* slow = dummy;
    ListNode* fast = dummy;

    // Move fast pointer n+1 steps ahead
    for (int i = 0; i &lt; n + 1; ++i) {
        if (!fast)
            return head;
        fast = fast-&gt;next;
    }

    // Move both pointers until fast reaches the end
    while (fast) {
        slow = slow-&gt;next;
        fast = fast-&gt;next;
    }

    // Remove the nth node
    ListNode* toDelete = slow-&gt;next;
    slow-&gt;next = toDelete-&gt;next;
    delete toDelete;

    ListNode* result = dummy-&gt;next;
    delete dummy;
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(L), where L is the length of the linked list. We traverse the list once. | <b>Space Complexity:</b> O(1) - Constant extra space is used.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,2,3,4,5], n = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,3,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The second node from the end is 4, so it is removed. The modified list is [1,2,3,5].</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1], n = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The first node from the end is 1, so it is removed. The modified list is [].</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,2], n = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The first node from the end is 2, so it is removed. The modified list is [1].</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  **Dummy Node:**  Using a dummy node simplifies handling the edge case where the head needs to be removed.
2.  **Two Pointers:** The two-pointer approach is generally preferred for its efficiency and elegant solution.
3.  **Memory Management:** Always be careful about memory leaks; use `delete` to free the memory allocated for the removed node(s).  The dummy node also needs to be properly deleted after use.
4.  **Edge Cases:** Always test with edge cases such as removing the head node, removing the last node, and an empty list.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/>Flatten a Multilevel Doubly Linked List</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>You are given a doubly linked list which in addition to the next and prev pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure.

Flatten the list so that all the nodes are in a single-level, doubly linked list. You are given the head of the first level of the list.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves recursively traversing the list. For each node, if it has a child, we flatten the child list and insert it between the current node and the next node in the main list.  We need to handle the prev and next pointers carefully to maintain the doubly-linked structure.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a Node.
class Node {
public:
    int val;
    Node* prev;
    Node* next;
    Node* child;

    Node() {}

    Node(int _val, Node* _prev, Node* _next, Node* _child) {
        val = _val;
        prev = _prev;
        next = _next;
        child = _child;
    }
};

class Solution {
public:
    Node* flatten(Node* head) {
        if (!head) return head;

        Node* curr = head;
        while (curr) {
            if (curr-&gt;child) {
                Node* childHead = curr-&gt;child;
                Node* childTail = childHead;
                while (childTail-&gt;next) {
                    childTail = childTail-&gt;next;
                }

                Node* nextNode = curr-&gt;next;
                curr-&gt;next = childHead;
                childHead-&gt;prev = curr;
                curr-&gt;child = nullptr; 

                childTail-&gt;next = nextNode;
                if (nextNode) {
                    nextNode-&gt;prev = childTail;
                }
                
            }
            curr = curr-&gt;next;
        }
        return head;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N^2), where N is the total number of nodes.  In the worst case, we might have to traverse all the child nodes repeatedly.  The nested loops inside the main loop lead to this complexity. | <b>Space Complexity:</b> O(1) - constant extra space as we are modifying the list in place.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Recursive Approach</h5>
  <p>This approach uses recursion to flatten the list.  We define a helper function that recursively flattens each child list and connects it to the main list.  This is more efficient because the child lists are only traversed once. The key is to use a recursive helper function that returns the tail of the flattened list. This allows for efficient connection of the flattened child lists.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a Node.
class Node {
public:
    int val;
    Node* prev;
    Node* next;
    Node* child;

    Node() {}

    Node(int _val, Node* _prev, Node* _next, Node* _child) {
        val = _val;
        prev = _prev;
        next = _next;
        child = _child;
    }
};

class Solution {
public:
    Node* flatten(Node* head) {
        if (!head) return head;
        flattenHelper(head);
        return head;
    }

private:
    Node* flattenHelper(Node* head) {
        Node* curr = head;
        Node* tail = head;
        while (curr) {
            Node* nextNode = curr-&gt;next;

            if (curr-&gt;child) {
                Node* childTail = flattenHelper(curr-&gt;child);
                curr-&gt;child-&gt;prev = curr;
                curr-&gt;next = curr-&gt;child;
                curr-&gt;child = nullptr;
                curr = childTail; 
            }

            tail = curr;
            curr = nextNode;
            if(curr) {
                tail = curr;
            }
        }
        return tail;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the total number of nodes. We visit each node at most once. | <b>Space Complexity:</b> O(N) - due to the recursion call stack in the worst case (when the list is deeply nested).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,3,7,8,11,12,9,10,4,5,6]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The input represents a multilevel linked list.  The output is the flattened list where each node is on the same level.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,2,null,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,3,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">This example shows a case where the child nodes can be in between the main list nodes.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Key considerations include properly handling the `prev` and `next` pointers when inserting or removing nodes. It's also important to handle the edge cases where child nodes exist, or where the list is empty.  The recursive approach is more efficient and cleaner.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/partition-list/>Partition List</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the linked list and separate nodes into two lists: one for nodes less than x and one for nodes greater than or equal to x. Then, concatenate these two lists.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* partition_brute_force(ListNode* head, int x) {
    if (!head) return nullptr;

    ListNode* less_head = nullptr, *less_tail = nullptr;
    ListNode* greater_head = nullptr, *greater_tail = nullptr;

    ListNode* curr = head;
    while (curr) {
        ListNode* next_node = curr->next;
        if (curr->val &lt x) {
            if (!less_head) {
                less_head = curr;
                less_tail = curr;
            } else {
                less_tail->next = curr;
                less_tail = curr;
            }
            less_tail->next = nullptr; // Important: break the original connection
        } else {
            if (!greater_head) {
                greater_head = curr;
                greater_tail = curr;
            } else {
                greater_tail->next = curr;
                greater_tail = curr;
            }
            greater_tail->next = nullptr; // Important: break the original connection
        }
        curr = next_node;
    }

    if (!less_head) return greater_head;
    less_tail->next = greater_head;
    return less_head;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the linked list. We iterate through the list once. | <b>Space Complexity:</b> O(1). We use constant extra space.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Two Pointers Approach</h5>
  <p>Iterate through the list, maintaining two sublists: one for nodes less than x (before) and one for nodes greater than or equal to x (after). Connect these sublists at the end.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* partition_optimal(ListNode* head, int x) {
    ListNode* before_head = new ListNode(0); // Dummy node
    ListNode* before_tail = before_head;
    ListNode* after_head = new ListNode(0); // Dummy node
    ListNode* after_tail = after_head;

    ListNode* curr = head;
    while (curr) {
        ListNode* next_node = curr->next;
        if (curr->val &lt x) {
            before_tail->next = curr;
            before_tail = curr;
        } else {
            after_tail->next = curr;
            after_tail = curr;
        }
        curr = next_node;
    }

    after_tail->next = nullptr; // Important: Break the cycle
    before_tail->next = after_head->next;

    ListNode* result = before_head->next;
    delete before_head;
    delete after_head;
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the linked list. | <b>Space Complexity:</b> O(1). We use constant extra space (excluding the dummy nodes).  The dummy nodes are constant space overhead.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,4,3,2,5,2], x = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,2,4,3,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Nodes with values less than 3 are moved before nodes with values greater than or equal to 3. The relative order within each partition is preserved.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [2,1], x = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Nodes with values less than 2 (only 1) are placed before 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [], x = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Empty list remains empty.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The relative order within each partition must be preserved.
2.  Consider the edge case where the list is empty, or all nodes are less than or greater than or equal to x.
3.  Dummy nodes help simplify the concatenation process.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/>Remove Duplicates from Sorted List II</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the list and use a hash map (unordered_map in C++) to count the occurrences of each value. Then, iterate through the list again and remove nodes with counts greater than 1.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* deleteDuplicatesBruteForce(ListNode* head) {
    if (!head || !head-&gt;next) {
        return head;
    }

    unordered_map&lt;int, int&gt; counts;
    ListNode* curr = head;
    while (curr) {
        counts[curr-&gt;val]++;
        curr = curr-&gt;next;
    }

    ListNode* dummy = new ListNode(0);
    dummy-&gt;next = head;
    ListNode* prev = dummy;
    curr = head;

    while (curr) {
        if (counts[curr-&gt;val] &gt; 1) {
            prev-&gt;next = curr-&gt;next;
        } else {
            prev = curr;
        }
        curr = curr-&gt;next;
    }

    ListNode* result = dummy-&gt;next;
    delete dummy;
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the number of nodes in the linked list. We iterate through the list twice. | <b>Space Complexity:</b> O(n), in the worst case, where all the elements are unique, we store all the elements in the hash map.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Two Pointers</h5>
  <p>Use two pointers, `prev` and `curr`.  `curr` iterates through the list. `prev` always points to the node before the current distinct node. If duplicates are found, skip them.  If no duplicates are found, advance both pointers.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* deleteDuplicatesOptimized(ListNode* head) {
    if (!head || !head-&gt;next) {
        return head;
    }

    ListNode* dummy = new ListNode(0, head);
    ListNode* prev = dummy;
    ListNode* curr = head;

    while (curr) {
        if (curr-&gt;next && curr-&gt;val == curr-&gt;next-&gt;val) {
            // Found duplicates
            int duplicateValue = curr-&gt;val;
            while (curr && curr-&gt;val == duplicateValue) {
                curr = curr-&gt;next;
            }
            prev-&gt;next = curr;
        } else {
            prev = curr;
            curr = curr-&gt;next;
        }
    }

    ListNode* result = dummy-&gt;next;
    delete dummy;
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the number of nodes in the linked list.  We iterate through the list at most twice in the worst case. | <b>Space Complexity:</b> O(1), constant space is used because we are only using two pointers.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,2,3,3,4,4,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Nodes with duplicate values (3 and 4) are removed, leaving only distinct values.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,1,1,2,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[2,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Nodes with duplicate values (1) are removed.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1, 2, 2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Node with value 2 is removed, preserving only the distinct values.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The input list is sorted, which is a crucial property for solving this problem efficiently.  Consider the edge case where all nodes have the same value and the case where there are no duplicates.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/linked-list-in-zig-zag-fashion/>Linked List in Zig-Zag fashion</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a singly linked list, reorder the list in-place such that the elements are arranged in a zig-zag fashion, i.e., smaller &lt; larger &gt; smaller &lt; larger ...

For example:
Given 1-&gt;2-&gt;3-&gt;4-&gt;5
You should reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>1. Store all the nodes' values into a vector.
2. Sort the vector.
3. Create a new linked list based on the zig-zag pattern from the sorted vector.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* zigzag_brute_force(ListNode* head) {
    if (!head || !head-&gt;next) return head;

    vector&lt;int&gt; values;
    ListNode* curr = head;
    while (curr) {
        values.push_back(curr-&gt;val);
        curr = curr-&gt;next;
    }

    sort(values.begin(), values.end());

    ListNode* newHead = new ListNode(values[0]);
    ListNode* currNew = newHead;
    int left = 1, right = values.size() - 1;
    bool turn = true; // true: right, false: left

    while (left &lt;= right) {
        if (turn) {
            currNew-&gt;next = new ListNode(values[right]);
            right--;
        } else {
            currNew-&gt;next = new ListNode(values[left]);
            left++;
        }
        currNew = currNew-&gt;next;
        turn = !turn;
    }

    return newHead;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N log N) due to sorting the values vector. | <b>Space Complexity:</b> O(N) to store the values in the vector.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized (In-place - Split, Reverse, Merge)</h5>
  <p>1. Find the middle of the linked list.
2. Reverse the second half of the list.
3. Merge the first half and the reversed second half in a zig-zag manner.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* curr = head;
    ListNode* next = nullptr;
    while (curr) {
        next = curr-&gt;next;
        curr-&gt;next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}

ListNode* zigzag_optimized(ListNode* head) {
    if (!head || !head-&gt;next) return head;

    // Find the middle node
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast &amp;&amp; fast-&gt;next) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }

    // Reverse the second half
    ListNode* secondHalf = slow-&gt;next;
    slow-&gt;next = nullptr;
    secondHalf = reverseList(secondHalf);

    // Merge the two halves
    ListNode* firstHalf = head;
    ListNode* curr = head;
    while (firstHalf &amp;&amp; secondHalf) {
        ListNode* nextFirst = firstHalf-&gt;next;
        ListNode* nextSecond = secondHalf-&gt;next;

        curr-&gt;next = secondHalf;
        secondHalf-&gt;next = nextFirst;

        firstHalf = nextFirst;
        secondHalf = nextSecond;
        curr = curr-&gt;next-&gt;next;
    }

    return head;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N). Finding the middle, reversing, and merging all take O(N) time. | <b>Space Complexity:</b> O(1). In-place operations are performed.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 -&gt; 5 -&gt; 2 -&gt; 4 -&gt; 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The list is reordered such that smaller &lt; larger &gt; smaller &lt; larger.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1 -&gt; 2 -&gt; 3 -&gt; 4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 -&gt; 4 -&gt; 2 -&gt; 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The list is reordered in a zig-zag fashion.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Single node list remains unchanged.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1 -&gt; 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 -&gt; 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Two node list remains unchanged.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases include empty lists, lists with one or two nodes. The optimized solution modifies the list in-place, making it more efficient in terms of space usage. It is important to handle the null pointers correctly, especially during reversing and merging the list segments.  The middle node finding is done using the slow-fast pointer approach.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/sort-list/>Sort List</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given the head of a linked list, return the list after sorting it in ascending order.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves extracting all the values from the linked list into an array, sorting the array, and then constructing a new linked list with the sorted values.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* bruteForceSortList(ListNode* head) {
    if (!head) return nullptr;

    vector&lt;int&gt; values;
    ListNode* current = head;
    while (current) {
        values.push_back(current-&gt;val);
        current = current-&gt;next;
    }

    sort(values.begin(), values.end());

    ListNode* sortedHead = nullptr;
    ListNode* tail = nullptr;

    for (int value : values) {
        ListNode* newNode = new ListNode(value);
        if (!sortedHead) {
            sortedHead = newNode;
            tail = newNode;
        } else {
            tail-&gt;next = newNode;
            tail = newNode;
        }
    }

    return sortedHead;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log n) due to sorting the array.  Extracting values and creating the new linked list take O(n) each, but sorting dominates. | <b>Space Complexity:</b> O(n) to store the values in the array.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Merge Sort (Bottom-up)</h5>
  <p>This approach uses the merge sort algorithm. Merge sort is well-suited for linked lists because it doesn't require random access. It divides the list into smaller sublists, sorts them, and then merges them back together.  Bottom-up approach starts with merging lists of size 1, then 2, 4, and so on.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* merge(ListNode* left, ListNode* right) {
    ListNode dummy;
    ListNode* tail = &dummy;
    while (left &amp;&amp; right) {
        if (left-&gt;val &lt;= right-&gt;val) {
            tail-&gt;next = left;
            left = left-&gt;next;
        } else {
            tail-&gt;next = right;
            right = right-&gt;next;
        }
        tail = tail-&gt;next;
    }

    tail-&gt;next = (left) ? left : right;
    return dummy.next;
}

ListNode* sortList(ListNode* head) {
    if (!head || !head-&gt;next) {
        return head;
    }

    int length = 0;
    ListNode* current = head;
    while (current) {
        length++;
        current = current-&gt;next;
    }

    ListNode dummy(0, head);
    for (int sublistSize = 1; sublistSize &lt; length; sublistSize *= 2) {
        ListNode* prev = &dummy;
        current = dummy.next;
        while (current) {
            ListNode* left = current;
            ListNode* right = nullptr;
            for (int i = 1; i &lt; sublistSize &amp;&amp; current-&gt;next; ++i) {
                current = current-&gt;next;
            }
            right = current-&gt;next;
            current-&gt;next = nullptr;
            current = right;

            for (int i = 1; i &lt; sublistSize &amp;&amp; current &amp;&amp; current-&gt;next; ++i) {
                current = current-&gt;next;
            }
            ListNode* next = nullptr;
            if (current) {
                next = current-&gt;next;
                current-&gt;next = nullptr;
            }

            ListNode* merged = merge(left, right);
            prev-&gt;next = merged;
            while (prev-&gt;next) {
                prev = prev-&gt;next;
            }

            current = next;
        }
    }
    return dummy.next;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log n) - Merge sort has a time complexity of O(n log n) in both average and worst-case scenarios. | <b>Space Complexity:</b> O(1) - Merge sort in-place for the linked list. However, the merge function requires some additional space which is O(log n) due to the recursive calls.  Overall space complexity can also be considered as O(1).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [4,2,1,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,3,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The input linked list is sorted to produce the output.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [-1,5,3,4,0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[-1,0,3,4,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The input linked list is sorted to produce the output.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">An empty list is already sorted.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The merge sort approach is preferred because it achieves O(n log n) time complexity with O(1) space complexity, or at worst O(log n) space due to merge function recursive calls, suitable for linked lists.  The brute force approach is easy to implement but less efficient.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/segregate-even-and-odd-elements-in-a-linked-list/>Segregate even and odd elements in a linked list</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a linked list, rearrange the nodes such that all even numbers appear before all odd numbers. The relative order of even and odd numbers should be maintained.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the linked list. Create two separate lists: one for even numbers and one for odd numbers. Concatenate the even list and the odd list.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

Node* segregateEvenOdd(Node* head) {
    if (!head || !head-&gt;next) return head;

    Node* evenHead = nullptr, *evenTail = nullptr;
    Node* oddHead = nullptr, *oddTail = nullptr;
    Node* curr = head;

    while (curr) {
        if (curr-&gt;data % 2 == 0) {
            if (!evenHead) {
                evenHead = evenTail = curr;
            } else {
                evenTail-&gt;next = curr;
                evenTail = curr;
            }
        } else {
            if (!oddHead) {
                oddHead = oddTail = curr;
            } else {
                oddTail-&gt;next = curr;
                oddTail = curr;
            }
        }
        curr = curr-&gt;next;
    }

    if (!evenHead) return oddHead;
    if (!oddHead) return evenHead;

    evenTail-&gt;next = oddHead;
    if(oddTail) oddTail-&gt;next = nullptr;
    return evenHead;
}

// Helper function to print the linked list
void printList(Node* head) {
    Node* curr = head;
    while (curr) {
        cout &lt&lt curr-&gt;data &lt&lt " ";
        curr = curr-&gt;next;
    }
    cout &lt&lt endl;
}

int main() {
    Node* head = new Node(1);
    head-&gt;next = new Node(2);
    head-&gt;next-&gt;next = new Node(3);
    head-&gt;next-&gt;next-&gt;next = new Node(4);
    head-&gt;next-&gt;next-&gt;next-&gt;next = new Node(5);

    cout &lt&lt "Original list: ";
    printList(head);

    head = segregateEvenOdd(head);

    cout &lt&lt "Segregated list: ";
    printList(head);

    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the linked list. We iterate through the list once. | <b>Space Complexity:</b> O(1). We are not using any extra space that scales with the input size, though we do create new pointers, the space used by them is constant.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Two-Pointer Approach (In-place)</h5>
  <p>Maintain two pointers, even and odd. Iterate through the list. If an even number is found, swap it with the node pointed to by the even pointer, and move the even pointer forward. Otherwise, move to the next node.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

Node* segregateEvenOddOptimized(Node* head) {
    if (!head || !head-&gt;next) return head;

    Node* even = nullptr, *odd = nullptr, *even_tail = nullptr;
    Node* curr = head;

    while(curr &amp;&amp; curr-&gt;data % 2 == 0) {
        even = curr;
        even_tail = curr;
        curr = curr-&gt;next;
    }

    if(!even) return head;
    odd = curr;
    while(curr) {
        if(curr-&gt;data % 2 == 0) {
            even_tail-&gt;next = curr;
            even_tail = curr;
            odd = curr-&gt;next;
        }
        else if(odd != nullptr)
        {
            even_tail-&gt;next = curr;
            even_tail = curr;
            curr = curr-&gt;next;
            odd = curr;
            continue;
        }
        else
            break;
        
        curr = curr-&gt;next;
    }
    if(even_tail != nullptr) even_tail-&gt;next = nullptr;
    return even;
}

void printList(Node* head) {
    Node* curr = head;
    while (curr) {
        cout &lt&lt curr-&gt;data &lt&lt " ";
        curr = curr-&gt;next;
    }
    cout &lt&lt endl;
}

int main() {
    Node* head = new Node(1);
    head-&gt;next = new Node(2);
    head-&gt;next-&gt;next = new Node(3);
    head-&gt;next-&gt;next-&gt;next = new Node(4);
    head-&gt;next-&gt;next-&gt;next-&gt;next = new Node(5);

    cout &lt&lt "Original list: ";
    printList(head);

    head = segregateEvenOddOptimized(head);

    cout &lt&lt "Segregated list: ";
    printList(head);

    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes. We iterate through the list once. | <b>Space Complexity:</b> O(1). We are modifying the list in-place, using only a few pointers.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1-&gt;2-&gt;3-&gt;4-&gt;5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2-&gt;4-&gt;1-&gt;3-&gt;5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Even numbers (2, 4) are moved to the front, while maintaining the original order of even and odd numbers.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1-&gt;3-&gt;5-&gt;7</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1-&gt;3-&gt;5-&gt;7</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No even numbers, so the list remains unchanged.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">2-&gt;4-&gt;6-&gt;8</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2-&gt;4-&gt;6-&gt;8</td>
        <td style="border: 1px solid #ccc; padding: 6px;">All numbers are even, so the list remains unchanged.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1-&gt;2-&gt;1-&gt;4-&gt;5-&gt;6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2-&gt;4-&gt;6-&gt;1-&gt;1-&gt;5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Even numbers (2, 4, 6) are moved to the front, while maintaining the original order of even and odd numbers.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases to consider: empty list, all even or all odd numbers. Maintain the relative order of even and odd numbers.  The in-place approach is preferred for its efficiency.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/rearrange-a-given-linked-list-in-place/>Rearrange a given linked list in-place</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a singly linked list, rearrange the nodes in such a way that all odd positioned nodes are placed at the beginning and all even positioned nodes are placed at the end. The relative order of odd and even nodes should be maintained. You must do this in-place.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>1. Iterate through the linked list and store the values of odd-positioned nodes in one list and even-positioned nodes in another list.
2. Concatenate the two lists.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

Node* rearrangeLinkedListBruteForce(Node* head) {
    if (!head || !head-&gt;next) return head;

    Node* oddHead = nullptr, *oddTail = nullptr;
    Node* evenHead = nullptr, *evenTail = nullptr;
    Node* curr = head;
    int pos = 1;

    while (curr) {
        Node* nextNode = curr-&gt;next;
        curr-&gt;next = nullptr;
        if (pos % 2 != 0) {
            if (!oddHead) {oddHead = oddTail = curr;} else {oddTail-&gt;next = curr; oddTail = curr;}
        } else {
            if (!evenHead) {evenHead = evenTail = curr;} else {evenTail-&gt;next = curr; evenTail = curr;}
        }
        curr = nextNode;
        pos++;
    }

    if (!oddHead) return evenHead; //all even
    if (!evenHead) return oddHead; //all odd

    oddTail-&gt;next = evenHead;
    return oddHead;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the linked list. We iterate through the list once. | <b>Space Complexity:</b> O(N) in the worst case when there are all odd or even nodes. We store all nodes in separate lists.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized (In-place)</h5>
  <p>1. Find the middle of the linked list using slow and fast pointers.
2. Reverse the second half of the list.
3. Merge the first half and the reversed second half by interleaving nodes.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

Node* reverseList(Node* head) {
    Node* prev = nullptr;
    Node* curr = head;
    Node* next = nullptr;

    while (curr) {
        next = curr-&gt;next;
        curr-&gt;next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}

Node* rearrangeLinkedListOptimized(Node* head) {
    if (!head || !head-&gt;next) return head;

    // Find the middle
    Node* slow = head, *fast = head, *prev = nullptr;
    while (fast &amp;&amp; fast-&gt;next) {
        prev = slow;
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }

    // Split and reverse the second half
    Node* secondHalf = slow-&gt;next;
    prev-&gt;next = nullptr; //end first half
    secondHalf = reverseList(secondHalf);

    // Merge the two halves
    Node* firstHalf = head;
    Node* result = nullptr;
    Node* tail = nullptr;
    while (firstHalf || secondHalf) {
        if (firstHalf) {
            if (!result) {result = firstHalf; tail = firstHalf;} else {tail-&gt;next = firstHalf; tail = firstHalf;}
            firstHalf = firstHalf-&gt;next;
            tail-&gt;next = nullptr;
        }
        if (secondHalf) {
            if (!result) {result = secondHalf; tail = secondHalf;} else {tail-&gt;next = secondHalf; tail = secondHalf;}
            secondHalf = secondHalf-&gt;next;
            tail-&gt;next = nullptr;
        }
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes. We iterate through the list a few times (finding middle, reversing, merging). | <b>Space Complexity:</b> O(1), we perform the rearrangement in-place without extra space (except a few pointers).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 -&gt; 3 -&gt; 5 -&gt; 2 -&gt; 4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The odd-positioned nodes (1, 3, 5) are placed before the even-positioned nodes (2, 4).</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1 -&gt; 2 -&gt; 3 -&gt; 4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 -&gt; 3 -&gt; 2 -&gt; 4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The odd-positioned nodes (1, 3) are placed before the even-positioned nodes (2, 4).</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Single node, remains unchanged.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1 -&gt; 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 -&gt; 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The odd-positioned nodes (1) are placed before the even-positioned nodes (2).</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The in-place solution modifies the original linked list. Pay attention to the edge cases like empty list, or single node list, even or odd length list. The important part is to split and reverse the second half and then merge. Also remember to set next of tail node of result list to nullptr in merge part.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/merge-k-sorted-lists/>Merge k Sorted Lists</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>You are given an array of k linked-lists, where each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Collect all the nodes from all the linked lists into a single list. Sort this list. Create a new linked list from the sorted list.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* mergeKLists_bruteforce(vector&lt;ListNode*&gt;&amp; lists) {
    vector&lt;int&gt; values;
    for (ListNode* list : lists) {
        ListNode* current = list;
        while (current) {
            values.push_back(current-&gt;val);
            current = current-&gt;next;
        }
    }

    sort(values.begin(), values.end());

    ListNode* head = nullptr;
    ListNode* tail = nullptr;
    for (int val : values) {
        ListNode* newNode = new ListNode(val);
        if (!head) {
            head = newNode;
            tail = newNode;
        } else {
            tail-&gt;next = newNode;
            tail = newNode;
        }
    }

    return head;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N log N), where N is the total number of nodes in all the lists. This is because of the sorting step. | <b>Space Complexity:</b> O(N), where N is the total number of nodes. This is to store all node values in a vector.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Merge with Priority Queue</h5>
  <p>Use a min-heap (priority queue) to store the heads of all k linked lists. Repeatedly extract the minimum node from the heap, append it to the merged list, and insert the next node from the same list into the heap. This approach efficiently finds the smallest element across all k lists.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

struct CompareNodes {
    bool operator()(ListNode* a, ListNode* b) {
        return a-&gt;val &gt; b-&gt;val;
    }
};

ListNode* mergeKLists_priorityQueue(vector&lt;ListNode*&gt;&amp; lists) {
    priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, CompareNodes&gt; pq;
    for (ListNode* list : lists) {
        if (list) {
            pq.push(list);
        }
    }

    ListNode* head = nullptr;
    ListNode* tail = nullptr;

    while (!pq.empty()) {
        ListNode* current = pq.top();
        pq.pop();

        if (!head) {
            head = current;
            tail = current;
        } else {
            tail-&gt;next = current;
            tail = current;
        }

        if (current-&gt;next) {
            pq.push(current-&gt;next);
        }
    }

    return head;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N log k), where N is the total number of nodes and k is the number of linked lists. Inserting and extracting from the priority queue takes O(log k) time, and we do this for each of the N nodes. | <b>Space Complexity:</b> O(k), where k is the number of linked lists. The priority queue holds at most k elements (the heads of each list).</p>
  <h5>‚û§ Merge Lists Pairwise (Divide and Conquer)</h5>
  <p>Pairwise merge the linked lists iteratively.  Merge the first two lists, then merge the result with the third list, and so on.  This method has a better time complexity if we merge lists in pairs, recursively.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    ListNode* dummy = new ListNode();
    ListNode* tail = dummy;

    while (l1 &amp;&amp; l2) {
        if (l1-&gt;val &lt;= l2-&gt;val) {
            tail-&gt;next = l1;
            l1 = l1-&gt;next;
        } else {
            tail-&gt;next = l2;
            l2 = l2-&gt;next;
        }
        tail = tail-&gt;next;
    }

    tail-&gt;next = l1 ? l1 : l2;
    return dummy-&gt;next;
}

ListNode* mergeKLists_divideAndConquer(vector&lt;ListNode*&gt;&amp; lists, int left, int right) {
    if (left &gt; right) return nullptr;
    if (left == right) return lists[left];

    int mid = left + (right - left) / 2;
    ListNode* l1 = mergeKLists_divideAndConquer(lists, left, mid);
    ListNode* l2 = mergeKLists_divideAndConquer(lists, mid + 1, right);
    return mergeTwoLists(l1, l2);
}

ListNode* mergeKLists_optimized(vector&lt;ListNode*&gt;&amp; lists) {
    if (lists.empty()) return nullptr;
    return mergeKLists_divideAndConquer(lists, 0, lists.size() - 1);
}
</code></pre>
  <p><b>Time Complexity:</b> O(N log k), where N is the total number of nodes and k is the number of linked lists.  Each merge of two lists takes O(n) time, where n is the combined size of the lists. We merge in log(k) steps. | <b>Space Complexity:</b> O(1) (in-place merge), or O(log k) for recursive calls stack.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">lists = [[1,4,5],[1,3,4],[2,6]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,1,2,3,4,4,5,6]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The linked lists are merged into one sorted list.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">lists = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">If the input is empty, return an empty list.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">lists = [[]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">If all lists are empty, return an empty list.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  **Empty Input:** Handle the case where the input `lists` is empty or contains empty lists.
2.  **One List:** If the input contains only one list, return that list directly.
3.  **Node Values:** The linked lists are sorted in ascending order of node values.
4.  **Memory Management:**  Be mindful of memory leaks. If the code uses dynamically allocated nodes (e.g., `new ListNode()`), make sure to deallocate them when they're no longer needed (e.g., in a cleanup function or at the end of the program).</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/reverse-nodes-in-k-group/>Reverse Nodes in k-Group</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.

k is a positive integer and is less than or equal to the length of the linked list.

If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.

You may not alter the values in the list's nodes, only nodes themselves may be changed.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the linked list, identify groups of k nodes, and reverse each group. This involves repeatedly traversing the list and reversing segments.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* reverseKGroupBruteForce(ListNode* head, int k) {
    if (head == nullptr || k == 1) {
        return head;
    }

    ListNode* dummy = new ListNode(0);
    dummy->next = head;
    ListNode* prev = dummy;
    ListNode* curr = head;

    while (curr) {
        ListNode* tail = prev;
        // Determine if there are k nodes to reverse
        for (int i = 0; i &lt k; i++) {
            tail = tail->next;
            if (!tail) {
                return dummy->next;
            }
        }

        ListNode* nextGroupHead = tail->next;
        // Reverse the group of k nodes
        ListNode* p1 = prev->next, * p2 = prev->next->next;
        for (int i = 0; i &lt k - 1; ++i) {
            ListNode* temp = p2->next;
            p2->next = p1;
            p1 = p2;
            p2 = temp;
        }

        ListNode* temp = prev->next;
        prev->next->next = nextGroupHead;
        prev->next = tail;
        prev = temp;
        curr = nextGroupHead;
    }

    return dummy->next;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n * k), where n is the number of nodes.  We iterate n/k times and reverse k nodes each time, hence the O(k) factor. Worst case is when k is a factor of n. | <b>Space Complexity:</b> O(1).  We only use constant extra space.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Iterative with Reversal</h5>
  <p>Iterate through the list, identifying groups of k nodes.  Reverse each group and link them together. Keep track of the previous and next group pointers to stitch the reversed groups together. Uses a `reverse` function to reverse a sublist.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* reverseList(ListNode* head, ListNode* tail) {
    ListNode* prev = nullptr;
    ListNode* curr = head;
    ListNode* next = nullptr;

    while (prev != tail) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }

    return prev;
}

ListNode* reverseKGroup(ListNode* head, int k) {
    if (!head || k == 1) return head;

    ListNode* dummy = new ListNode(0);
    dummy->next = head;
    ListNode* prev = dummy;
    ListNode* curr = head;

    while (curr) {
        ListNode* tail = prev;
        // Check if there are k nodes
        for (int i = 0; i &lt k; i++) {
            tail = tail->next;
            if (!tail) {
                return dummy->next;
            }
        }

        ListNode* nextGroup = tail->next;

        // Reverse the group
        ListNode* reversedHead = reverseList(prev->next, tail);

        // Connect to next group
        prev->next->next = nextGroup;
        prev->next = reversedHead;

        prev = prev->next;
        curr = nextGroup;
    }

    return dummy->next;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the number of nodes in the linked list. Each node is visited and potentially reversed once. | <b>Space Complexity:</b> O(1).  We use constant extra space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,2,3,4,5], k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[2,1,4,3,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The list is reversed in groups of 2. The last node remains the same as there are not enough nodes to reverse.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,2,3,4,5], k = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[3,2,1,4,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The list is reversed in groups of 3. The last two nodes remain the same.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [1,2,3,4,5], k = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,3,4,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The list remains unchanged as k is 1.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases include an empty list, k = 1, and the number of nodes not being a multiple of k. Make sure to handle these correctly. The dummy node simplifies handling the head of the reversed list.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/merge-sort-for-linked-list/>Merge Sort for Linked List</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given the head of a singly linked list, sort the list in ascending order using the merge sort algorithm. Merge sort is a divide-and-conquer algorithm that recursively divides the list into smaller sublists, sorts them, and then merges them back together.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Convert the linked list into an array, sort the array, and then reconstruct the linked list from the sorted array.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* bruteForceSort(ListNode* head) {
    if (!head || !head->next) return head; // Empty or single-node list is already sorted

    vector&lt;int&gt; values;
    ListNode* curr = head;
    while (curr) {
        values.push_back(curr->val);
        curr = curr->next;
    }

    sort(values.begin(), values.end());

    curr = head;
    int i = 0;
    while (curr) {
        curr->val = values[i];
        curr = curr->next;
        i++;
    }

    return head;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log n) due to sorting the array, where n is the number of nodes in the linked list. | <b>Space Complexity:</b> O(n) due to the extra space used by the array to store node values.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Merge Sort on Linked List</h5>
  <p>Implement merge sort directly on the linked list. This involves recursively splitting the list into halves, sorting each half, and then merging the sorted halves.  The key steps are: 1) Find the middle of the linked list using slow and fast pointers. 2) Split the list into two halves at the middle. 3) Recursively sort the two halves. 4) Merge the two sorted halves.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* merge(ListNode* left, ListNode* right) {
    ListNode* dummy = new ListNode();
    ListNode* tail = dummy;

    while (left &amp;&amp; right) {
        if (left->val &lt;= right->val) {
            tail->next = left;
            left = left->next;
        }
        else {
            tail->next = right;
            right = right->next;
        }
        tail = tail->next;
    }

    tail->next = (left ? left : right);
    ListNode* result = dummy->next;
    delete dummy;
    return result;
}

ListNode* findMiddle(ListNode* head) {
    if (!head) return nullptr;
    ListNode* slow = head;
    ListNode* fast = head->next;
    while (fast &amp;&amp; fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow;
}

ListNode* mergeSort(ListNode* head) {
    if (!head || !head->next) return head;

    ListNode* middle = findMiddle(head);
    ListNode* nextOfMiddle = middle->next;
    middle->next = nullptr; // Split the list into two halves

    ListNode* left = mergeSort(head);
    ListNode* right = mergeSort(nextOfMiddle);

    return merge(left, right);
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log n), where n is the number of nodes.  The splitting takes O(log n) steps, and the merging takes O(n) time at each level. | <b>Space Complexity:</b> O(log n) due to the recursive call stack.  Each level of recursion splits the list in half.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [4,2,1,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,3,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The list is correctly sorted using merge sort.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = [-1,5,3,4,0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[-1,0,3,4,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The list is correctly sorted with negative numbers.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">head = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">An empty list returns an empty list.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The primary challenge is performing the merge sort operations on a linked list structure directly, which requires careful handling of pointers and memory management. Edge cases involve empty lists, single-node lists, and lists with duplicate values.  The optimized solution avoids creating extra space for intermediate operations, performing the sorting in-place.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/flattening-a-linked-list/>Flattening a Linked List</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given a linked list where each node has two pointers: one to the next node in the list and another to a sub-list which is also a linked list. Your task is to flatten this multi-level linked list into a single-level linked list.  The final list should contain all the nodes from the original list and its sublists, maintaining the original order within each level. Nodes should be linked in the order they appear from top to bottom and left to right.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>This approach involves traversing the main list and recursively flattening each sublist. We can use a helper function to flatten each sublist and then merge it with the flattened main list.  The merging step is crucial and can be done efficiently by maintaining the order.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Node structure for the linked list
struct Node {
    int data;
    Node* next;
    Node* child;
    Node(int val) : data(val), next(nullptr), child(nullptr) {}
};

// Helper function to merge two sorted linked lists
Node* mergeLists(Node* head1, Node* head2) {
    Node* dummy = new Node(0);
    Node* tail = dummy;

    while (head1 && head2) {
        if (head1-&gt;data &lt head2-&gt;data) {
            tail-&gt;next = head1;
            head1 = head1-&gt;next;
        } else {
            tail-&gt;next = head2;
            head2 = head2-&gt;next;
        }
        tail = tail-&gt;next;
    }

    tail-&gt;next = head1 ? head1 : head2;
    Node* result = dummy-&gt;next;
    delete dummy;
    return result;
}

// Recursive function to flatten the linked list
Node* flatten(Node* head) {
    if (!head) return nullptr;

    Node* current = head;
    while (current) {
        if (current-&gt;child) {
            Node* childHead = current-&gt;child;
            Node* nextNode = current-&gt;next;

            // Flatten the child list
            Node* flattenedChild = flatten(childHead);

            // Make the child list as next node of current
            current-&gt;next = flattenedChild;

            // Find the tail of child and connect to next node
            Node* tail = flattenedChild;
            while(tail &amp;&amp; tail-&gt;next) {
                tail = tail-&gt;next;
            }

            if(tail)
                tail-&gt;next = nextNode;

            current-&gt;child = nullptr;
            current = nextNode;
        } else {
            current = current-&gt;next;
        }
    }

    return head;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N*M) in worst-case, where N is the number of nodes in the main list, and M is the maximum number of nodes in any sublist.  The merging process takes O(N+M). The flattening part also involves N traversing operations for the main list and recursive traversal for sublist nodes | <b>Space Complexity:</b> O(1) - if we ignore the space used by recursive calls, otherwise, it can be O(depth of nesting)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Iterative Approach (Modified In-place)</h5>
  <p>This approach iteratively flattens the list without recursion, improving space efficiency. It involves traversing the list and, when encountering a child node, inserting the child list into the main list at the appropriate position.  This is often done by connecting the tail of the child list to the next node and linking the head of child to the current node.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Node structure for the linked list
struct Node {
    int data;
    Node* next;
    Node* child;
    Node(int val) : data(val), next(nullptr), child(nullptr) {}
};

Node* flattenIterative(Node* head) {
    if (!head) return nullptr;

    Node* current = head;

    while (current) {
        if (current-&gt;child) {
            Node* childHead = current-&gt;child;
            Node* tail = childHead;

            // Find the tail of the child list
            while (tail-&gt;next) {
                tail = tail-&gt;next;
            }

            // Connect tail of child to next of current
            tail-&gt;next = current-&gt;next;

            // Connect current to child head
            current-&gt;next = childHead;

            // Remove child pointer
            current-&gt;child = nullptr;
        }
        current = current-&gt;next;
    }
    return head;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the total number of nodes in all lists. | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 with 2-&gt;7-&gt;8 and 3-&gt;9-&gt;10</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1-&gt;2-&gt;7-&gt;8-&gt;3-&gt;9-&gt;10-&gt;4-&gt;5-&gt;6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The child lists are merged into the main list in the correct order.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">5-&gt;10-&gt;19-&gt;28 with 7-&gt;8-&gt;30 and 20-&gt;22, 19 is having 20</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5-&gt;10-&gt;7-&gt;8-&gt;30-&gt;19-&gt;20-&gt;22-&gt;28</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Another example demonstrating the flattening of a multi-level linked list.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1-&gt;2-&gt;3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1-&gt;2-&gt;3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Simple linear list (no child nodes).</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The iterative approach generally performs better in terms of space complexity, avoiding the overhead of recursive calls.
2.  Make sure to handle the cases where the child list is null or when both the main list and child list have only one or no nodes.
3.  The key is to properly link the nodes of child list into main list without losing connection of the remaining nodes.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/subtract-two-numbers-represented-as-linked-lists/>Subtract two numbers represented as linked lists</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given two numbers represented by linked lists, write a function that subtracts the two numbers and returns the result as a linked list.  The numbers are represented such that each node contains a single digit, and the digits are stored in reverse order (units digit at the head of the list). If the second number is larger than the first, return the negative of the result. If the lists are of different lengths, assume the shorter list is padded with leading zeros.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>1. Convert each linked list to an integer. 
2. Subtract the two integers.  Handle the case where the second number is greater than the first to return the negative result. 
3. Convert the result back into a linked list.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

// Helper function to convert a linked list to an integer
long long listToInt(ListNode* head) {
    long long num = 0;
    long long powerOfTen = 1;
    while (head) {
        num += head-&gt;val * powerOfTen;
        powerOfTen *= 10;
        head = head-&gt;next;
    }
    return num;
}

// Helper function to convert an integer to a linked list
ListNode* intToList(long long num) {
    if (num == 0) {
        return new ListNode(0);
    }
    ListNode* head = nullptr;
    ListNode* tail = nullptr;
    if (num &lt 0) {
        num = -num;
    }
    while (num &gt 0) {
        int digit = num % 10;
        ListNode* newNode = new ListNode(digit);
        if (!head) {
            head = newNode;
            tail = newNode;
        } else {
            tail-&gt;next = newNode;
            tail = newNode;
        }
        num /= 10;
    }
    return head;
}

ListNode* subtractListsBruteForce(ListNode* l1, ListNode* l2) {
    long long num1 = listToInt(l1);
    long long num2 = listToInt(l2);

    long long result = num1 - num2;
    
    return intToList(result);
}

// Helper function to print a linked list
void printList(ListNode* head) {
    while (head) {
        cout &lt&lt head-&gt;val &lt&lt " ";
        head = head-&gt;next;
    }
    cout &lt&lt endl;
}
</code></pre>
  <p><b>Time Complexity:</b> O(M + N), where M and N are the lengths of the two linked lists. Conversion to int is O(M) and O(N) respectively, and conversion back to the list is dependent on the magnitude of the result which can be O(max(M,N)) | <b>Space Complexity:</b> O(M + N) to store the integers and the result linked list.  Potentially O(1) if we can modify the original list in place, but typically O(M+N).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Subtraction using reversing and borrowing</h5>
  <p>1. Reverse both linked lists.  This simplifies digit-wise subtraction, handling the least significant digit at the head. 
2. Iterate through the reversed lists, subtracting digits. If the digit in the first list is smaller than the corresponding digit in the second list, borrow from the next digit. 
3. Handle the sign of the result. If the second number was larger, make the result negative (invert the list).
4. Reverse the result list back to the original order.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

// Helper function to reverse a linked list
ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* curr = head;
    ListNode* next = nullptr;

    while (curr) {
        next = curr-&gt;next;
        curr-&gt;next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}

ListNode* subtractListsOptimized(ListNode* l1, ListNode* l2) {
    ListNode* head1 = reverseList(l1);
    ListNode* head2 = reverseList(l2);

    ListNode* resultHead = nullptr;
    ListNode* resultTail = nullptr;
    int borrow = 0;
    bool isNegative = false;

    ListNode* curr1 = head1;
    ListNode* curr2 = head2;

    while (curr1 || curr2 || borrow) {
        int val1 = (curr1) ? curr1-&gt;val : 0;
        int val2 = (curr2) ? curr2-&gt;val : 0;

        int diff = val1 - val2 - borrow;
        if (diff &lt 0) {
            diff += 10;
            borrow = 1;
        } else {
            borrow = 0;
        }

        ListNode* newNode = new ListNode(diff);
        if (!resultHead) {
            resultHead = newNode;
            resultTail = newNode;
        } else {
            resultTail-&gt;next = newNode;
            resultTail = newNode;
        }

        if(curr1) curr1 = curr1-&gt;next;
        if(curr2) curr2 = curr2-&gt;next;
    }
    
    // Remove leading zeros
    while(resultHead &amp;&amp; resultHead-&gt;val == 0 &amp;&amp; resultHead-&gt;next != nullptr){
        ListNode* temp = resultHead;
        resultHead = resultHead-&gt;next;
        delete temp;
    }

    ListNode* finalResult = reverseList(resultHead);
    
    return finalResult;
}

// Helper function to print a linked list
void printList(ListNode* head) {
    while (head) {
        cout &lt&lt head-&gt;val &lt&lt " ";
        head = head-&gt;next;
    }
    cout &lt&lt endl;
}
</code></pre>
  <p><b>Time Complexity:</b> O(M + N) where M and N are lengths of two lists, as we iterate through lists a constant number of times. | <b>Space Complexity:</b> O(1) excluding space for the output linked list (which is O(max(M, N))) or O(M+N) if you consider the space used by reversed lists. Space complexity can be reduced to O(1) if linked lists are modified in-place.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">l1 = 5-&gt;6-&gt;7, l2 = 1-&gt;2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4-&gt;4-&gt;7</td>
        <td style="border: 1px solid #ccc; padding: 6px;">765 - 21 = 744</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">l1 = 1-&gt;0-&gt;0, l2 = 1-&gt;1-&gt;1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-1-&gt;1-&gt;1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">100-111 = -11. List represents -11 using digits in reverse, which is -1->1->1</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">l1 = 1-&gt;0-&gt;0, l2 = 9</td>
        <td style="border: 1px solid #ccc; padding: 6px;">9-&gt;1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">100 - 9 = 91</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">l1 = 0, l2 = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0 - 1 = -1</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. The numbers can have different lengths. Handle leading zeros appropriately. 
2. Be mindful of the sign of the result. If the second number is larger, the result will be negative.
3. Reversing lists is a common technique for this kind of problem and simplifies digit by digit operations.
4. Remove leading zeros from the result.
5. Deal with cases where one or both input lists are empty.</p>
</div>
<hr style="margin: 40px 0;">
<h2>Stacks and Queues</h2>
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/implement-queue-using-stacks/>Implement Queue using Stacks</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Implement a queue using two stacks. The queue should support the standard queue operations: `push` (add an element to the rear), `pop` (remove the element from the front), `peek` (return the element at the front), and `empty` (check if the queue is empty). You are not allowed to use other data structures like linked lists. Standard stack operations are allowed (push, pop, top/peek, and empty).</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Simulate the queue operations using two stacks. For `push`, simply push the element onto the first stack (inStack). For `pop` and `peek`, if the second stack (outStack) is empty, transfer all elements from inStack to outStack. Then, pop/peek from outStack. If outStack is not empty, perform pop/peek directly from outStack. `empty` checks if both stacks are empty.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

class MyQueue {
public:
    stack&lt;int&gt; inStack;
    stack&lt;int&gt; outStack;

    MyQueue() {

    }

    void push(int x) {
        inStack.push(x);
    }

    int pop() {
        peek(); // Ensure the front element is in outStack
        int val = outStack.top();
        outStack.pop();
        return val;
    }

    int peek() {
        if (outStack.empty()) {
            while (!inStack.empty()) {
                outStack.push(inStack.top());
                inStack.pop();
            }
        }
        return outStack.top();
    }

    bool empty() {
        return inStack.empty() &amp;&amp; outStack.empty();
    }
};
</code></pre>
  <p><b>Time Complexity:</b> push: O(1), pop: O(N) worst case (transferring elements), peek: O(N) worst case, empty: O(1), where N is the number of elements in the queue | <b>Space Complexity:</b> O(N) - for storing elements in the stacks</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized using Two Stacks</h5>
  <p>Use two stacks, inStack for push operations and outStack for pop and peek operations. Push elements to inStack. When pop or peek is called, if outStack is empty, transfer elements from inStack to outStack. This ensures that the front element is always at the top of outStack. This approach reduces the amortized time complexity of pop and peek.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

class MyQueue {
public:
    stack&lt;int&gt; inStack;
    stack&lt;int&gt; outStack;

    MyQueue() {

    }

    void push(int x) {
        inStack.push(x);
    }

    int pop() {
        if (outStack.empty()) {
            while (!inStack.empty()) {
                outStack.push(inStack.top());
                inStack.pop();
            }
        }
        int val = outStack.top();
        outStack.pop();
        return val;
    }

    int peek() {
        if (outStack.empty()) {
            while (!inStack.empty()) {
                outStack.push(inStack.top());
                inStack.pop();
            }
        }
        return outStack.top();
    }

    bool empty() {
        return inStack.empty() &amp;&amp; outStack.empty();
    }
};
</code></pre>
  <p><b>Time Complexity:</b> push: O(1), pop: O(1) (amortized), peek: O(1) (amortized), empty: O(1) | <b>Space Complexity:</b> O(N)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[null, null, null, 1, 1, false]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">MyQueue myQueue = new MyQueue();
myQueue.push(1);
myQueue.push(2);
myQueue.peek(); // return 1
myQueue.pop(); // return 1
myQueue.empty(); // return false</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["MyQueue", "push", "push", "pop", "peek", "empty"]
[[], [1], [2], [], [], []]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[null, null, null, 1, 2, false]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">MyQueue myQueue = new MyQueue();
myQueue.push(1);
myQueue.push(2);
myQueue.pop(); // return 1
myQueue.peek(); // return 2
myQueue.empty(); // return false</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["MyQueue", "push", "pop", "peek", "pop", "empty"]
[[], [1], [], [], [], []]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[null, null, 1, 1, 1, true]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">MyQueue myQueue = new MyQueue();
myQueue.push(1);
myQueue.pop();
myQueue.peek();
myQueue.pop();
myQueue.empty();</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key is to ensure that the front element of the queue is always accessible efficiently. The use of two stacks allows us to manage the order of elements for push, pop, and peek operations. Amortized time complexity means that although a single pop or peek operation might take O(N) (transferring elements), the average time complexity over many operations is O(1).</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/backspace-string-compare/>Backspace String Compare</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character. 

Note that after backspacing an empty text, the text will still be empty.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Simulate the backspace operations for each string. Iterate through each string, maintaining a resulting string. If a character is not '#', append it to the resulting string. If it's '#', remove the last character from the resulting string (if not empty). Finally, compare the two resulting strings.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string processString(string s) {
    string result = "";
    for (char c : s) {
        if (c == '#') {
            if (!result.empty()) {
                result.pop_back();
            }
        } else {
            result.push_back(c);
        }
    }
    return result;
}

bool backspaceCompare_bruteforce(string s, string t) {
    return processString(s) == processString(t);
}
</code></pre>
  <p><b>Time Complexity:</b> O(m + n), where m and n are the lengths of strings s and t respectively. Processing each string takes O(m) or O(n) time. The comparison of the resulting strings takes O(min(m, n)). | <b>Space Complexity:</b> O(m + n) in the worst case, where m and n are the lengths of strings s and t. This is due to the space required to store the processed strings.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Two Pointers (Optimized)</h5>
  <p>Iterate from the end of both strings, and use two pointers. Keep track of the number of backspaces encountered. If a character is not '#' and the backspace count is zero, then compare the current characters. If the characters don't match or we've reached the end of one string before the other, the strings don't match. If it's a '#', increment the backspace count. If it's not '#' and the backspace count is greater than 0, decrement the backspace count, and skip this character. Continue processing until both pointers reach the beginning of strings.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool backspaceCompare_optimized(string s, string t) {
    int i = s.length() - 1, j = t.length() - 1;
    int skipS = 0, skipT = 0;

    while (i &gt;= 0 || j &gt;= 0) {
        // Process string s
        while (i &gt;= 0) {
            if (s[i] == '#') {
                skipS++;
                i--;
            } else if (skipS &gt; 0) {
                skipS--;
                i--;
            } else {
                break;
            }
        }

        // Process string t
        while (j &gt;= 0) {
            if (t[j] == '#') {
                skipT++;
                j--;
            } else if (skipT &gt; 0) {
                skipT--;
                j--;
            } else {
                break;
            }
        }

        // Compare characters
        if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; s[i] != t[j]) {
            return false;
        }

        if ((i &gt;= 0) != (j &gt;= 0)) {
            return false;
        }

        i--;
        j--;
    }

    return true;
}
</code></pre>
  <p><b>Time Complexity:</b> O(m + n), where m and n are the lengths of strings s and t. We iterate through the strings at most once. | <b>Space Complexity:</b> O(1). We use a constant amount of extra space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "ab#c", t = "ad#c"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Both strings become "ac" after processing backspaces.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "ab##", t = "c#d#"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Both strings become "" after processing backspaces.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "a#c", t = "b"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The strings become "c" and "b" respectively.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "y#fo##f", t = "y#f#o##f"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Both strings become "f" after processing backspaces.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Consider edge cases such as multiple consecutive backspace characters (e.g., "a###") and strings with backspace characters at the beginning, potentially resulting in an empty string.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/implement-stack-using-queues/>Implement Stack using Queues</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Implement a stack using two queues. You need to support the usual stack operations: push, pop, top, and empty. All operations should be done in amortized O(1) time complexity.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>In this approach, we use two queues. The push operation is straightforward, adding the element to the first queue.  For pop, we move all elements from the first queue to the second queue except for the last one. The last element is then the top element, which we pop. We then swap the two queues to maintain the order. For top, we do a similar operation as pop, but instead of popping, we return the top element after moving the other elements to the other queue.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

class MyStack {
private:
    queue&lt;int&gt; q1, q2;

public:
    MyStack() {

    }

    void push(int x) {
        q1.push(x);
    }

    int pop() {
        while (q1.size() &gt 1) {
            q2.push(q1.front());
            q1.pop();
        }
        int top = q1.front();
        q1.pop();
        swap(q1, q2);
        return top;
    }

    int top() {
        while (q1.size() &gt 1) {
            q2.push(q1.front());
            q1.pop();
        }
        int top = q1.front();
        q2.push(q1.front());
        q1.pop();
        swap(q1, q2);
        return top;
    }

    bool empty() {
        return q1.empty();
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n) for pop and top operations, O(1) for push and empty operations, where n is the number of elements in the stack. | <b>Space Complexity:</b> O(n), where n is the number of elements stored in the stack.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Solution with Two Queues</h5>
  <p>We use two queues, q1 and q2. Push operation is simple. For pop, we move all elements from q1 to q2 except the last one, pop the last element from q1, and then swap q1 and q2. The top operation is similar to pop but returns the top element without removing it. This gives us an amortized O(1) for all operations.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

class MyStack {
private:
    queue&lt;int&gt; q1, q2;

public:
    MyStack() {

    }

    void push(int x) {
        q1.push(x);
    }

    int pop() {
        while (q1.size() &gt 1) {
            q2.push(q1.front());
            q1.pop();
        }
        int top = q1.front();
        q1.pop();
        swap(q1, q2);
        return top;
    }

    int top() {
        while (q1.size() &gt 1) {
            q2.push(q1.front());
            q1.pop();
        }
        int top = q1.front();
        q2.push(q1.front());
        q1.pop();
        swap(q1, q2);
        return top;
    }

    bool empty() {
        return q1.empty();
    }
};
</code></pre>
  <p><b>Time Complexity:</b> Amortized O(1) for push, pop and top. O(1) for empty.  The amortized comes from the fact that pop and top move n-1 elements, but this cost is spread out over multiple operations. | <b>Space Complexity:</b> O(n) to store stack elements.</p>
  <h5>‚û§ Optimized Solution with One Queue</h5>
  <p>We can achieve amortized O(1) push operation by using only one queue. The `push` operation is the bottleneck. We first enqueue the new element, then move all existing elements in the queue *after* this element. This effectively reverses the order.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

class MyStack {
private:
    queue&lt;int&gt; q;

public:
    MyStack() {

    }

    void push(int x) {
        q.push(x);
        for (int i = 0; i &lt q.size() - 1; ++i) {
            q.push(q.front());
            q.pop();
        }
    }

    int pop() {
        int top = q.front();
        q.pop();
        return top;
    }

    int top() {
        return q.front();
    }

    bool empty() {
        return q.empty();
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n) for push operation, O(1) for pop, top, and empty operations.  Push involves moving all existing elements of the queue. | <b>Space Complexity:</b> O(n) to store the elements.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[null, null, null, 2, 2, false]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">MyStack stack = new MyStack();
stack.push(1);
stack.push(2);
stack.top(); // return 2
stack.pop(); // return 2
stack.empty(); // return false</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["MyStack", "push", "push", "pop", "top", "empty"]
[[], [1], [2], [], [], []]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[null, null, null, 2, 1, false]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Creates a stack and pushes elements, pops, and then checks top and emptiness.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The main challenge is to maintain the LIFO (Last-In, First-Out) property of a stack using FIFO (First-In, First-Out) queues. The choice of one queue or two queues impacts the time complexity of push or other operations. The amortized analysis is important, as individual pop or top operations might be O(n), but overall, the time complexity is considered amortized O(1).</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/implement-stack-queue-using-deque/>Implement Stack and Queue using Deque</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Implement a Stack and a Queue data structure using the Deque (Double-Ended Queue) data structure. You should implement the standard stack and queue operations, i.e., push, pop, peek/top, and enqueue, dequeue, peek/front. The Deque is the only allowed underlying data structure.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Both Stack and Queue can be implemented using a Deque. For stack, we can use either the front or the back of deque to perform push and pop operations. For queue, we can use one end for enqueue and the other for dequeue. This approach leverages the flexibility of Deque to simulate the behaviors of both stack and queue.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

// Implementing Stack using Deque
class Stack {
private:
    deque&ltint&gt dq;
public:
    void push(int data) {
        dq.push_back(data);
    }
    int pop() {
        if (dq.empty()) {
            cout &lt&lt "Stack is empty\n";
            return -1;  // Or throw an exception
        }
        int val = dq.back();
        dq.pop_back();
        return val;
    }
    int top() {
        if (dq.empty()) {
            cout &lt&lt "Stack is empty\n";
            return -1;  // Or throw an exception
        }
        return dq.back();
    }
    bool isEmpty() {
        return dq.empty();
    }
};

// Implementing Queue using Deque
class Queue {
private:
    deque&ltint&gt dq;
public:
    void enqueue(int data) {
        dq.push_back(data);
    }
    int dequeue() {
        if (dq.empty()) {
            cout &lt&lt "Queue is empty\n";
            return -1;  // Or throw an exception
        }
        int val = dq.front();
        dq.pop_front();
        return val;
    }
    int front() {
        if (dq.empty()) {
            cout &lt&lt "Queue is empty\n";
            return -1;  // Or throw an exception
        }
        return dq.front();
    }
    bool isEmpty() {
        return dq.empty();
    }
};

// int main() {
//     // Example usage for Stack
//     Stack s;
//     s.push(10);
//     s.push(20);
//     s.push(30);
//     cout &lt&lt "Top: " &lt&lt s.top() &lt&lt endl; // Output: 30
//     cout &lt&lt "Pop: " &lt&lt s.pop() &lt&lt endl; // Output: 30
//     cout &lt&lt "Top: " &lt&lt s.top() &lt&lt endl; // Output: 20

//     // Example usage for Queue
//     Queue q;
//     q.enqueue(1);
//     q.enqueue(2);
//     q.enqueue(3);
//     cout &lt&lt "Front: " &lt&lt q.front() &lt&lt endl; // Output: 1
//     cout &lt&lt "Dequeue: " &lt&lt q.dequeue() &lt&lt endl; // Output: 1
//     cout &lt&lt "Front: " &lt&lt q.front() &lt&lt endl; // Output: 2
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(1) for all stack and queue operations (push, pop, enqueue, dequeue, top/peek, front). | <b>Space Complexity:</b> O(N), where N is the number of elements in the stack or queue.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Using Deque for Stack and Queue</h5>
  <p>This approach directly uses the Deque to implement Stack and Queue.  For Stack, push and pop operations are done at the back of the deque.  For Queue, enqueue is performed at the back and dequeue at the front of the deque.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

// Implementing Stack using Deque
class Stack {
private:
    deque&ltint&gt dq;
public:
    void push(int data) {
        dq.push_back(data);
    }
    int pop() {
        if (dq.empty()) {
            cout &lt&lt "Stack is empty\n";
            return -1;  // Or throw an exception
        }
        int val = dq.back();
        dq.pop_back();
        return val;
    }
    int top() {
        if (dq.empty()) {
            cout &lt&lt "Stack is empty\n";
            return -1;  // Or throw an exception
        }
        return dq.back();
    }
    bool isEmpty() {
        return dq.empty();
    }
};

// Implementing Queue using Deque
class Queue {
private:
    deque&ltint&gt dq;
public:
    void enqueue(int data) {
        dq.push_back(data);
    }
    int dequeue() {
        if (dq.empty()) {
            cout &lt&lt "Queue is empty\n";
            return -1;  // Or throw an exception
        }
        int val = dq.front();
        dq.pop_front();
        return val;
    }
    int front() {
        if (dq.empty()) {
            cout &lt&lt "Queue is empty\n";
            return -1;  // Or throw an exception
        }
        return dq.front();
    }
    bool isEmpty() {
        return dq.empty();
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(1) for all operations. | <b>Space Complexity:</b> O(N), where N is the number of elements.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">Stack: push(1), push(2), push(3), pop(), top(), pop(), pop(), pop()</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Top: 3, Pop: 3, Top: 2, Pop: 2, Pop: 1, Stack is empty, Pop: -1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Demonstrates the stack operations. push adds elements, pop removes the top, and top retrieves the top element.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">Queue: enqueue(1), enqueue(2), enqueue(3), dequeue(), front(), dequeue(), dequeue(), dequeue()</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Front: 1, Dequeue: 1, Front: 2, Dequeue: 2, Dequeue: 3, Queue is empty, Dequeue: -1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Demonstrates the queue operations. enqueue adds elements at the rear, dequeue removes from the front, and front retrieves the front element.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">Stack: push(5), push(10), top(), isEmpty(), pop(), isEmpty()
Queue: enqueue(5), enqueue(10), front(), isEmpty(), dequeue(), isEmpty()</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Top: 10, isEmpty: false, Pop: 10, isEmpty: false
Front: 5, isEmpty: false, Dequeue: 5, isEmpty: false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Combined example showing both data structures' operations and checks for empty state.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The key is to use the `push_back()` and `pop_back()` methods for stack and `push_back()` and `pop_front()` methods for queue using the Deque.
2.  Handle the empty stack/queue case appropriately to avoid errors (e.g., returning -1 or throwing an exception).
3.  Use the `front()` method of the deque to get the front element of the queue, and the `back()` to get the top element of the stack.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/next-greater-element-i/>Next Greater Element I</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given two arrays `nums1` and `nums2` where `nums1` is a subset of `nums2`, find the next greater element for each element in `nums1` in `nums2`. The next greater element of a number `x` in `nums1` is the first greater number to its right in `nums2`. If it does not exist, return -1 for this number.

For example: nums1 = [4,1,2], nums2 = [1,3,4,2].  The output should be [-1, 3, -1]. Because for 4, the next greater element in nums2 does not exist. For 1, the next greater element is 3. For 2, the next greater element does not exist.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through `nums1`. For each element in `nums1`, search for its index in `nums2`. Then, iterate through the portion of `nums2` to the right of this index to find the first element that is greater than the current element in `nums1`. If no such element is found, the next greater element is -1.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

vector&lt;int&gt; bruteForce(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
    vector&lt;int&gt; result(nums1.size(), -1);
    for (int i = 0; i &lt; nums1.size(); ++i) {
        int num1 = nums1[i];
        int index2 = -1;
        for (int j = 0; j &lt; nums2.size(); ++j) {
            if (nums2[j] == num1) {
                index2 = j;
                break;
            }
        }
        if (index2 != -1) {
            for (int j = index2 + 1; j &lt; nums2.size(); ++j) {
                if (nums2[j] &gt; num1) {
                    result[i] = nums2[j];
                    break;
                }
            }
        }
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(m * n), where m is the size of nums1 and n is the size of nums2. | <b>Space Complexity:</b> O(1) - excluding the space required for the result vector.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized using Stack and Hash Map</h5>
  <p>Use a stack to keep track of the elements in `nums2` that have not found their next greater element yet.  Use a hash map to store the next greater element for each element in `nums2`. Iterate through `nums2`. If the current element is greater than the element at the top of the stack, then the current element is the next greater element for the top element of the stack. Pop the stack until the top element is no longer smaller than the current element, assigning the current element as the next greater element for all popped elements. After processing `nums2`, iterate through `nums1` and look up the next greater element in the hash map.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

vector&lt;int&gt; optimizedSolution(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
    unordered_map&lt;int, int&gt; nextGreater;
    stack&lt;int&gt; st;
    for (int num : nums2) {
        while (!st.empty() &amp;&amp; num &gt; st.top()) {
            nextGreater[st.top()] = num;
            st.pop();
        }
        st.push(num);
    }
    while (!st.empty()) {
        nextGreater[st.top()] = -1;
        st.pop();
    }

    vector&lt;int&gt; result(nums1.size());
    for (int i = 0; i &lt; nums1.size(); ++i) {
        result[i] = nextGreater[nums1[i]];
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(m + n), where m is the size of nums1 and n is the size of nums2. | <b>Space Complexity:</b> O(n) - for the hash map and the stack, in the worst case where all elements are in decreasing order.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums1 = [4,1,2], nums2 = [1,3,4,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[-1,3,-1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">For 4, there is no next greater element in nums2. For 1, the next greater element is 3. For 2, there is no next greater element.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums1 = [2,4], nums2 = [1,2,3,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[3,-1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">For 2, the next greater element is 3. For 4, there is no next greater element.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums1 = [1,3,5,2,4], nums2 = [6,5,4,3,2,1,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[7,7,7,7,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">For each element in nums1 the next greater element is 7</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The constraint that `nums1` is a subset of `nums2` is crucial.  This allows us to focus on finding the next greater element only for the values present in `nums1`.  The optimized solution using a stack is efficient because it processes each element of `nums2` only once.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/stack-set-4-evaluation-postfix-expression/>Stack Set 4 | Evaluation of Postfix Expression</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given a postfix expression, evaluate the expression and return the result. Postfix expressions are a way of writing mathematical expressions where the operators follow their operands. For example, the infix expression `2 + 3` would be written as `2 3 +` in postfix notation.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach iterates through the postfix expression. If an operand is encountered, it's pushed onto a stack. If an operator is encountered, the top two operands are popped from the stack, the operation is performed, and the result is pushed back onto the stack.  This continues until the end of the expression. The final result remains on top of the stack.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;cctype&gt; // for isdigit

using namespace std;

int evaluatePostfix(const string& expression) {
    stack&lt;int&gt; operands;

    for (char c : expression) {
        if (isdigit(c)) {
            operands.push(c - '0'); // Convert char to int
        } else if (c != ' ') {
            int operand2 = operands.top();
            operands.pop();
            int operand1 = operands.top();
            operands.pop();

            switch (c) {
                case '+':
                    operands.push(operand1 + operand2);
                    break;
                case '-':
                    operands.push(operand1 - operand2);
                    break;
                case '*':
                    operands.push(operand1 * operand2);
                    break;
                case '/':
                    operands.push(operand1 / operand2);
                    break;
                default:
                    // Handle invalid operator
                    cerr &lt;&lt; "Invalid operator: " &lt;&lt; c &lt;&lt; endl;
                    return -1; // Or throw an exception
            }
        }
    }

    return operands.top();
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the length of the postfix expression.  Each character is visited once. | <b>Space Complexity:</b> O(n), in the worst case, where n is the number of operands.  The stack might need to store all operands if the expression consists of many operands followed by a single operator.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Stack-based Evaluation</h5>
  <p>This is the same approach as the brute-force method, which is already an optimal solution in this case. The core idea is to use a stack to store operands and perform operations based on the encountered operators. It directly follows the rules of postfix expression evaluation.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;cctype&gt; // for isdigit

using namespace std;

int evaluatePostfix(const string& expression) {
    stack&lt;int&gt; operands;

    for (char c : expression) {
        if (isdigit(c)) {
            operands.push(c - '0'); // Convert char to int
        } else if (c != ' ') {
            int operand2 = operands.top();
            operands.pop();
            int operand1 = operands.top();
            operands.pop();

            switch (c) {
                case '+':
                    operands.push(operand1 + operand2);
                    break;
                case '-':
                    operands.push(operand1 - operand2);
                    break;
                case '*':
                    operands.push(operand1 * operand2);
                    break;
                case '/':
                    operands.push(operand1 / operand2);
                    break;
                default:
                    // Handle invalid operator
                    cerr &lt;&lt; "Invalid operator: " &lt;&lt; c &lt;&lt; endl;
                    return -1; // Or throw an exception
            }
        }
    }

    return operands.top();
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the length of the postfix expression. | <b>Space Complexity:</b> O(n), in the worst case. This is determined by the maximum depth of the stack, which can potentially store all operands.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">2 3 +</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2 and 3 are pushed. + pops 3 and 2, calculates 2 + 3 = 5, and pushes 5.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">2 3 4 + *</td>
        <td style="border: 1px solid #ccc; padding: 6px;">14</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2, 3, and 4 are pushed. + pops 4 and 3, calculates 3 + 4 = 7, pushes 7. * pops 7 and 2, calculates 2 * 7 = 14, and pushes 14.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">10 2 / 3 *</td>
        <td style="border: 1px solid #ccc; padding: 6px;">15</td>
        <td style="border: 1px solid #ccc; padding: 6px;">10 and 2 are pushed. / pops 2 and 10, calculates 10 / 2 = 5, pushes 5.  3 is pushed. * pops 3 and 5, calculates 5 * 3 = 15, pushes 15.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">5 1 2 + 4 * + 3 -</td>
        <td style="border: 1px solid #ccc; padding: 6px;">14</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 + 2 = 3, then 3 * 4 = 12, then 5 + 12 = 17, then 17 - 3 = 14</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Important edge cases to consider:

1.  **Invalid expressions:** Expressions might contain invalid characters (e.g., letters when only numbers are allowed) or have an incorrect number of operands/operators, or division by zero.
2.  **Handling spaces:**  The input string may contain spaces. The code must handle these correctly, typically by skipping them.
3.  **Operator precedence:** Postfix notation avoids operator precedence issues because operators are always applied to the preceding operands.
4.  **Integer overflow/underflow:** While not usually a major concern for this problem, very large intermediate results might lead to integer overflow or underflow. In a production environment, consider using `long long` or similar types to handle a larger range of numbers, or consider input validation to guard against the issue. Also consider potential division by zero errors when handling the `/` operator.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/implement-two-stacks-in-an-array/>Implement two stacks in an array</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Implement two stacks in a single array. You need to implement the following functions:

1.  `push1(int x)`: Push element x into stack 1.
2.  `push2(int x)`: Push element x into stack 2.
3.  `pop1()`: Pop an element from stack 1 and return it.
4.  `pop2()`: Pop an element from stack 2 and return it.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach would be to use two separate arrays to represent the two stacks. This, however, defeats the purpose of the problem. Another way is to simply use the same array and store both the stacks in it.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class TwoStacks {
private:
    int *arr;
    int size;
    int top1, top2;

public:
    // Constructor
    TwoStacks(int n) {
        size = n;
        arr = new int[n];
        top1 = -1; // Stack 1 is empty
        top2 = n; // Stack 2 is empty
    }

    // Push element x into stack 1
    void push1(int x) {
        if (top1 &lt top2 - 1) {
            top1++;
            arr[top1] = x;
        } else {
            cout &lt&lt "Stack Overflow" &lt&lt endl;
            return;
        }
    }

    // Push element x into stack 2
    void push2(int x) {
        if (top1 &lt top2 - 1) {
            top2--;
            arr[top2] = x;
        } else {
            cout &lt&lt "Stack Overflow" &lt&lt endl;
            return;
        }
    }

    // Pop an element from stack 1 and return it
    int pop1() {
        if (top1 &gt= 0) {
            int val = arr[top1];
            top1--;
            return val;
        } else {
            cout &lt&lt "Stack Underflow" &lt&lt endl;
            return -1;
        }
    }

    // Pop an element from stack 2 and return it
    int pop2() {
        if (top2 &lt size) {
            int val = arr[top2];
            top2++;
            return val;
        } else {
            cout &lt&lt "Stack Underflow" &lt&lt endl;
            return -1;
        }
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(1) for all operations (push1, push2, pop1, pop2). | <b>Space Complexity:</b> O(N), where N is the size of the array.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach</h5>
  <p>Use a single array and two pointers, `top1` and `top2`. Initialize `top1` to -1 and `top2` to the size of the array.  Stack 1 grows from the beginning of the array, and stack 2 grows from the end towards the beginning.  `push1` increments `top1` and inserts the element.  `push2` decrements `top2` and inserts the element.  `pop1` returns the element at `top1` and decrements `top1`.  `pop2` returns the element at `top2` and increments `top2`.  Handle overflow/underflow conditions appropriately.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class TwoStacks {
private:
    int *arr;
    int size;
    int top1, top2;

public:
    // Constructor
    TwoStacks(int n) {
        size = n;
        arr = new int[n];
        top1 = -1; // Stack 1 is empty
        top2 = n; // Stack 2 is empty
    }

    // Push element x into stack 1
    void push1(int x) {
        if (top1 &lt top2 - 1) {
            top1++;
            arr[top1] = x;
        } else {
            cout &lt&lt "Stack Overflow" &lt&lt endl;
            return;
        }
    }

    // Push element x into stack 2
    void push2(int x) {
        if (top1 &lt top2 - 1) {
            top2--;
            arr[top2] = x;
        } else {
            cout &lt&lt "Stack Overflow" &lt&lt endl;
            return;
        }
    }

    // Pop an element from stack 1 and return it
    int pop1() {
        if (top1 &gt= 0) {
            int val = arr[top1];
            top1--;
            return val;
        } else {
            cout &lt&lt "Stack Underflow" &lt&lt endl;
            return -1;
        }
    }

    // Pop an element from stack 2 and return it
    int pop2() {
        if (top2 &lt size) {
            int val = arr[top2];
            top2++;
            return val;
        } else {
            cout &lt&lt "Stack Underflow" &lt&lt endl;
            return -1;
        }
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(1) for all operations (push1, push2, pop1, pop2). | <b>Space Complexity:</b> O(N), where N is the size of the array.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">size = 5
push1(1)
push2(2)
push1(3)
pop1()
pop2()</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Initially, top1 = -1, top2 = 5.
push1(1): arr[0] = 1, top1 = 0
push2(2): arr[4] = 2, top2 = 4
push1(3): arr[1] = 3, top1 = 1
pop1(): returns 3, top1 = 0
pop2(): returns 2, top2 = 5</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">size = 3
push1(1)
push1(2)
push1(3)</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Stack Overflow</td>
        <td style="border: 1px solid #ccc; padding: 6px;">When stack 1 attempts to push the third element while the array is full</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">size = 3
push1(1)
push2(2)
pop1()
pop2()
pop1()</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 Stack Underflow</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Push 1, push 2, then pop both. Afterwards stack 1 will underflow.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Important edge cases include handling stack overflow (when both stacks are full) and stack underflow (when trying to pop from an empty stack).  The solution assumes a fixed size array.  The `top1 &lt top2 - 1` condition in `push1` and `push2` prevents overlap.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/>Minimum Cost Tree From Leaf Values</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an array `arr` of positive integers, where `arr[i]` represents the value of each leaf in an inorder traversal of a binary tree. The cost of a non-leaf node is the product of the largest leaf value in its left subtree and the largest leaf value in its right subtree. Find the minimum sum of the values of all non-leaf nodes of such a binary tree. Note: The number of nodes in the tree is at most the length of the array.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach tries all possible binary trees that can be formed from the given leaf values.  For each possible tree structure, calculate the cost (sum of products of non-leaf node values) and find the minimum among all the calculated costs. This involves generating all possible binary tree structures and evaluating the cost of each one. This approach is highly inefficient.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// This approach is fundamentally flawed and very hard to implement efficiently for brute-force.
// Instead, a recursive approach with memoization will be significantly more efficient.
// This code is a placeholder, as it is not feasible to implement brute force efficiently for this problem.

int calculate_cost(const vector&lt;int&gt;& arr, const vector&lt;int&gt;& inorder) {
    // Placeholder:  In a real brute-force, this would involve traversing the tree structure.
    return 0; 
}

int brute_force(vector&lt;int&gt;& arr) {
    if (arr.size() &lt= 1) return 0;
    int min_cost = INT_MAX;

    // Generate all possible trees (very difficult efficiently).
    // For each tree, calculate cost and update min_cost.

    return min_cost;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N!), where N is the size of the input array. This is because generating all possible binary tree structures is computationally very expensive. The actual time complexity is far worse than factorial, as it involves generating tree structures and then traversing them. | <b>Space Complexity:</b> O(N) due to the recursive calls and auxiliary space used to construct the tree structures (although highly variable and hard to define precisely).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming with Monotonic Stack (Optimized)</h5>
  <p>This approach uses dynamic programming to optimize the process of forming the binary tree. It leverages a monotonic stack to efficiently determine the optimal structure.  For each subarray `arr[i...j]`, we want to find the minimum cost. Consider the maximum element `arr[k]` within `arr[i...j]`. This element forms the root of the subtree. The left and right subtrees consist of `arr[i...k-1]` and `arr[k+1...j]` respectively. We split the problem into smaller subproblems and use the following observations. The cost is determined by the product of max values of its child, and we must use all leaf nodes as values. The key is to find the best way to arrange the numbers to minimize the overall cost. We can use a monotonic stack to determine the root elements of the subtrees efficiently. Iteratively process the array. The approach dynamically computes the optimal cost for each possible subarray and avoids redundant calculations.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int mctFromLeafValues(vector&lt;int&gt;& arr) {
    int n = arr.size();
    int cost = 0;
    stack&lt;int&gt; st;
    st.push(INT_MAX);  // Sentinel value for the left boundary

    for (int val : arr) {
        while (st.top() &lt= val) {
            int mid = st.top();
            st.pop();
            cost += mid * min(st.top(), val); // Cost of this non-leaf node.
        }
        st.push(val);
    }

    while (st.size() &gt 2) {
        int top = st.top();
        st.pop();
        cost += top * st.top(); //Remaining non-leaf node costs
    }

    return cost;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the size of the input array. Each element is pushed and popped from the stack at most once. | <b>Space Complexity:</b> O(N) due to the stack.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[6,2,4]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">32</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There are two possible trees.  
1.  The root is 6, the left subtree has leaves [2], the right subtree has leaves [4].  Cost: 2 * 4 = 8.
2.  The root is 4, the left subtree has leaves [6,2], the right subtree has no leaves.  Cost: 6 * 2 = 12
 The only possible arrangement to generate non-leaf nodes is:
 2 * 6 + 4 * 6 = 8+24 =32</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[4,11,15,1,5,3]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">164</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Minimum cost tree arrangement is obtained with the given arrangement.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Key considerations include: Using a monotonic stack to maintain a monotonically decreasing sequence of leaf values, which helps in determining the optimal structure to minimize the product of nodes values. When a value is popped, the cost is updated by multiplying the popped element with the smaller of its left and right neighbors. When a value is pushed, it's placed into the stack to potentially be used as a root.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/daily-temperatures/>Daily Temperatures</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an array of integers `temperatures` representing the daily temperatures, return an array `answer` such that `answer[i]` is the number of days you have to wait after the `ith` day to get a warmer temperature. If there is no future day for which this is possible, keep `answer[i]` as `0` instead.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the `temperatures` array. For each day `i`, iterate through the remaining days `j` (from `i+1` to the end) to find the first day `j` where `temperatures[j] > temperatures[i]`. The difference `j - i` is the waiting days. If no such day is found, the waiting days are 0.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

string convert_to_string(vector&lt;int&gt; arr) {
    string res = "[";
    for (int i = 0; i &lt arr.size(); ++i) {
        res += to_string(arr[i]);
        if (i != arr.size() - 1) {
            res += ", ";
        }
    }
    res += "]";
    return res;
}

string convert_to_string(int num) {
  return to_string(num);
}


string convert_to_string(bool b) {
    return b ? "true" : "false";
}



class Solution {
public:
    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) {
        int n = temperatures.size();
        vector&lt;int&gt; answer(n, 0);

        for (int i = 0; i &lt n; ++i) {
            for (int j = i + 1; j &lt n; ++j) {
                if (temperatures[j] &gt temperatures[i]) {
                    answer[i] = j - i;
                    break;
                }
            }
        }
        return answer;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n^2), where n is the number of days. Nested loops iterate through the array. | <b>Space Complexity:</b> O(1), as we are only using the output array.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Using Stack</h5>
  <p>Use a stack to store the indices of the days. Iterate through the `temperatures` array. For each day `i`, while the stack is not empty and the temperature of the day at the top of the stack is less than the temperature of the current day `i`, pop the index from the stack and calculate the waiting days as `i - index`. Push the current day's index `i` onto the stack. After the loop finishes, if there are any indices left in the stack, it means there were no warmer temperatures for those days.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

string convert_to_string(vector&lt;int&gt; arr) {
    string res = "[";
    for (int i = 0; i &lt arr.size(); ++i) {
        res += to_string(arr[i]);
        if (i != arr.size() - 1) {
            res += ", ";
        }
    }
    res += "]";
    return res;
}

string convert_to_string(int num) {
  return to_string(num);
}


string convert_to_string(bool b) {
    return b ? "true" : "false";
}


class Solution {
public:
    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) {
        int n = temperatures.size();
        vector&lt;int&gt; answer(n, 0);
        stack&lt;int&gt; s;

        for (int i = 0; i &lt n; ++i) {
            while (!s.empty() &amp;&amp; temperatures[i] &gt temperatures[s.top()]) {
                int prev_index = s.top();
                s.pop();
                answer[prev_index] = i - prev_index;
            }
            s.push(i);
        }
        return answer;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the number of days. Each element is pushed onto the stack and popped from the stack at most once. | <b>Space Complexity:</b> O(n), in the worst case, the stack might contain all the indices if the temperatures are in decreasing order.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">temperatures = [73,74,75,71,69,72,76,73]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,1,4,2,1,1,0,0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">For example, on day 0, the temperature is 73, and the next warmer temperature is on day 1 (74). On day 1, the next warmer temperature is on day 2 (75). On day 2, the next warmer temperature is on day 6 (76), and so on.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">temperatures = [30,40,50,60]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,1,1,0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Each day, the next warmer temperature is found on the next day, except for the last day.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">temperatures = [30,60,90]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,1,0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The next warmer temperature for the first two days are on the next day.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The stack approach provides an efficient solution by keeping track of potential days waiting for a warmer temperature. Key considerations include the case when a warmer temperature is not found for a day (results in a 0 wait) and the case where the temperatures are monotonically decreasing. The use of stack helps to optimize the search for next warmer temperatures compared to the brute force solution.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/distance-of-nearest-cell-having-1-1587115620/1>Distance of nearest cell having 1</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a matrix of integers, where each cell represents either a land cell (0) or a water cell (1).  The task is to calculate the distance of the nearest water cell (1) for every land cell (0). The distance between two cells (r1, c1) and (r2, c2) is calculated as |r1 - r2| + |c1 - c2| (Manhattan Distance).</p>

  <h4>üß† Brute Force Approach</h4>
  <p>For each cell containing 0, iterate through the entire matrix and find the minimum distance to any cell containing 1.  This involves calculating the Manhattan distance between the current cell (0) and all cells (1) and taking the minimum.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

vector&lt;vector&lt;int&gt;&gt; nearest(vector&lt;vector&lt;int&gt;&gt; &amp;grid) {
    int rows = grid.size();
    int cols = grid[0].size();
    vector&lt;vector&lt;int&gt;&gt; result(rows, vector&lt;int&gt;(cols, INT_MAX));

    // Iterate through each cell
    for (int i = 0; i &lt; rows; ++i) {
        for (int j = 0; j &lt; cols; ++j) {
            // If it's a land cell (0)
            if (grid[i][j] == 0) {
                int minDistance = INT_MAX;
                // Iterate through all cells to find nearest water cell (1)
                for (int r = 0; r &lt; rows; ++r) {
                    for (int c = 0; c &lt; cols; ++c) {
                        if (grid[r][c] == 1) {
                            int distance = abs(i - r) + abs(j - c);
                            minDistance = min(minDistance, distance);
                        }
                    }
                }
                result[i][j] = minDistance;
            } else {
                // If it's a water cell (1), distance is 0
                result[i][j] = 0;
            }
        }
    }

    // Handle case where no water cell is present - set all zeros to -1 if necessary.
    for (int i = 0; i &lt; rows; ++i) {
        for (int j = 0; j &lt; cols; ++j) {
            if (result[i][j] == INT_MAX) {
                result[i][j] = -1; // Or another suitable value indicating no reachable water cell
            }
        }
    }

    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(rows * cols * rows * cols).  For each cell, we iterate through the entire matrix to find the nearest 1. | <b>Space Complexity:</b> O(1) -  Excluding the output matrix. O(rows * cols)  if including the output matrix.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ BFS (Breadth-First Search)</h5>
  <p>Use BFS to traverse the matrix. Start BFS from all cells containing 1 simultaneously. The distance from a cell to its nearest 1 is the number of levels in the BFS traversal. This effectively finds the shortest path from each 0 to a 1. The queue stores the coordinates of the cells to be visited along with their distances.</p>
  <pre><code class="language-python">#include &lt;bits/stdc++.h&gt;
using namespace std;

vector&lt;vector&lt;int&gt;&gt; nearest(vector&lt;vector&lt;int&gt;&gt; &amp;grid) {
    int rows = grid.size();
    int cols = grid[0].size();
    vector&lt;vector&lt;int&gt;&gt; result(rows, vector&lt;int&gt;(cols, INT_MAX));
    queue&lt;pair&lt;int, int&gt;&gt; q;

    // Initialize queue with all water cells (1) and set distance to 0
    for (int i = 0; i &lt; rows; ++i) {
        for (int j = 0; j &lt; cols; ++j) {
            if (grid[i][j] == 1) {
                result[i][j] = 0;
                q.push({i, j});
            }
        }
    }

    // BFS traversal
    int dx[] = {-1, 1, 0, 0};
    int dy[] = {0, 0, -1, 1};

    while (!q.empty()) {
        pair&lt;int, int&gt; curr = q.front();
        q.pop();
        int row = curr.first;
        int col = curr.second;

        for (int i = 0; i &lt; 4; ++i) {
            int newRow = row + dx[i];
            int newCol = col + dy[i];

            if (newRow &gt;= 0 &amp;&amp; newRow &lt; rows &amp;&amp; newCol &gt;= 0 &amp;&amp; newCol &lt; cols &amp;&amp; result[newRow][newCol] == INT_MAX) {
                result[newRow][newCol] = result[row][col] + 1;
                q.push({newRow, newCol});
            }
        }
    }

    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(rows * cols).  Each cell is visited at most once during the BFS. | <b>Space Complexity:</b> O(rows * cols). In worst case, the queue can hold all the cells (e.g. when the matrix contains only 1s).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">grid = {{0,0,0},{0,1,0},{0,0,0}}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">{{2,1,2},{1,0,1},{2,1,2}}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The nearest 1 to each cell is calculated based on Manhattan distance.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">grid = {{1,0,1},{0,0,0},{1,0,1}}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">{{0,1,0},{1,2,1},{0,1,0}}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Similar to the previous example. The distances are based on Manhattan distance from each cell to the nearest '1'.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The BFS approach is significantly more efficient than the brute force approach.  
2.  Consider edge cases like matrices with all 0s or all 1s.
3.  The provided code assumes the input grid is valid and well-formed.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/online-stock-span/>Online Stock Span</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Design an algorithm that collects daily price quotes for some stock and returns the span of that stock's price for the current day. The span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backward) for which the stock price was less than or equal to today's price.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>For each price, iterate backwards from the current day to find the span. This involves comparing the current price with the prices of previous days until a price greater than the current price is found.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class StockSpanner {
public:
    vector&lt;int&gt; prices;
    StockSpanner() {
    }

    int next(int price) {
        prices.push_back(price);
        int span = 1;
        for (int i = prices.size() - 2; i &gt;= 0; --i) {
            if (prices[i] &lt;= price) {
                span++;
            } else {
                break;
            }
        }
        return span;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) where n is the number of calls to next(). In the worst case, we may have to iterate through all previous prices for each call. | <b>Space Complexity:</b> O(n) to store the prices.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Using a Stack</h5>
  <p>Maintain a stack of pairs &lt;price, span&gt;. When a new price arrives, pop elements from the stack while the top element's price is less than or equal to the current price. The span of the current price is 1 + the sum of spans of the popped elements. Push the current price and its calculated span onto the stack.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class StockSpanner {
public:
    stack&lt;pair&lt;int, int&gt;&gt; st;

    StockSpanner() {
    }

    int next(int price) {
        int span = 1;
        while (!st.empty() &amp;&amp; st.top().first &lt;= price) {
            span += st.top().second;
            st.pop();
        }
        st.push({price, span});
        return span;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n) on average. Each price is pushed and popped at most once. | <b>Space Complexity:</b> O(n) for the stack.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["StockSpanner","next","next","next","next","next"]\n[[],[100],[80],[60],[70],[60]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[null,1,1,1,2,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">StockSpanner stockSpanner = new StockSpanner();
stockSpanner.next(100); // return 1
stockSpanner.next(80);  // return 1
stockSpanner.next(60);  // return 1
stockSpanner.next(70);  // return 2
stockSpanner.next(60);  // return 1</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["StockSpanner","next","next","next","next","next","next","next"]\n[[],[29],[91],[62],[76],[52],[58],[92]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[null,1,2,1,2,1,2,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Same as above, showcasing the calculation for different inputs.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The stack-based solution provides an optimized time complexity. The key is to efficiently determine the span by considering previous prices and their spans. The stack helps to maintain information about potential spans without redundant calculations. Edge cases include empty input and prices that are consistently increasing or decreasing.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/rotting-oranges/>Rotting Oranges</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>You are given an m x n grid where each cell represents a fresh orange (0), a rotten orange (2), or an empty cell (0). Every minute, any fresh orange that is adjacent to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Simulate the process minute by minute. In each minute, iterate through the grid and if a rotten orange is found, mark its adjacent fresh oranges as rotten. Repeat this until no more fresh oranges can be rotted or no fresh oranges exist. Count the minutes.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int orangesRottingBruteForce(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
    int rows = grid.size();
    int cols = grid[0].size();
    int minutes = 0;
    bool changed = true;

    while (changed) {
        changed = false;
        vector&lt;vector&lt;int&gt;&gt; next_grid = grid;

        for (int i = 0; i &lt rows; ++i) {
            for (int j = 0; j &lt cols; ++j) {
                if (grid[i][j] == 2) {
                    // Check adjacent cells
                    if (i &gt 0 &amp;&amp; grid[i - 1][j] == 1) {
                        next_grid[i - 1][j] = 2;
                        changed = true;
                    }
                    if (i &lt rows - 1 &amp;&amp; grid[i + 1][j] == 1) {
                        next_grid[i + 1][j] = 2;
                        changed = true;
                    }
                    if (j &gt 0 &amp;&amp; grid[i][j - 1] == 1) {
                        next_grid[i][j - 1] = 2;
                        changed = true;
                    }
                    if (j &lt cols - 1 &amp;&amp; grid[i][j + 1] == 1) {
                        next_grid[i][j + 1] = 2;
                        changed = true;
                    }
                }
            }
        }
        grid = next_grid;
        if (changed) {
            minutes++;
        }
    }

    // Check for remaining fresh oranges
    for (int i = 0; i &lt rows; ++i) {
        for (int j = 0; j &lt cols; ++j) {
            if (grid[i][j] == 1) {
                return -1;
            }
        }
    }

    return minutes;
}
</code></pre>
  <p><b>Time Complexity:</b> O(M * N * (M * N)), where M and N are the dimensions of the grid. In the worst case, we might iterate through the grid in each minute and update all fresh oranges if they are reachable by rotten ones. | <b>Space Complexity:</b> O(M * N) due to creating a copy of the grid in each iteration.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ BFS (Breadth-First Search)</h5>
  <p>Use BFS to simulate the rotting process. Start with all rotten oranges in a queue. In each minute (level of BFS), process oranges from the queue and mark adjacent fresh oranges as rotten, adding them to the queue. Count the levels of BFS as minutes.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int orangesRottingBFS(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
    int rows = grid.size();
    int cols = grid[0].size();
    queue&lt;pair&lt;int, int&gt;&gt; q;
    int freshOranges = 0;

    // Find initial rotten oranges and count fresh oranges
    for (int i = 0; i &lt rows; ++i) {
        for (int j = 0; j &lt cols; ++j) {
            if (grid[i][j] == 2) {
                q.push({i, j});
            } else if (grid[i][j] == 1) {
                freshOranges++;
            }
        }
    }

    int minutes = 0;
    int dx[] = {0, 0, 1, -1};
    int dy[] = {1, -1, 0, 0};

    while (!q.empty() &amp;&amp; freshOranges &gt 0) {
        int size = q.size();
        bool rottedThisMinute = false;

        for (int i = 0; i &lt size; ++i) {
            pair&lt;int, int&gt; curr = q.front();
            q.pop();
            int x = curr.first;
            int y = curr.second;

            for (int k = 0; k &lt 4; ++k) {
                int nx = x + dx[k];
                int ny = y + dy[k];

                if (nx &gt= 0 &amp;&amp; nx &lt rows &amp;&amp; ny &gt= 0 &amp;&amp; ny &lt cols &amp;&amp; grid[nx][ny] == 1) {
                    grid[nx][ny] = 2;
                    q.push({nx, ny});
                    freshOranges--;
                    rottedThisMinute = true;
                }
            }
        }
        if(rottedThisMinute) {
            minutes++;
        }
    }

    if (freshOranges &gt 0) {
        return -1;
    }

    return minutes;
}
</code></pre>
  <p><b>Time Complexity:</b> O(M * N) where M and N are the dimensions of the grid. Each cell is visited at most once. | <b>Space Complexity:</b> O(M * N) in the worst case, due to the queue potentially holding all the cells.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[2,1,1],[1,1,0],[0,1,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The orange at (0,0) rots (0,1) and (0,2) in minute 1. The orange at (1,0) rots in minute 2, (1,1) rots in minute 3, and finally the orange at (2,1) rots in minute 4.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[2,1,1],[0,1,1],[1,0,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The orange at (0,0) rots (0,1) and (0,2) in minute 1. But (2,0) can not be reached by any rotten orange. Hence, the answer is -1.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0,2]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The existing rotten orange can already affect all the fresh oranges.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. Handle the case where some oranges cannot be rotten (return -1).
2. BFS is more efficient than brute force.
3. Edge cases: empty grid, no fresh oranges, no rotten oranges, all oranges are rotten initially.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/sum-of-subarray-minimums/>Sum of Subarray Minimums</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an array of integers `arr`, find the sum of minimums of all possible contiguous subarrays of `arr`. Since the answer can be very large, return the answer modulo `10^9 + 7`.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible subarrays. For each subarray, find the minimum element. Sum up all the minimums. This is a straightforward but inefficient approach.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    int sumSubarrayMins(vector&lt;int&gt;&amp; arr) {
        int n = arr.size();
        long long totalSum = 0;
        int MOD = 1e9 + 7;

        for (int i = 0; i &lt; n; ++i) {
            for (int j = i; j &lt; n; ++j) {
                int minVal = arr[i];
                for (int k = i + 1; k &lt;= j; ++k) {
                    minVal = min(minVal, arr[k]);
                }
                totalSum = (totalSum + minVal) % MOD;
            }
        }
        return (int)totalSum;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n^3) -  Three nested loops. The outer loops select the start and end of the subarray (O(n^2)), and the inner loop finds the minimum (O(n)). | <b>Space Complexity:</b> O(1) - Constant extra space is used.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Monotonic Stack</h5>
  <p>Use a monotonic stack to efficiently find the subarrays where a given element is the minimum.  For each element `arr[i]`, find the nearest smaller elements to its left and right.  The element `arr[i]` is the minimum for all subarrays that contain `arr[i]` and whose boundaries are determined by the indices of the nearest smaller elements. Count the number of such subarrays, and multiply by `arr[i]`, summing up the result to get the answer. This significantly reduces redundant computations by avoiding repeated searches for the minimum within each subarray. The use of a monotonic stack allows us to determine these bounds in linear time, optimizing the overall time complexity.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    int sumSubarrayMins(vector&lt;int&gt;&amp; arr) {
        int n = arr.size();
        long long totalSum = 0;
        int MOD = 1e9 + 7;
        vector&lt;int&gt; left(n), right(n);
        stack&lt;int&gt; s;

        // Calculate left boundaries
        for (int i = 0; i &lt; n; ++i) {
            while (!s.empty() &amp;&amp; arr[s.top()] &gt; arr[i]) {
                s.pop();
            }
            left[i] = s.empty() ? i + 1 : i - s.top();
            s.push(i);
        }

        // Clear stack for right boundaries
        while (!s.empty()) {
            s.pop();
        }

        // Calculate right boundaries
        for (int i = 0; i &lt; n; ++i) {
            right[i] = n - i;
        }

        for (int i = 0; i &lt; n; ++i) {
            while (!s.empty() &amp;&amp; arr[s.top()] &gt;= arr[i]) {
                s.pop();
            }
            if (!s.empty()) {
                right[s.top()] = i - s.top();
            }
            s.push(i);
        }

        for (int i = 0; i &lt; n; ++i) {
            totalSum = (totalSum + (long long)arr[i] * left[i] * right[i]) % MOD;
        }

        return (int)totalSum;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n) -  Each element is pushed and popped from the stack at most once. | <b>Space Complexity:</b> O(n) -  The stack and left/right arrays can store up to n elements.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr = [3,1,2,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">17</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4].
Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.
Sum is 3 + 1 + 2 + 4 + 1 + 1 + 2 + 1 + 1 + 1 = 17.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr = [10,2,3,7,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">19</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Subarrays: [10], [2], [3], [7], [5], [10,2], [2,3], [3,7], [7,5], [10,2,3], [2,3,7], [3,7,5], [10,2,3,7], [2,3,7,5], [10,2,3,7,5]
Minimums: 10, 2, 3, 5, 5, 2, 3, 5, 2, 2, 2, 3, 2
Sum = 10+2+3+5+5+2+2+3+2 = 19</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The modular arithmetic (using % MOD) is crucial to prevent integer overflow, especially when dealing with large input arrays or elements.  The monotonic stack approach is significantly more efficient than brute force due to its linear time complexity. Pay close attention to edge cases like duplicate elements and the behavior when the stack is empty.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/evaluate-reverse-polish-notation/>Evaluate Reverse Polish Notation</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an array of strings `tokens` that represents an arithmetic expression in Reverse Polish Notation, evaluate the expression. Return the integer that represents the value of the expression.

Note that:

*   Valid operators are `+`, `-`, `*`, and `/`.
*   Each operand may be an integer or another expression.
*   The division between two integers should truncate toward zero.
*   The given RPN expression is always valid. That means the expression will always evaluate to a result, and there will not be any division by zero operation.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves iterating through the `tokens` array. When an operand (number) is encountered, it's pushed onto a stack. When an operator is encountered, the top two operands are popped from the stack, the operation is performed, and the result is pushed back onto the stack.  This continues until the entire `tokens` array is processed.  The final result is the only element remaining in the stack.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    int evalRPN(vector&lt;string&gt;&amp; tokens) {
        stack&lt;int&gt; nums;
        for (const string&amp; token : tokens) {
            if (token == "+") {
                int operand2 = nums.top(); nums.pop();
                int operand1 = nums.top(); nums.pop();
                nums.push(operand1 + operand2);
            } else if (token == "-") {
                int operand2 = nums.top(); nums.pop();
                int operand1 = nums.top(); nums.pop();
                nums.push(operand1 - operand2);
            } else if (token == "*") {
                int operand2 = nums.top(); nums.pop();
                int operand1 = nums.top(); nums.pop();
                nums.push(operand1 * operand2);
            } else if (token == "/") {
                int operand2 = nums.top(); nums.pop();
                int operand1 = nums.top(); nums.pop();
                nums.push(operand1 / operand2);
            } else {
                nums.push(stoi(token));
            }
        }
        return nums.top();
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the number of tokens in the input array.  Each token is processed once. | <b>Space Complexity:</b> O(n), in the worst-case scenario where all tokens are numbers, the stack will store all operands. In the best-case, if many operators appear earlier in the input, the stack size would be lower.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach (Stack-Based)</h5>
  <p>The optimized approach uses a stack to store operands. The algorithm iterates through the `tokens` array.  If the current token is an operand, it's pushed onto the stack. If the current token is an operator, the top two operands are popped from the stack, the operation is performed, and the result is pushed back onto the stack. Integer division is handled by truncating towards zero. The final result is the top element of the stack.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    int evalRPN(vector&lt;string&gt;&amp; tokens) {
        stack&lt;int&gt; operands;
        for (const string&amp; token : tokens) {
            if (token == "+") {
                int operand2 = operands.top(); operands.pop();
                int operand1 = operands.top(); operands.pop();
                operands.push(operand1 + operand2);
            } else if (token == "-") {
                int operand2 = operands.top(); operands.pop();
                int operand1 = operands.top(); operands.pop();
                operands.push(operand1 - operand2);
            } else if (token == "*") {
                int operand2 = operands.top(); operands.pop();
                int operand1 = operands.top(); operands.pop();
                operands.push(operand1 * operand2);
            } else if (token == "/") {
                int operand2 = operands.top(); operands.pop();
                int operand1 = operands.top(); operands.pop();
                operands.push(operand1 / operand2);
            } else {
                operands.push(stoi(token));
            }
        }
        return operands.top();
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the number of tokens.  Each token is processed once. | <b>Space Complexity:</b> O(n), in the worst case (all operands), the stack can grow up to the size of input.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["2","1","+","3","*"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">9</td>
        <td style="border: 1px solid #ccc; padding: 6px;">(2 + 1) * 3 = 9</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["4","13","5","/","+"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4 + (13 / 5) = 4 + 2 = 6</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["10","6","9","3","+","-11","*","/","*","17","+","5","+"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">22</td>
        <td style="border: 1px solid #ccc; padding: 6px;">((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / 132)) + 17) + 5 = (10 * 0 + 17) + 5 = 22</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The problem relies heavily on the properties of a stack (LIFO - Last In, First Out).  The order of operands when performing operations is critical, especially for subtraction and division. Integer division truncates towards zero, not rounds.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/circular-tour/1>Circular tour</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a circular tour with N petrol pumps. The amount of petrol each petrol pump has is given in an array petrol[] and the distance of that petrol pump to the next petrol pump is given in an array distance[]. A truck starts from a petrol pump and wants to cycle through all the petrol pumps. The truck can only move to the next petrol pump. The truck starts with 0 capacity. Given a starting petrol pump, the truck can visit all the petrol pumps and come back to the starting point, otherwise, it can't. Determine the starting petrol pump index such that the truck can complete the circular tour. If there is no possible solution return -1.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through each petrol pump as a potential starting point. For each starting point, simulate the entire circular tour.  If the truck runs out of petrol at any point, this starting point is invalid. If the truck successfully completes the tour, return the starting point index. If no starting point is found, return -1.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int tour(int petrol[], int distance[], int n) {
    for (int start = 0; start &lt n; start++) {
        int currentPetrol = 0;
        int i = start;
        bool possible = true;

        do {
            currentPetrol += petrol[i] - distance[i];
            if (currentPetrol &lt 0) {
                possible = false;
                break;
            }
            i = (i + 1) % n;
        } while (i != start);

        if (possible) {
            return start;
        }
    }
    return -1;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N^2) - In the worst case, we iterate through all possible starting points (N) and for each, we traverse the entire tour (N). | <b>Space Complexity:</b> O(1) - Constant extra space is used.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach</h5>
  <p>Maintain two variables: `start` and `currentPetrol`. Iterate through the petrol pumps. For each pump, add `petrol[i] - distance[i]` to `currentPetrol`.  If `currentPetrol` becomes negative, it means we cannot reach the next pump from the current start.  In that case, set `start` to `i + 1` and reset `currentPetrol` to 0. Additionally, maintain a `totalPetrol` to track the total petrol available. After traversing all pumps, if `totalPetrol` is negative, then no solution exists; otherwise, return `start`.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int tour(int petrol[], int distance[], int n) {
    int start = 0;
    int currentPetrol = 0;
    int totalPetrol = 0;

    for (int i = 0; i &lt n; i++) {
        totalPetrol += petrol[i] - distance[i];
        currentPetrol += petrol[i] - distance[i];
        if (currentPetrol &lt 0) {
            start = i + 1;
            currentPetrol = 0;
        }
    }

    if (totalPetrol &lt 0) {
        return -1;
    }
    else {
        return start;
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(N) - We iterate through the petrol pumps only once. | <b>Space Complexity:</b> O(1) - Constant extra space is used.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">petrol[] = {4, 6, 7, 4}, distance[] = {6, 5, 3, 6}, N = 4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Starting from pump 1, we have 6 - 5 = 1.  Then, 1 + 7 - 3 = 5. Then, 5 + 4 - 6 = 3. Finally, 3 + 4 - 6 = 1 which is &gt=0, and we are back at the starting point.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">petrol[] = {4, 6, 7, 4}, distance[] = {4, 6, 7, 4}, N = 4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Starting from pump 0, we have 4 - 4 = 0. Then, 0 + 6 - 6 = 0, then 0 + 7 - 7 = 0, then 0 + 4 - 4 = 0.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">petrol[] = {4, 6, 7, 4}, distance[] = {6, 5, 3, 6}, N = 4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Starting from pump 1, we have 6-5=1, 1+7-3=5, 5+4-6=3, 3+4-6 = 1. Circular Tour Possible</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">petrol[] = {6,8,6,6,5}, distance[] = {4,7,8,6,7}, N = 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Circular tour possible from pump 1</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. **Edge Cases:**
   - If the total petrol available is less than the total distance to be covered, there is no solution.
   - Handle cases where `petrol[i] - distance[i]` might be negative at some petrol pumps, implying that we can't move forward from that point as a starting point. 
2. **Optimization:** The optimized approach avoids unnecessary iterations and is significantly faster than the brute-force method.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/>Remove All Adjacent Duplicates in String II</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a string s and an integer k, you are asked to repeatedly remove all adjacent and equal characters from s until you no longer can. You have to return the final string after all such removals have been done. In other words, repeatedly delete consecutive sequences of k characters until no more such sequences exist.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iteratively scan the string, identifying and removing consecutive sequences of k identical characters. This process repeats until no more removals are possible.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string removeDuplicatesBF(string s, int k) {
    while (true) {
        bool removed = false;
        string result = "";
        int count = 1;
        for (int i = 0; i &lt s.length(); ++i) {
            if (i + 1 &lt s.length() &amp;&amp; s[i] == s[i + 1]) {
                count++;
            } else {
                if (count &lt k) {
                    for (int j = i - count + 1; j &lt= i; ++j) {
                        result += s[j];
                    }
                } else {
                    removed = true;
                }
                count = 1;
            }
        }

        if (result.length() != 0 &amp;&amp; result.back() == s.back()) {
            if (count &lt k) {
                for (int j = s.length() - count; j &lt s.length(); ++j) {
                    result += s[j];
                }
            }
        } else {
            if (count &lt k) {
                for (int j = s.length() - count; j &lt s.length(); ++j) {
                    result += s[j];
                }
            }
        }
        if (!removed) {
            return result;
        }
        s = result;
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(N^2 / K), where N is the length of the string.  In the worst case (e.g., "aaaaaaaa" and k=2) we might have to iterate through the string multiple times. | <b>Space Complexity:</b> O(N) in the worst case, for storing the intermediate strings.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Stack-based Approach</h5>
  <p>Use a stack to store pairs of characters and their counts. Iterate through the string. If the current character matches the top of the stack, increment its count. If the count reaches k, pop the pair from the stack. If the current character is different, push it onto the stack with a count of 1. Reconstruct the final string from the stack.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string removeDuplicatesOptimized(string s, int k) {
    stack&lt;pair&lt;char, int&gt;&gt; st;
    for (char c : s) {
        if (!st.empty() &amp;&amp; st.top().first == c) {
            st.top().second++;
            if (st.top().second == k) {
                st.pop();
            }
        } else {
            st.push({c, 1});
        }
    }
    string result = "";
    while (!st.empty()) {
        int count = st.top().second;
        char ch = st.top().first;
        st.pop();
        while (count--) {
            result = ch + result;
        }
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the length of the string.  Each character is visited at most twice (once to add to stack and once during reconstruction). | <b>Space Complexity:</b> O(N), in the worst case, where all characters are different.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "abcd", k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">abcd</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There's no consecutive sequence of k characters to remove.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "deeedbbcccbdaa", k = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">aa</td>
        <td style="border: 1px solid #ccc; padding: 6px;">First delete "eee" and "ccc". Then delete "bbb", and finally delete "ddd".  The remaining string is "aa".</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "abbaca", k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">ca</td>
        <td style="border: 1px solid #ccc; padding: 6px;">For example, in "abbaca" we could remove "bb" since the consecutive characters are of length 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "aaaaaaaaaaaa", k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;"></td>
        <td style="border: 1px solid #ccc; padding: 6px;">Remove all characters.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The stack-based solution is the most efficient due to its linear time complexity. It leverages the properties of stacks to keep track of character counts and efficiently remove duplicates.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/flatten-nested-list-iterator/>Flatten Nested List Iterator</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a nested list of integers, implement an iterator to flatten it.

Each element is either an integer, or a list whose elements may also be integers or other lists.

Implement the NestedIterator class:

*   NestedIterator(List&lt;NestedInteger&gt; nestedList) Initializes the iterator with the nested list.
*   int next() Returns the next integer in the nested list.
*   boolean hasNext() Returns true if there are still some integer in the nested list and false otherwise.

Your code should accept lists where each element is a NestedInteger. The NestedInteger class has an API:

*   isInteger() returns true if this NestedInteger holds a single integer
*   getInteger() returns the single integer that this NestedInteger holds
*   getList() returns the list that this NestedInteger holds
</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Flatten the nested list into a single list during initialization.  Then, the `next()` method simply retrieves the next element from the flattened list, and `hasNext()` checks if there are more elements.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;

using namespace std;

// This is the interface for the NestedInteger class.
// You should not implement it, or speculate about its implementation
class NestedInteger {
 public:
  // Return true if this NestedInteger holds a single integer, rather than a nested list.
  bool isInteger() const;

  // Return the single integer that this NestedInteger holds, if it holds a single integer
  // The result is undefined if this NestedInteger holds a nested list
  int getInteger() const;

  // Return the nested list that this NestedInteger holds, if it holds a nested list
  // The result is undefined if this NestedInteger holds a single integer
  const vector&lt;NestedInteger&gt;&amp; getList() const;
};

class NestedIterator {
private:
  vector&lt;int&gt; flattenedList;
  int currentIndex;

  void flatten(const vector&lt;NestedInteger&gt;&amp; nestedList) {
    for (const auto&amp; element : nestedList) {
      if (element.isInteger()) {
        flattenedList.push_back(element.getInteger());
      } else {
        flatten(element.getList());
      }
    }
  }

public:
  NestedIterator(const vector&lt;NestedInteger&gt;&amp; nestedList) :
      currentIndex(0) {
    flatten(nestedList);
  }

  int next() {
    return flattenedList[currentIndex++];
  }

  bool hasNext() const {
    return currentIndex &lt; flattenedList.size();
  }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the total number of integers in the nested list. This is due to flattening the nested list in the constructor. | <b>Space Complexity:</b> O(N),  where N is the total number of integers in the nested list. This is because we store the flattened list.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized with Stack</h5>
  <p>Use a stack to simulate the recursive process. Push elements onto the stack in reverse order during initialization.  The `next()` method pops the top element and returns its integer value. The `hasNext()` method ensures that the stack is not empty and that the top element is an integer. If it's not an integer, flatten it more during the hasNext process.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;

using namespace std;

// This is the interface for the NestedInteger class.
// You should not implement it, or speculate about its implementation
class NestedInteger {
 public:
  // Return true if this NestedInteger holds a single integer, rather than a nested list.
  bool isInteger() const;

  // Return the single integer that this NestedInteger holds, if it holds a single integer
  // The result is undefined if this NestedInteger holds a nested list
  int getInteger() const;

  // Return the nested list that this NestedInteger holds, if it holds a nested list
  // The result is undefined if this NestedInteger holds a single integer
  const vector&lt;NestedInteger&gt;&amp; getList() const;
};

class NestedIterator {
private:
  stack&lt;pair&lt;vector&lt;NestedInteger&gt;::const_iterator, vector&lt;NestedInteger&gt;::const_iterator&gt;&gt; st;

public:
  NestedIterator(const vector&lt;NestedInteger&gt;&amp; nestedList) {
    if (!nestedList.empty()) {
      st.push({nestedList.begin(), nestedList.end()});
    }
  }

  int next() {
    int result = -1; // Default return if there's an issue.
    if (hasNext()) {
        auto& top_pair = st.top();
        result = top_pair.first-&gt;getInteger();
        ++(st.top().first);
    }
    return result;
  }

  bool hasNext() {
    while (!st.empty()) {
      auto& top_pair = st.top();
      if (top_pair.first == top_pair.second) {
        st.pop();
        continue;
      }

      const NestedInteger& current = *top_pair.first;
      if (current.isInteger()) {
        return true;
      }
      else {
        vector&lt;NestedInteger&gt; sub_list = current.getList();
        if (!sub_list.empty()) {
           st.push({sub_list.begin(), sub_list.end()});
        }
        ++(st.top().first);
      }
    }
    return false;
  }
};
</code></pre>
  <p><b>Time Complexity:</b> O(1) for `next()` and `hasNext()` on average. The `hasNext()` method might take O(N) in the worst case (e.g., when flattening deeply nested lists), but it amortizes to O(1). | <b>Space Complexity:</b> O(D), where D is the maximum depth of the nested list. In the worst-case scenario, this equals the number of nested lists.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nestedList = [[1,1],2,[1,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,1,2,1,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The iterator will return the integers in the nested list in the order they appear, flattened.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nestedList = [1,[4,[6]]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,4,6]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Same as above, the iterator is created and values are fetched by calling next method repeatedly.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nestedList = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">An empty list will give an empty flattened result.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Key considerations: 
*   Handling empty nested lists.
*   Efficiency in the hasNext() and next() methods.
*   The NestedInteger interface should not be implemented.  The solution relies on the existing methods isInteger(), getInteger(), and getList().
*   The stack based solution avoids pre-flattening the list, optimizing space complexity and latency of initialization and calls to next().</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/find-the-maximum-of-minimums-for-every-window-size-in-a-given-array/>Find the maximum of minimums for every window size in a given array</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given an array of integers, the task is to find the maximum of minimums for every window size. More precisely, for each window size k from 1 to n (where n is the size of the array), find the minimum value in all subarrays of size k, and then find the maximum among these minimums for that particular k.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through each window size from 1 to n. For each window size k, iterate through all possible subarrays of size k. For each subarray, find the minimum element. Keep track of the maximum of these minimums for each window size k.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

vector&lt;int&gt; maxOfMin(int arr[], int n) {
    vector&lt;int&gt; result(n);

    for (int k = 1; k &lt;= n; ++k) {
        int max_min = INT_MIN;
        for (int i = 0; i &lt;= n - k; ++i) {
            int min_val = INT_MAX;
            for (int j = i; j &lt; i + k; ++j) {
                min_val = min(min_val, arr[j]);
            }
            max_min = max(max_min, min_val);
        }
        result[k - 1] = max_min;
    }
    return result;
}

int main() {
    int arr[] = {1, 2, 3, 1, 4, 5, 2, 3, 6};
    int n = sizeof(arr) / sizeof(arr[0]);
    vector&lt;int&gt; result = maxOfMin(arr, n);

    for (int x : result) {
        cout &lt;&lt; x &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^3) | <b>Space Complexity:</b> O(n)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Using a Stack (Monotonic Stack)</h5>
  <p>Use a stack to efficiently find the nearest smaller elements to the left and right of each element. This helps determine the window size within which the current element is the minimum. Calculate the maximum of minimums for each window size based on these window boundaries.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

vector&lt;int&gt; maxOfMinOptimized(int arr[], int n) {
    vector&lt;int&gt; result(n, 0);
    vector&lt;int&gt; left(n, 0), right(n, 0);
    stack&lt;int&gt; s;

    // Find the nearest smaller element to the left for each element.
    for (int i = 0; i &lt; n; ++i) {
        while (!s.empty() &amp;&amp; arr[s.top()] &gt;= arr[i]) {
            s.pop();
        }
        left[i] = s.empty() ? -1 : s.top();
        s.push(i);
    }

    // Clear the stack for right boundary calculation.
    while (!s.empty()) {
        s.pop();
    }

    // Find the nearest smaller element to the right for each element.
    for (int i = n - 1; i &gt;= 0; --i) {
        while (!s.empty() &amp;&amp; arr[s.top()] &gt;= arr[i]) {
            s.pop();
        }
        right[i] = s.empty() ? n : s.top();
        s.push(i);
    }

    // Calculate the maximum of minimums for each window size.
    for (int i = 0; i &lt; n; ++i) {
        int window_size = right[i] - left[i] - 1;
        result[window_size - 1] = max(result[window_size - 1], arr[i]);
    }

    // Fill in missing results for window sizes.
    for (int i = n - 2; i &gt;= 0; --i) {
        result[i] = max(result[i], result[i + 1]);
    }

    return result;
}

int main() {
    int arr[] = {1, 2, 3, 1, 4, 5, 2, 3, 6};
    int n = sizeof(arr) / sizeof(arr[0]);
    vector&lt;int&gt; result = maxOfMinOptimized(arr, n);

    for (int x : result) {
        cout &lt;&lt; x &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) | <b>Space Complexity:</b> O(n)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr[] = {1, 2, 3, 1, 4, 5, 2, 3, 6}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">6 3 2 1 1 1 2 1 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">For k=1, the max of mins is 6 (6 is the minimum in the only window of size 1). For k=2, the max of mins is 3 (max of {1, 1, 2, 2, 3, 3}). For k=3, the max of mins is 2, (max of {1, 1, 1, 2, 2}). And so on.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr[] = {1, 2, 3, 4}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4 3 2 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">For k=1, max of mins is 4. For k=2, max of mins is 3, etc.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The monotonic stack approach is significantly more efficient than the brute-force approach. The edge cases to consider include arrays with duplicate elements and arrays with increasing or decreasing order.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/lru-cache-implementation/>LRU Cache Implementation</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: `get` and `put`. 

- `get(key)` - Get the value of the key if the key exists in the cache, otherwise return -1.
- `put(key, value)` - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item. 

The cache should be initialized with a positive capacity.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach uses a standard hash map to store the key-value pairs. To maintain the LRU property, we can add a timestamp or an access counter to each entry. When a get or put operation happens, we update the timestamp. When the cache is full and needs to evict, the entry with the oldest timestamp is evicted. However, this approach has inefficiencies in updating the order which makes it not a feasible approach.</p>
  <pre><code class="language-python">#include &ltiostream&gt
#include &ltunordered_map&gt
#include &ltalgorithm&gt
#include &ltlist&gt;

using namespace std;

struct CacheEntry {
    int key;
    int value;
    int timestamp;
};

class LRUCache {
private:
    int capacity;
    unordered_map&lt;int, CacheEntry&gt; cache;
    int time;

public:
    LRUCache(int capacity) {
        this-&gt;capacity = capacity;
        time = 0;
    }

    int get(int key) {
        if (cache.find(key) != cache.end()) {
            cache[key].timestamp = time++;
            return cache[key].value;
        }
        return -1;
    }

    void put(int key, int value) {
        if (cache.find(key) != cache.end()) {
            cache[key].value = value;
            cache[key].timestamp = time++;
            return;
        }

        if (cache.size() == capacity) {
            int lruKey = -1;
            int minTime = time;
            for (auto const&amp; [k, entry] : cache) {
                if (entry.timestamp &lt minTime) {
                    minTime = entry.timestamp;
                    lruKey = k;
                }
            }
            cache.erase(lruKey);
        }
        cache[key] = {key, value, time++};
    }
};

</code></pre>
  <p><b>Time Complexity:</b> O(N) for get and put in the worst-case due to iterating through the cache to find the LRU element.  Where N is the capacity of the cache. | <b>Space Complexity:</b> O(capacity) to store the cache entries.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized with Doubly Linked List and Hash Map</h5>
  <p>This approach combines a doubly linked list and a hash map. The linked list maintains the order of usage (most recently used at the head, least recently used at the tail). The hash map provides O(1) lookup for keys.

- **get(key):** If the key exists, move the corresponding node to the head of the list and return its value. If not, return -1.
- **put(key, value):** If the key exists, update the value and move the corresponding node to the head. If not, create a new node and add it to the head. If the cache is full, remove the tail node (LRU) before inserting the new node.</p>
  <pre><code class="language-python">#include &ltiostream&gt
#include &ltunordered_map&gt
#include &ltlist&gt;

using namespace std;

struct Node {
    int key;
    int value;
    Node* next;
    Node* prev;

    Node(int k, int v) : key(k), value(v), next(nullptr), prev(nullptr) {}
};

class LRUCache {
private:
    int capacity;
    unordered_map&lt;int, Node*&gt; cache;
    Node* head;
    Node* tail;

    void addToHead(Node* node) {
        node-&gt;next = head-&gt;next;
        if (head-&gt;next != nullptr) {
            head-&gt;next-&gt;prev = node;
        }
        head-&gt;next = node;
        node-&gt;prev = head;
        if (tail == head) {
            tail = node;
        }
    }

    void removeNode(Node* node) {
        if (node == nullptr) return;
        node-&gt;prev-&gt;next = node-&gt;next;
        if (node-&gt;next != nullptr) {
            node-&gt;next-&gt;prev = node-&gt;prev;
        }
        if (tail == node) {
            tail = node-&gt;prev;
        }
    }

public:
    LRUCache(int capacity) {
        this-&gt;capacity = capacity;
        head = new Node(-1, -1);
        tail = head;
    }

    int get(int key) {
        if (cache.find(key) != cache.end()) {
            Node* node = cache[key];
            removeNode(node);
            addToHead(node);
            return node-&gt;value;
        }
        return -1;
    }

    void put(int key, int value) {
        if (cache.find(key) != cache.end()) {
            Node* node = cache[key];
            node-&gt;value = value;
            removeNode(node);
            addToHead(node);
        } else {
            Node* newNode = new Node(key, value);
            cache[key] = newNode;
            addToHead(newNode);
            if (cache.size() &gt capacity) {
                int lruKey = tail-&gt;key;
                removeNode(tail);
                cache.erase(lruKey);
            }
        }
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(1) for both get and put operations. | <b>Space Complexity:</b> O(capacity) to store the cache entries and the doubly linked list.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">LRUCache(2)
put(1, 1)
put(2, 2)
get(1)
put(3, 3)
get(2)
put(4, 4)
get(1)
get(3)
get(4)</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1
-1
-1
3
4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The cache is initialized with a capacity of 2. The operations and their effects are as follows:
- put(1, 1): Cache: {1=1}
- put(2, 2): Cache: {1=1, 2=2}
- get(1): Returns 1 (cache: {2=2, 1=1})
- put(3, 3): Evicts key 2, Cache: {1=1, 3=3}
- get(2): Returns -1 (not found)
- put(4, 4): Evicts key 1, Cache: {3=3, 4=4}
- get(1): Returns -1 (not found)
- get(3): Returns 3
- get(4): Returns 4</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">LRUCache(1)
put(2, 1)
get(2)
put(3, 2)
get(2)
get(3)</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1
-1
2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The cache is initialized with a capacity of 1. The operations and their effects are as follows:
- put(2, 1): Cache: {2=1}
- get(2): Returns 1
- put(3, 2): Evicts key 2, Cache: {3=2}
- get(2): Returns -1 (not found)
- get(3): Returns 2</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Important considerations include:
- Handling of the head and tail of the doubly linked list.
- Ensuring the correctness of the `removeNode` and `addToHead` helper functions.
- Correctly updating the cache when a key is already present.
- Efficiently evicting the LRU element when the cache is full.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=http://geeksforgeeks.org/the-celebrity-problem/>The Celebrity Problem</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>In a party of N people, only one person is known to everyone. Such a person may be present in the party, if yes, he/she doesn't know anyone in the party. Find out the celebrity in the party.

You are given a helper function `knows(a, b)` which returns true if person `a` knows person `b`, and false otherwise. You have to use this function to solve the problem. You are allowed to call `knows()` function as many times as you want.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves checking every person as a potential celebrity. For each person, iterate through all other people to check if they know the potential celebrity (celebrity knows no one) and if the potential celebrity is known by all other people (everyone knows celebrity).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Function to check if a knows b
bool knows(int a, int b, const vector&lt;vector&lt;int&gt;&gt;&amp; party) {
    return party[a][b] == 1;
}

int findCelebrityBruteForce(int n, const vector&lt;vector&lt;int&gt;&gt;&amp; party) {
    for (int i = 0; i &lt; n; i++) {
        bool isCelebrity = true;

        // Check if i knows anyone
        for (int j = 0; j &lt; n; j++) {
            if (i != j &amp;&amp; knows(i, j, party)) {
                isCelebrity = false;
                break;
            }
        }

        if (!isCelebrity) continue;

        // Check if everyone else knows i
        for (int j = 0; j &lt; n; j++) {
            if (i != j &amp;&amp; !knows(j, i, party)) {
                isCelebrity = false;
                break;
            }
        }

        if (isCelebrity) return i;
    }

    return -1; // No celebrity found
}

</code></pre>
  <p><b>Time Complexity:</b> O(N^2), where N is the number of people in the party. | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach using Stack</h5>
  <p>The optimized approach uses a stack to eliminate potential non-celebrities.  First, push all the people onto the stack. Then, while the stack has more than one element, pop two people (a and b). If a knows b, then a cannot be a celebrity (because celebrities don't know anyone), so discard a. If a doesn't know b, then b cannot be a celebrity (because a celebrity is known by everyone), so discard b.  The remaining person (if any) is a potential celebrity.  Verify if this person is indeed a celebrity by checking if they know anyone and if everyone else knows them.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Function to check if a knows b
bool knows(int a, int b, const vector&lt;vector&lt;int&gt;&gt;&amp; party) {
    return party[a][b] == 1;
}

int findCelebrityOptimized(int n, const vector&lt;vector&lt;int&gt;&gt;&amp; party) {
    stack&lt;int&gt; s;
    for (int i = 0; i &lt; n; i++) {
        s.push(i);
    }

    while (s.size() &gt; 1) {
        int a = s.top();
        s.pop();
        int b = s.top();
        s.pop();

        if (knows(a, b, party)) {
            // a knows b, so a is not a celebrity
            // b might be a celebrity, so push b back
            
        } else {
            // a doesn't know b, so b is not a celebrity
            s.push(a);
        }
    }

    if (s.empty()) return -1; // No potential celebrity
    int potentialCelebrity = s.top();

    // Verify the potential celebrity
    for (int i = 0; i &lt; n; i++) {
        if (potentialCelebrity != i &amp;&amp; (knows(potentialCelebrity, i, party) || !knows(i, potentialCelebrity, party)))
            return -1;
    }

    return potentialCelebrity;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of people in the party. | <b>Space Complexity:</b> O(N) due to the stack.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">N = 3, party = [[0, 0, 1], [0, 0, 1], [0, 0, 0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Person 2 knows no one, and persons 0 and 1 know person 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">N = 3, party = [[0, 1, 0], [0, 0, 0], [0, 1, 0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Person 1 knows no one and persons 0 and 2 knows person 1.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">N = 2, party = [[0, 1], [1, 0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No celebrity exists. Both know each other.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">N = 1, party = [[0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Person 0 is the celebrity.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The `knows()` function is the key to solving this problem. It's the only way to gather information about the relationships between people. The stack approach is more efficient because it smartly eliminates potential non-celebrities using pairwise comparisons.</p>
</div>
<hr style="margin: 40px 0;">
<h2>Trees</h2>
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/diameter-of-binary-tree/>Diameter of Binary Tree</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given the root of a binary tree, return the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. The length of a path between two nodes is represented by the number of edges between them.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>For each node, calculate the height of its left subtree and the height of its right subtree. The diameter passing through that node is the sum of these heights. Keep track of the maximum diameter found so far.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

int height(TreeNode* node) {
    if (!node) return 0;
    return 1 + max(height(node->left), height(node->right));
}

int diameterOfBinaryTree_brute_force(TreeNode* root) {
    int diameter = 0;
    if (!root) return 0;

    function&lt;void(TreeNode*)&gt; dfs = [&](TreeNode* node) {
        if (!node) return;

        int leftHeight = height(node->left);
        int rightHeight = height(node->right);
        diameter = max(diameter, leftHeight + rightHeight);
        dfs(node->left);
        dfs(node->right);
    };

    dfs(root);
    return diameter;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N^2), where N is the number of nodes. For each node, we calculate the height of its subtrees, which takes O(N) time in the worst case (skewed tree). | <b>Space Complexity:</b> O(H), where H is the height of the tree, due to the recursion stack. In the worst case (skewed tree), this is O(N).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach (DFS with Height Calculation)</h5>
  <p>Perform a Depth-First Search (DFS) on the tree. During the DFS, calculate the height of each node and update the diameter. The diameter at a node is the sum of the heights of its left and right subtrees. Use a single pass to calculate both height and diameter.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

int diameter = 0;

int dfs(TreeNode* node) {
    if (!node) return 0;

    int leftHeight = dfs(node->left);
    int rightHeight = dfs(node->right);

    diameter = max(diameter, leftHeight + rightHeight);

    return 1 + max(leftHeight, rightHeight);
}

int diameterOfBinaryTree_optimized(TreeNode* root) {
    diameter = 0;
    dfs(root);
    return diameter;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes.  Each node is visited once. | <b>Space Complexity:</b> O(H), where H is the height of the tree, due to the recursion stack.  In the worst case (skewed tree), this is O(N).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,2,3,4,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The longest path is [4,2,1,3] or [5,2,1,3]. The diameter is 3 (number of edges between two nodes).</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The longest path is [2,1] or [1,2].  The diameter is 1 (number of edges between two nodes).</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The tree is empty, therefore the diameter is 0.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to the optimized solution is to combine the height calculation and diameter calculation in a single DFS traversal. This avoids redundant calculations. The diameter can pass through or not through the root.  Edge cases include empty trees and trees with only one node.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/invert-binary-tree/>Invert Binary Tree</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given the root of a binary tree, invert the tree, and return its root.

Inverting a binary tree means swapping the left and right children of all nodes at every level of the tree.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Recursively traverse the tree. At each node, swap its left and right children. Then, recursively invert the left and right subtrees.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

TreeNode* invertTreeBruteForce(TreeNode* root) {
    if (!root) {
        return nullptr;
    }

    swap(root-&gt;left, root-&gt;right);

    invertTreeBruteForce(root-&gt;left);
    invertTreeBruteForce(root-&gt;right);

    return root;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree. We visit each node once. | <b>Space Complexity:</b> O(H), where H is the height of the tree. This is due to the recursion call stack. In the worst-case (skewed tree), H can be N.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Recursive Inversion</h5>
  <p>Similar to the brute force approach, but using recursion for clarity and conciseness.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

TreeNode* invertTreeRecursive(TreeNode* root) {
    if (!root) {
        return nullptr;
    }

    TreeNode* temp = root-&gt;left;
    root-&gt;left = root-&gt;right;
    root-&gt;right = temp;

    invertTreeRecursive(root-&gt;left);
    invertTreeRecursive(root-&gt;right);

    return root;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree. | <b>Space Complexity:</b> O(H), where H is the height of the tree. This is due to the recursion call stack.</p>
  <h5>‚û§ Iterative Inversion (BFS)</h5>
  <p>Use a queue to perform a level-order traversal. At each node, swap its left and right children and enqueue the children if they exist.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

TreeNode* invertTreeIterative(TreeNode* root) {
    if (!root) {
        return nullptr;
    }

    queue&lt;TreeNode*&gt; q;
    q.push(root);

    while (!q.empty()) {
        TreeNode* current = q.front();
        q.pop();

        swap(current-&gt;left, current-&gt;right);

        if (current-&gt;left) {
            q.push(current-&gt;left);
        }
        if (current-&gt;right) {
            q.push(current-&gt;right);
        }
    }

    return root;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree. | <b>Space Complexity:</b> O(W), where W is the maximum width of the tree. In the worst-case (complete binary tree), W is approximately N/2, which is O(N).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [4,2,7,1,3,6,9]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[4,7,2,9,6,3,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The tree is inverted at each level.  The left and right children of nodes are swapped.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [2,1,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[2,3,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The tree is inverted by swapping the children of the root.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">An empty tree remains empty.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The iterative approach using BFS generally avoids the stack overflow issues that can occur with highly skewed trees in the recursive approach, and its space complexity is dependent on the width of the tree rather than the height. The choice between recursive and iterative approaches can be a matter of preference and the constraints of the problem.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/subtree-of-another-tree/>Subtree of Another Tree</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given the roots of two binary trees `root` and `subRoot`, return `true` if a subtree of `root` has the exact same structure and node values of `subRoot` and `false` otherwise.

A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>This approach involves a recursive function to check if two trees are identical. The main function iterates through the `root` tree and at each node, it checks if the subtree rooted at that node is identical to `subRoot`.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

// Function to check if two trees are identical
bool isIdentical(TreeNode* root1, TreeNode* root2) {
    if (!root1 && !root2) return true;
    if (!root1 || !root2) return false;
    return (root1-&gt;val == root2-&gt;val) &amp;&amp;
           isIdentical(root1-&gt;left, root2-&gt;left) &amp;&amp;
           isIdentical(root1-&gt;right, root2-&gt;right);
}

// Brute-force solution
bool isSubtreeBruteForce(TreeNode* root, TreeNode* subRoot) {
    if (!subRoot) return true; // An empty tree is always a subtree
    if (!root) return false;  // If root is empty and subRoot is not, it's not a subtree

    if (isIdentical(root, subRoot)) return true;

    return isSubtreeBruteForce(root-&gt;left, subRoot) || isSubtreeBruteForce(root-&gt;right, subRoot);
}
</code></pre>
  <p><b>Time Complexity:</b> O(m*n), where n is the number of nodes in `root` and m is the number of nodes in `subRoot`.  `isIdentical` takes O(m) time, and it might be called for each of the n nodes in the root tree.  In worst-case, we visit all nodes of both the tree. | <b>Space Complexity:</b> O(H + h), where H is the height of the `root` tree and h is the height of the `subRoot`. This accounts for the recursion call stack in `isIdentical` and `isSubtreeBruteForce`. In the worst-case of skewed trees, it can go up to O(n + m).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach (String Conversion)</h5>
  <p>Convert both trees into string representations using pre-order traversal, including null nodes as a placeholder.  Then check if the string of `subRoot` is a substring of the string of `root`. This eliminates repeated subtree comparisons by using a substring search algorithm.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

// Function to build the pre-order string representation of a tree
string serialize(TreeNode* root) {
    if (!root) return "#"; // Use '#' to represent null nodes
    return to_string(root-&gt;val) + " " + serialize(root-&gt;left) + " " + serialize(root-&gt;right);
}

// Optimized solution
bool isSubtreeOptimized(TreeNode* root, TreeNode* subRoot) {
    if (!subRoot) return true; // An empty tree is always a subtree
    if (!root) return false;  // If root is empty and subRoot is not, it's not a subtree

    string rootStr = serialize(root);
    string subRootStr = serialize(subRoot);

    return rootStr.find(subRootStr) != string::npos;
}
</code></pre>
  <p><b>Time Complexity:</b> O(m + n), where n and m are the number of nodes in root and subRoot respectively. Converting the trees to strings takes O(n) and O(m) time, and the string search with find takes O(n + m) in the best case (using optimized algorithms like KMP). | <b>Space Complexity:</b> O(n + m) to store the string representations of both trees.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [3,4,5,1,2], subRoot = [4,1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The subtree rooted at node 4 in the root tree has the same structure and node values as subRoot.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The subtree rooted at node 4 in the root tree doesn't match the structure of subRoot.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,2], subRoot = [1,null,1,null,1,null,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Shows that equal values are present but with different subtrees.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The string conversion approach is generally much more efficient, particularly for larger trees, because it avoids redundant traversals and comparisons. The brute force is only suitable for small trees. The edge case of empty subRoot should always be addressed for correctness.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/range-sum-of-bst/>Range Sum of BST</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Perform an inorder traversal of the BST. For each node visited, check if its value falls within the range [low, high]. If it does, add the node's value to a running sum. Return the final sum.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    int rangeSumBST(TreeNode* root, int low, int high) {
        int sum = 0;
        inorderTraversal(root, low, high, sum);
        return sum;
    }

    void inorderTraversal(TreeNode* node, int low, int high, int& sum) {
        if (!node) return;

        inorderTraversal(node-&gtleft, low, high, sum);

        if (node-&gtval &gt= low &amp;&amp; node-&gtval &lt= high) {
            sum += node-&gtval;
        }

        inorderTraversal(node-&gtright, low, high, sum);
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the BST. In the worst case, we might have to visit all nodes. | <b>Space Complexity:</b> O(H), where H is the height of the BST.  This is due to the recursion stack. In the worst case (skewed tree), H can be N.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Traversal (BST Properties)</h5>
  <p>Leverage the properties of a Binary Search Tree (BST). We can prune parts of the tree that cannot contribute to the sum. If the current node's value is less than low, only traverse the right subtree. If the current node's value is greater than high, only traverse the left subtree. If the current node's value is within the range [low, high], add it to the sum and traverse both left and right subtrees.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    int rangeSumBST(TreeNode* root, int low, int high) {
        int sum = 0;
        optimizedTraversal(root, low, high, sum);
        return sum;
    }

    void optimizedTraversal(TreeNode* node, int low, int high, int& sum) {
        if (!node) return;

        if (node-&gtval &lt low) {
            optimizedTraversal(node-&gtright, low, high, sum);
        } else if (node-&gtval &gt high) {
            optimizedTraversal(node-&gtleft, low, high, sum);
        } else {
            sum += node-&gtval;
            optimizedTraversal(node-&gtleft, low, high, sum);
            optimizedTraversal(node-&gtright, low, high, sum);
        }
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(K), where K is the number of nodes within the range [low, high] plus the nodes on the paths to reach those nodes. In the best case, K can be much smaller than N (the total number of nodes). In the worst case, it can be O(N). | <b>Space Complexity:</b> O(H), where H is the height of the BST. This is due to the recursion stack.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [10,5,15,3,7,null,18], low = 7, high = 15</td>
        <td style="border: 1px solid #ccc; padding: 6px;">32</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Nodes within the range [7, 15] are 7, 10, and 15. 7 + 10 + 15 = 32.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10</td>
        <td style="border: 1px solid #ccc; padding: 6px;">23</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Nodes within the range [6, 10] are 6, 7, and 10. 6 + 7 + 10 = 23.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key optimization is leveraging the BST property. If the current node's value is outside the range, we can safely ignore entire subtrees.  Make sure to handle null root and empty tree cases.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/symmetric-tree/>Symmetric Tree</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves recursively checking if the left subtree is a mirror image of the right subtree. We can define a helper function that takes two nodes as input and checks if their values are equal and their subtrees are mirror images of each other. The base cases are when both nodes are null (symmetric) or only one is null (not symmetric).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (!root) return true;
        return isMirror(root-&gt;left, root-&gt;right);
    }

    bool isMirror(TreeNode* left, TreeNode* right) {
        if (!left &amp;&amp; !right) return true;
        if (!left || !right) return false;
        return (left-&gt;val == right-&gt;val) &amp;&amp;
               isMirror(left-&gt;left, right-&gt;right) &amp;&amp;
               isMirror(left-&gt;right, right-&gt;left);
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree. In the worst case, we visit each node. | <b>Space Complexity:</b> O(H), where H is the height of the tree. In the worst case (skewed tree), H can be N. In the best case (balanced tree), H can be log(N). This space is due to the recursive call stack.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Recursive Approach (Optimized)</h5>
  <p>This is the same as the brute-force approach, but it's the standard and most efficient solution for this problem. We recursively check if the left and right subtrees are mirror images of each other. This approach directly reflects the problem's requirements and is the cleanest way to solve it.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (!root) return true;
        return isMirror(root-&gt;left, root-&gt;right);
    }

    bool isMirror(TreeNode* left, TreeNode* right) {
        if (!left &amp;&amp; !right) return true;
        if (!left || !right) return false;
        return (left-&gt;val == right-&gt;val) &amp;&amp;
               isMirror(left-&gt;left, right-&gt;right) &amp;&amp;
               isMirror(left-&gt;right, right-&gt;left);
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree. | <b>Space Complexity:</b> O(H), where H is the height of the tree.  In the worst case (skewed tree), H can be N. In the best case (balanced tree), H can be log(N).</p>
  <h5>‚û§ Iterative Approach (Using Queue)</h5>
  <p>We can use an iterative approach using a queue (or two queues) to simulate the recursive calls. We enqueue the left and right children of the root node. Then, in each iteration, we dequeue two nodes, compare their values, and enqueue their children in a mirrored order (left of one, right of the other). This approach avoids the overhead of recursion.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (!root) return true;
        queue&lt;TreeNode*&gt; q;
        q.push(root-&gt;left);
        q.push(root-&gt;right);

        while (!q.empty()) {
            TreeNode* left = q.front(); q.pop();
            TreeNode* right = q.front(); q.pop();

            if (!left &amp;&amp; !right) continue;
            if (!left || !right || left-&gt;val != right-&gt;val) return false;

            q.push(left-&gt;left);
            q.push(right-&gt;right);
            q.push(left-&gt;right);
            q.push(right-&gt;left);
        }
        return true;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree. We visit each node at most once. | <b>Space Complexity:</b> O(W), where W is the maximum width of the tree. In the worst case (complete binary tree), W can be N/2.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,2,2,3,4,4,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The tree is symmetric.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,2,2,null,3,null,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The tree is not symmetric.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">An empty tree is considered symmetric.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to solving this problem is understanding the mirror image property.  The nodes must be mirrored across the center.  Edge cases include null trees (symmetric) and trees with only one node (symmetric). The iterative solution with a queue offers an alternative without recursion, which can be useful in environments where recursion depth is limited.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/>Convert Sorted Array to Binary Search Tree</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree. A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach is not directly applicable here, as the problem inherently requires a specific structure (BST). A naive approach might involve inserting elements one by one into the BST, but this won't guarantee a balanced tree and would not be efficient. Hence, we will skip the brute force approach.</p>
  <pre><code class="language-python"></code></pre>
  <p><b>Time Complexity:</b> N/A | <b>Space Complexity:</b> N/A</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Recursive Approach (Divide and Conquer)</h5>
  <p>This approach utilizes the sorted nature of the input array. The core idea is to recursively divide the array into halves.  The middle element becomes the root of the subtree. The left half forms the left subtree, and the right half forms the right subtree. This division and assignment ensures the BST property is maintained and the tree is balanced. The base cases are when the input array is empty or contains only one element.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    TreeNode* sortedArrayToBST(vector&lt;int&gt;& nums) {
        return buildBST(nums, 0, nums.size() - 1);
    }

    TreeNode* buildBST(vector&lt;int&gt;& nums, int left, int right) {
        if (left &gt right) {
            return nullptr;
        }

        int mid = left + (right - left) / 2;  // Prevent potential overflow
        TreeNode* root = new TreeNode(nums[mid]);

        root-&gtleft = buildBST(nums, left, mid - 1);
        root-&gtright = buildBST(nums, mid + 1, right);

        return root;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of elements in the input array.  Each element is visited and processed once. | <b>Space Complexity:</b> O(log N) in the average case due to the recursive call stack for a balanced tree. In the worst case (skewed tree), it can be O(N).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [-10,-3,0,5,9]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[0,-3,9,-10,null,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">One possible answer is [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
  /   /
-10  5</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[3,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">One possible answer is [3,1], which represents the following height balanced BST:

      3
     /
    1</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Empty input array results in an empty BST.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Key points:

1.  The input array is sorted, which is crucial for the efficiency of the approach.
2.  The middle element is always selected as the root to balance the tree.
3.  The recursive calls handle the creation of left and right subtrees.
4.  Consider edge cases like empty or single-element input arrays.
5.  The solution automatically builds a balanced BST, fulfilling the problem constraints.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/merge-two-binary-trees/>Merge Two Binary Trees</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>You are given two binary trees, `root1` and `root2`. Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree. Return the merged tree.

Note: The merging process must start from the root nodes, and merge both trees recursively.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach recursively traverses both trees simultaneously.  At each node, it checks if both nodes exist. If they do, it sums their values and creates a new node with the sum. If only one node exists, it uses that node's value. If neither exists (at a specific level), it creates a null node.
</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
    if (!root1 && !root2) return nullptr;
    if (!root1) return root2;
    if (!root2) return root1;

    TreeNode* mergedNode = new TreeNode(root1-&gt;val + root2-&gt;val);
    mergedNode-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);
    mergedNode-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);

    return mergedNode;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the total number of nodes in both trees, because we visit each node once. | <b>Space Complexity:</b> O(H), where H is the height of the resulting merged tree, for the recursive call stack. In worst case (skewed trees), H can be N, and in the best case (balanced trees) it is log(N).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Recursive Approach (Optimized)</h5>
  <p>This optimized approach is essentially the same as the brute-force, but it streamlines the logic and utilizes in-place merging for slightly better readability. It recursively merges the trees, summing values where nodes overlap. If either node is null, it returns the other node (or null if both are null).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
    if (!root1 && !root2) return nullptr;
    if (!root1) return root2;
    if (!root2) return root1;

    root1-&gt;val += root2-&gt;val;
    root1-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);
    root1-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);

    return root1;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the total number of nodes in both trees. | <b>Space Complexity:</b> O(H), where H is the height of the resulting merged tree for the recursive call stack. In the worst-case, this is O(N) for skewed trees, and O(log N) for balanced trees.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[3,4,5,5,4,null,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Nodes of the trees are merged. For example, the node at root1.left.right is merged with root2.left.right. And the new node will be of value 5.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root1 = [1], root2 = [1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[2,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The left child of the merged tree is created from root2 as root1 does not have any left child.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root1 = [1,2,3], root2 = [0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">root2 has only one node, thus root1's node is used as is.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key is the recursive traversal and the handling of null nodes. We should handle the edge case when one of the input trees is empty or both are empty, in which case we should return the non-null tree or nullptr.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/maximum-depth-of-binary-tree/>Maximum Depth of Binary Tree</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given the root of a binary tree, return its maximum depth.

A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>This approach uses recursion to traverse the binary tree. For each node, it calculates the depth of the left and right subtrees and returns the maximum of the two, plus 1 for the current node.  The base case is when the node is null, in which case the depth is 0.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root) {
            return 0;
        }
        return 1 + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree.  Each node is visited once. | <b>Space Complexity:</b> O(H), where H is the height of the tree. This is due to the recursion stack.  In the worst case (skewed tree), H can be equal to N.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Recursive Depth-First Search (DFS)</h5>
  <p>This is the same approach as the brute-force solution. Recursively compute the depth of the left and right subtrees and take the maximum.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root) {
            return 0;
        }
        return 1 + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree. | <b>Space Complexity:</b> O(H), where H is the height of the tree (due to recursion stack). In the worst case, H can be equal to N.</p>
  <h5>‚û§ Iterative Breadth-First Search (BFS)</h5>
  <p>Use a queue to perform a level-order traversal (BFS). The depth is tracked by incrementing a counter for each level of the tree.  The number of levels is the maximum depth. For each level, we process all nodes present on that level.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root) {
            return 0;
        }
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        int depth = 0;

        while (!q.empty()) {
            int levelSize = q.size();
            depth++;

            for (int i = 0; i &lt levelSize; i++) {
                TreeNode* curr = q.front();
                q.pop();

                if (curr-&gt;left) {
                    q.push(curr-&gt;left);
                }
                if (curr-&gt;right) {
                    q.push(curr-&gt;right);
                }
            }
        }
        return depth;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree. Each node is visited and processed once. | <b>Space Complexity:</b> O(W), where W is the maximum width of the tree (the maximum number of nodes at any level). In the worst-case (complete binary tree), W is roughly N/2.  In the worst-case (skewed tree), W could be 1.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [3,9,20,null,null,15,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The longest path is 3 -> 9 -> 20 -> [15 or 7]</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,null,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The longest path is 1 -> 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Empty tree has a depth of 0.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases to consider: empty tree (root is null), a tree with only one node, and skewed trees (where all nodes only have one child).  The iterative BFS approach might be preferred for large trees to avoid potential stack overflow issues that can arise with deep recursion.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/binary-tree-paths/>Binary Tree Paths</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given the `root` of a binary tree, return all root-to-leaf paths in any order.  A leaf is a node with no children.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>This approach uses recursion to traverse the tree. At each node, we add the node's value to the current path. When we reach a leaf node, we add the current path to the result.  We then recursively call the function for the left and right children, and before returning to the parent node we must remove the current node value from the path to explore other paths.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    vector&lt;string&gt; binaryTreePaths(TreeNode* root) {
        vector&lt;string&gt; result;
        vector&lt;int&gt; path;
        dfs(root, path, result);
        return result;
    }

    void dfs(TreeNode* node, vector&lt;int&gt;&amp; path, vector&lt;string&gt;&amp; result) {
        if (!node) {
            return;
        }

        path.push_back(node-&gt;val);

        if (!node-&gt;left &amp;&amp; !node-&gt;right) {
            string currentPath = "";
            for (int i = 0; i &lt; path.size(); ++i) {
                currentPath += to_string(path[i]);
                if (i &lt; path.size() - 1) {
                    currentPath += "-&gt;";
                }
            }
            result.push_back(currentPath);
        }

        dfs(node-&gt;left, path, result);
        dfs(node-&gt;right, path, result);
        path.pop_back(); // Backtrack
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N^2) in the worst case (skewed tree), where N is the number of nodes.  Building the string path takes O(N) time in the worst case, and we potentially do this for each of the N nodes. | <b>Space Complexity:</b> O(N) in the worst case (skewed tree) for the recursion call stack and the path vector.  O(log N) on average (balanced tree).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Recursive Approach</h5>
  <p>This approach improves on the brute-force by directly constructing the path string within the recursive function, avoiding the need to repeatedly convert numbers to strings and concatenate them. This also reduces the space complexity slightly.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    vector&lt;string&gt; binaryTreePaths(TreeNode* root) {
        vector&lt;string&gt; result;
        dfs(root, "", result);
        return result;
    }

    void dfs(TreeNode* node, string currentPath, vector&lt;string&gt;&amp; result) {
        if (!node) {
            return;
        }

        currentPath += to_string(node-&gt;val);

        if (!node-&gt;left &amp;&amp; !node-&gt;right) {
            result.push_back(currentPath);
            return;
        }

        currentPath += "-&gt;";
        dfs(node-&gt;left, currentPath, result);
        dfs(node-&gt;right, currentPath, result);
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes.  We visit each node once. | <b>Space Complexity:</b> O(N) in the worst case (skewed tree) for the recursion call stack. O(log N) on average (balanced tree).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,2,3,null,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">["1-&gt;2-&gt;5","1-&gt;3"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The root-to-leaf paths are 1 -&gt; 2 -&gt; 5 and 1 -&gt; 3.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">["1"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There is only one path, which is 1.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">["1-&gt;2"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The path is 1 -> 2.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to solving this problem is to use recursion to traverse the tree.  We must keep track of the current path and append node values to it as we traverse downwards. When a leaf node is found, the complete path is added to the result.  Backtracking is crucial to explore all possible paths.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/same-tree/>Same Tree</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given the roots of two binary trees `p` and `q`, write a function to check if they are the same. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Recursively compare the nodes of both trees.  Check if both nodes exist and have the same value.  If they do, recursively call the function on the left and right subtrees.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

bool isSameTree(TreeNode* p, TreeNode* q) {
    // If both trees are empty, they are the same.
    if (!p && !q) {
        return true;
    }

    // If one tree is empty and the other is not, they are different.
    if (!p || !q) {
        return false;
    }

    // Check if the values of the current nodes are different.
    if (p-&gt;val != q-&gt;val) {
        return false;
    }

    // Recursively check the left and right subtrees.
    return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the smaller tree. In the worst case, we traverse all nodes of both trees. | <b>Space Complexity:</b> O(H), where H is the height of the smaller tree due to the recursive call stack. In the worst case (skewed tree), H can be N.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Recursive Approach</h5>
  <p>The same as the brute-force, but it is the standard and most efficient way.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

bool isSameTree(TreeNode* p, TreeNode* q) {
    if (!p &amp;&amp; !q) {
        return true;
    }
    if (!p || !q) {
        return false;
    }
    if (p-&gt;val != q-&gt;val) {
        return false;
    }
    return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the smaller tree. | <b>Space Complexity:</b> O(H), where H is the height of the smaller tree (due to recursion).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">p = [1,2,3], q = [1,2,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Both trees are identical.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">p = [1,2], q = [1,null,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The structure differs: p's right child is null, while q's right child has a value.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">p = [1,2,1], q = [1,1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The structure differs: p's right child is 1, while q's right child is 2.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key is to handle the null cases correctly. If both nodes are null, they're the same. If one is null and the other isn't, they're different. If the values at the current nodes aren't equal, the trees are different.  The recursion neatly handles the subtrees.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/>Lowest Common Ancestor of a Binary Search Tree</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given a binary search tree (BST) and two nodes, `p` and `q`, find the lowest common ancestor (LCA) of `p` and `q` in the BST. The LCA is defined as the lowest node that has both `p` and `q` as descendants (where a node can be a descendant of itself).</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Traverse the tree from the root to find the paths to both `p` and `q`. Then, iterate through both paths and find the last common node.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

vector&lt;TreeNode*&gt; getPath(TreeNode* root, TreeNode* target) {
    vector&lt;TreeNode*&gt; path;
    if (!root)
        return path;

    TreeNode* curr = root;
    while (curr) {
        path.push_back(curr);
        if (curr-&gt;val == target-&gt;val)
            return path;
        else if (curr-&gt;val &gt; target-&gt;val)
            curr = curr-&gt;left;
        else
            curr = curr-&gt;right;
    }
    return {};
}

TreeNode* lowestCommonAncestor_bruteforce(TreeNode* root, TreeNode* p, TreeNode* q) {
    vector&lt;TreeNode*&gt; pathP = getPath(root, p);
    vector&lt;TreeNode*&gt; pathQ = getPath(root, q);
    if (pathP.empty() || pathQ.empty()) return nullptr;

    TreeNode* lca = nullptr;
    int i = 0, j = 0;
    while (i &lt; pathP.size() &amp;&amp; j &lt; pathQ.size() &amp;&amp; pathP[i]-&gt;val == pathQ[j]-&gt;val) {
        lca = pathP[i];
        i++;
        j++;
    }
    return lca;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree. In the worst case, we traverse the tree to find paths to p and q (O(N)), and then iterate through the paths (O(N) in the worst case). | <b>Space Complexity:</b> O(N) in the worst-case scenario, due to the space used by the paths to p and q, especially in a skewed tree.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Iterative Approach</h5>
  <p>Leverage the properties of a BST. Starting from the root, compare the values of the current node, `p`, and `q`. If both `p` and `q` are less than the current node's value, the LCA lies in the left subtree. If both are greater, the LCA lies in the right subtree. Otherwise, the current node is the LCA.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

TreeNode* lowestCommonAncestor_iterative(TreeNode* root, TreeNode* p, TreeNode* q) {
    TreeNode* curr = root;
    while (curr) {
        if (p-&gt;val &lt; curr-&gt;val &amp;&amp; q-&gt;val &lt; curr-&gt;val) {
            curr = curr-&gt;left;
        }
        else if (p-&gt;val &gt; curr-&gt;val &amp;&amp; q-&gt;val &gt; curr-&gt;val) {
            curr = curr-&gt;right;
        }
        else {
            return curr;
        }
    }
    return nullptr;
}
</code></pre>
  <p><b>Time Complexity:</b> O(H), where H is the height of the BST. In a balanced BST, H = log(N). In the worst case (skewed tree), H = N. | <b>Space Complexity:</b> O(1) - constant space.</p>
  <h5>‚û§ Recursive Approach</h5>
  <p>Recursively traverse the tree. If both p and q are smaller than the current node, recursively search the left subtree. If both are larger, search the right subtree. Otherwise, the current node is the LCA.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

TreeNode* lowestCommonAncestor_recursive(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (!root) return nullptr;

    if (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) {
        return lowestCommonAncestor_recursive(root-&gt;left, p, q);
    }
    else if (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) {
        return lowestCommonAncestor_recursive(root-&gt;right, p, q);
    }
    else {
        return root;
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(H), where H is the height of the BST.  In the worst case (skewed tree), H = N. | <b>Space Complexity:</b> O(H) due to the recursive call stack. In a balanced BST, H = log(N).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [6,2,8,0,4,7,9], p = 2, q = 8</td>
        <td style="border: 1px solid #ccc; padding: 6px;">6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The LCA of nodes 2 and 8 is 6. Node 6 is the lowest common ancestor because it is a descendant of both 2 and 8, and the path from the root to both 2 and 8 converge at 6.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [6,2,8,0,4,7,9], p = 2, q = 4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [2,1], p = 2, q = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The LCA of 2 and 1 is 2.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The provided solutions exploit the properties of a Binary Search Tree (BST). A BST has the following properties: the value of each node in the left subtree is less than the value of the node, and the value of each node in the right subtree is greater than the value of the node. The problem is efficiently solvable due to this property.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/path-sum/>Path Sum</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a root-to-leaf path such that adding up all the values along the path equals `targetSum`. A leaf is a node with no children.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>This approach uses recursion to traverse every path from the root to each leaf. For each path, it calculates the sum of the node values. If a path's sum equals the targetSum, it returns true. If no path matches, it returns false.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

bool hasPathSum(TreeNode* root, int targetSum) {
    if (!root) {
        return false;
    }

    if (!root-&gt;left &amp;&amp; !root-&gt;right) {
        return targetSum == root-&gt;val;
    }

    return hasPathSum(root-&gt;left, targetSum - root-&gt;val) || hasPathSum(root-&gt;right, targetSum - root-&gt;val);
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the binary tree. In the worst case (skewed tree), we might visit all nodes. | <b>Space Complexity:</b> O(H), where H is the height of the binary tree. This is due to the recursive call stack. In the worst case (skewed tree), H can be N, leading to O(N) space complexity.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Recursive Approach</h5>
  <p>This optimized approach is the same as the brute-force approach but emphasizes early exit conditions to potentially improve performance.  It recursively explores the tree. At each node, it subtracts the node's value from the targetSum. If a leaf node is reached and the remaining targetSum is equal to the leaf's value, it means a path with the target sum has been found.  If it's not a leaf node, it calls the recursive function on its left and right children with the updated targetSum, and returns true if either child finds a valid path.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

bool hasPathSum(TreeNode* root, int targetSum) {
    if (!root) {
        return false;
    }

    targetSum -= root-&gt;val;

    if (!root-&gt;left &amp;&amp; !root-&gt;right) {
        return targetSum == 0;
    }

    return hasPathSum(root-&gt;left, targetSum) || hasPathSum(root-&gt;right, targetSum);
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the binary tree. | <b>Space Complexity:</b> O(H), where H is the height of the binary tree (due to the recursion call stack). In the worst case (skewed tree), H can be N, leading to O(N) space complexity.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There is a root-to-leaf path 5 -> 4 -> 11 -> 2 which sums up to 22.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,2,3], targetSum = 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There is no root-to-leaf path with sum 5.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [], targetSum = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The tree is empty; therefore, no path exists.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases to consider include empty trees and trees where the target sum cannot be reached.  The critical part of the solution is identifying the leaf nodes and checking if the remaining targetSum is zero when a leaf is encountered.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/minimum-absolute-difference-in-bst/>Minimum Absolute Difference in BST</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Traverse the BST and store all node values in a list. Then, sort the list. Finally, iterate through the sorted list and find the minimum absolute difference between adjacent elements.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

void inorderTraversal(TreeNode* root, vector&lt;int&gt;& values) {
    if (root == nullptr) {
        return;
    }
    inorderTraversal(root-&gt;left, values);
    values.push_back(root-&gt;val);
    inorderTraversal(root-&gt;right, values);
}

int getMinimumDifference(TreeNode* root) {
    vector&lt;int&gt; values;
    inorderTraversal(root, values);
    sort(values.begin(), values.end());
    int minDiff = INT_MAX;
    for (int i = 1; i &lt; values.size(); ++i) {
        minDiff = min(minDiff, values[i] - values[i - 1]);
    }
    return minDiff;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N log N) due to the sorting step, where N is the number of nodes in the BST.  The inorder traversal takes O(N). | <b>Space Complexity:</b> O(N) to store the node values in the vector.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Inorder Traversal with Optimization</h5>
  <p>Perform an inorder traversal of the BST.  Since BST's inorder traversal yields a sorted sequence, we can calculate the difference between the current node's value and the previous node's value during the traversal and keep track of the minimum difference. This avoids sorting.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

int minDiff = INT_MAX;
int prevVal = -1; // Initialize with an invalid value

void inorder(TreeNode* root) {
    if (root == nullptr) {
        return;
    }

    inorder(root-&gt;left);

    if (prevVal != -1) {
        minDiff = min(minDiff, root-&gt;val - prevVal);
    }
    prevVal = root-&gt;val;

    inorder(root-&gt;right);
}

int getMinimumDifference(TreeNode* root) {
    minDiff = INT_MAX;
    prevVal = -1;
    inorder(root);
    return minDiff;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the BST, because we visit each node once. | <b>Space Complexity:</b> O(H) in the worst case (skewed tree) for the recursion stack, where H is the height of the tree.  In the average case (balanced tree), space complexity is O(log N).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [4,2,6,1,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The minimum absolute difference is 1, which is the difference between 1 and 2 (also between 3 and 2).</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,null,3,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The minimum absolute difference is 1, which is the difference between 2 and 3.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to the optimal solution is realizing that an inorder traversal of a BST yields a sorted sequence.  Therefore, the minimum difference can be found by comparing adjacent elements during the traversal, avoiding the need for explicit sorting. Initialize `prevVal` with -1 or a sufficiently small number to handle the first node's comparison correctly. Consider the edge case of a tree with only one node.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/sum-of-left-leaves/>Sum of Left Leaves</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given the root of a binary tree, return the sum of all left leaves. A leaf is a node with no children. A left leaf is a leaf that is the left child of another node.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Traverse the tree using recursion. For each node, check if its left child is a leaf. If it is, add its value to the sum. Continue recursively for the left and right subtrees.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        int sum = 0;
        if (root)
            sumHelper(root, sum, false);
        return sum;
    }

    void sumHelper(TreeNode* node, int& sum, bool isLeft) {
        if (!node) return;

        if (isLeft && !node-&gt;left && !node-&gt;right) {
            sum += node-&gt;val;
            return;
        }

        sumHelper(node-&gt;left, sum, true);
        sumHelper(node-&gt;right, sum, false);
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree.  We visit each node once. | <b>Space Complexity:</b> O(H), where H is the height of the tree. This is due to the recursive call stack. In the worst case (skewed tree), H can be N.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Recursive Approach</h5>
  <p>Similar to the brute-force approach, but slightly optimized. Check if the left child is a leaf within the recursive call.  Avoid unnecessary checks.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        int sum = 0;
        if (root) {
            sumHelper(root, sum);
        }
        return sum;
    }

    void sumHelper(TreeNode* node, int& sum) {
        if (!node) return;

        if (node-&gt;left && !node-&gt;left-&gt;left && !node-&gt;left-&gt;right) {
            sum += node-&gt;left-&gt;val;
        }

        sumHelper(node-&gt;left, sum);
        sumHelper(node-&gt;right, sum);
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree. | <b>Space Complexity:</b> O(H), where H is the height of the tree. In the worst case, H can be N.</p>
  <h5>‚û§ Iterative Approach (BFS)</h5>
  <p>Use Breadth-First Search (BFS) to traverse the tree level by level. Maintain a queue of nodes.  For each node, check if its left child is a leaf and add its value if it is. Add the left and right children to the queue if they exist.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if (!root) return 0;
        int sum = 0;
        queue&lt;TreeNode*&gt; q;
        q.push(root);

        while (!q.empty()) {
            TreeNode* node = q.front();
            q.pop();

            if (node-&gt;left) {
                if (!node-&gt;left-&gt;left &amp;&amp; !node-&gt;left-&gt;right) {
                    sum += node-&gt;left-&gt;val;
                }
                q.push(node-&gt;left);
            }

            if (node-&gt;right) {
                q.push(node-&gt;right);
            }
        }
        return sum;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree. | <b>Space Complexity:</b> O(W), where W is the maximum width of the tree (maximum number of nodes at any level). In the worst case, W can be N.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [3,9,20,null,null,15,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">24</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There are two left leaves in the tree, with values 9 and 15, respectively. Sum = 9 + 15 = 24.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There are no left leaves in the tree.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,2,3,4,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The left leaf is 4.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key is to correctly identify left leaves. A node is a left leaf if it is a left child and has no children. Edge cases to consider include empty trees and trees with no left leaves.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/balanced-binary-tree/>Balanced Binary Tree</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given a binary tree, determine if it is height-balanced. A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>For each node, calculate the heights of its left and right subtrees. If the absolute difference is greater than 1, the tree is not balanced. Repeat this process for every node in the tree.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

// Function to calculate the height of a tree
int height(TreeNode* root) {
    if (!root) return 0;
    return 1 + max(height(root-&gt;left), height(root-&gt;right));
}

bool isBalanced(TreeNode* root) {
    if (!root) return true;

    int leftHeight = height(root-&gt;left);
    int rightHeight = height(root-&gt;right);

    if (abs(leftHeight - rightHeight) &gt; 1) {
        return false;
    }

    return isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);
}
</code></pre>
  <p><b>Time Complexity:</b> O(N^2), where N is the number of nodes in the tree.  The height function is called repeatedly for each node, and height calculation takes O(N) in the worst case. | <b>Space Complexity:</b> O(H), where H is the height of the tree, due to the recursion stack. In the worst case (skewed tree), it can be O(N).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach (Bottom-up)</h5>
  <p>Calculate the height and check the balance in a single pass using recursion.  At each node, recursively compute the heights of the left and right subtrees. If either subtree is unbalanced or the height difference is greater than 1, mark the current node as unbalanced. This avoids redundant height calculations.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

// Function to check if a tree is balanced and return its height.
pair&lt;bool, int&gt; isBalancedHelper(TreeNode* root) {
    if (!root) {
        return {true, 0};
    }

    pair&lt;bool, int&gt; left = isBalancedHelper(root-&gt;left);
    pair&lt;bool, int&gt; right = isBalancedHelper(root-&gt;right);

    bool balanced = left.first &amp;&amp; right.first &amp;&amp; abs(left.second - right.second) &lt;= 1;
    int height = 1 + max(left.second, right.second);

    return {balanced, height};
}

bool isBalanced(TreeNode* root) {
    return isBalancedHelper(root).first;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree.  Each node is visited at most once. | <b>Space Complexity:</b> O(H), where H is the height of the tree, due to the recursion stack. In the worst case (skewed tree), it can be O(N).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [3,9,20,null,null,15,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The tree is balanced.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,2,2,3,3,null,null,4,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The tree is not balanced. The left subtree's depth is 4, but the right subtree's depth is 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Empty tree is considered balanced.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>An empty tree is considered height-balanced.  The key to optimization is to avoid redundant calculations of subtree heights.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/predecessor-and-successor/1>Predecessor and Successor</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given a Binary Search Tree (BST) and a key, find the predecessor and successor of the key in the BST. The predecessor is the node with the largest value less than the key, and the successor is the node with the smallest value greater than the key. If either predecessor or successor doesn't exist, set their respective pointers to NULL.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Perform an inorder traversal of the BST and store all the nodes' values in a sorted order. Then, iterate through the sorted array to find the key.  The element before the key is the predecessor, and the element after the key is the successor.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Node {
    int data;
    Node *left, *right;
    Node(int val) : data(val), left(NULL), right(NULL) {}
};

void inorderTraversal(Node* root, vector&lt;int&gt;&amp; nodes) {
    if (!root) return;
    inorderTraversal(root-&gt;left, nodes);
    nodes.push_back(root-&gt;data);
    inorderTraversal(root-&gt;right, nodes);
}

void findPreSucBrute(Node* root, int key, Node*&amp; pre, Node*&amp; suc) {
    vector&lt;int&gt; nodes;
    inorderTraversal(root, nodes);
    int n = nodes.size();
    int keyIndex = -1;
    for (int i = 0; i &lt; n; ++i) {
        if (nodes[i] == key) {
            keyIndex = i;
            break;
        }
    }
    if (keyIndex == -1) {
        pre = suc = NULL; // Key not found, both are null
        return;
    }
    if (keyIndex &gt; 0) {
        // Predecessor exists
        pre = new Node(nodes[keyIndex - 1]);
    } else {
        pre = NULL; // No predecessor
    }
    if (keyIndex &lt; n - 1) {
        // Successor exists
        suc = new Node(nodes[keyIndex + 1]);
    } else {
        suc = NULL; // No successor
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(N) for inorder traversal + O(N) for searching in the array, where N is the number of nodes in the BST. Overall: O(N) | <b>Space Complexity:</b> O(N) for storing the inorder traversal in an array.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach (BST Properties)</h5>
  <p>Leverage the properties of a BST. Start from the root.  If the current node's value is less than the key, update the predecessor and move to the right subtree. If the current node's value is greater than the key, update the successor and move to the left subtree. If the current node's value equals the key, the predecessor is the rightmost node of the left subtree, and the successor is the leftmost node of the right subtree. Handle cases where either subtree is empty.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Node {
    int data;
    Node *left, *right;
    Node(int val) : data(val), left(NULL), right(NULL) {}
};

void findPreSuc(Node* root, Node*&amp; pre, Node*&amp; suc, int key) {
    pre = suc = NULL;
    Node* curr = root;

    while (curr) {
        if (curr-&gt;data == key) {
            if (curr-&gt;left) {
                pre = curr-&gt;left;
                while (pre-&gt;right)
                    pre = pre-&gt;right;
            }
            if (curr-&gt;right) {
                suc = curr-&gt;right;
                while (suc-&gt;left)
                    suc = suc-&gt;left;
            }
            return;
        } else if (curr-&gt;data &lt; key) {
            pre = curr;
            curr = curr-&gt;right;
        } else {
            suc = curr;
            curr = curr-&gt;left;
        }
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(H), where H is the height of the tree.  In the best and average case (balanced BST), H = log(N). In the worst case (skewed tree), H = N. | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">BST: 20 10 30 5 15 25 35, Key: 15</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Predecessor: 10, Successor: 20</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The inorder traversal is 5, 10, 15, 20, 25, 30, 35.  The predecessor of 15 is 10, and the successor is 20.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">BST: 20 10 30 5 15 25 35, Key: 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Predecessor: NULL, Successor: 10</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The key 5 is the smallest element. There is no predecessor. The successor is 10.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">BST: 20 10 30 5 15 25 35, Key: 35</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Predecessor: 30, Successor: NULL</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The key 35 is the largest element. There is no successor. The predecessor is 30.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">BST: 50 30 70 20 40 60 80, Key: 65</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Predecessor: 60, Successor: 70</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The key 65 is not in the tree. Thus, predecessor is the largest element less than 65, and successor is the smallest element greater than 65.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The optimized approach using BST properties is significantly more efficient.  Handle edge cases: key is the root, key is the smallest element, key is the largest element, and when the key does not exist in the tree.  When the key is not present, the approach should find the closest predecessor and successor based on BST rules.  The brute force approach is less efficient, but straightforward to implement.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/binary-tree-inorder-traversal/  >Binary Tree Inorder Traversal</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given the `root` of a binary tree, return the inorder traversal of its nodes' values.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Recursively traverse the tree. The inorder traversal visits the left subtree, then the current node, and finally the right subtree.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        inorder(root, result);
        return result;
    }

    void inorder(TreeNode* root, vector&lt;int&gt;&amp; result) {
        if (root == nullptr) {
            return;
        }
        inorder(root-&gt;left, result);
        result.push_back(root-&gt;val);
        inorder(root-&gt;right, result);
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree. We visit each node once. | <b>Space Complexity:</b> O(H), where H is the height of the tree.  This is due to the recursion call stack. In the worst case (skewed tree), H can be N.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Iterative Inorder Traversal (Using Stack)</h5>
  <p>Use a stack to simulate the recursive calls.  The algorithm proceeds as follows:
1.  Initialize an empty stack and a current node pointer to the root.
2.  While the current node is not null or the stack is not empty:
    -   While the current node is not null:
        -   Push the current node onto the stack.
        -   Move the current node to its left child.
    -   Pop a node from the stack. This is the next node to be visited.
    -   Add the popped node's value to the result.
    -   Move the current node to the popped node's right child.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        stack&lt;TreeNode*&gt; s;
        TreeNode* curr = root;

        while (curr != nullptr || !s.empty()) {
            while (curr != nullptr) {
                s.push(curr);
                curr = curr-&gt;left;
            }

            curr = s.top();
            s.pop();
            result.push_back(curr-&gt;val);
            curr = curr-&gt;right;
        }

        return result;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree.  We visit each node once. | <b>Space Complexity:</b> O(H), where H is the height of the tree.  In the worst case (skewed tree), H can be N. In the average case (balanced tree), H is log(N).</p>
  <h5>‚û§ Morris Traversal</h5>
  <p>Morris traversal is an in-place algorithm for inorder traversal that uses O(1) space.  It works by using the right child pointer of a node to point to its inorder successor.

The algorithm proceeds as follows:
1. Initialize current to the root.
2. While current is not NULL:
    - If current has no left child:
        a. Print the current node's value.
        b. Move current to the right child.
    - Else:
        a. Find the inorder predecessor of current.
        b. If the predecessor's right child is NULL:
            i. Set the predecessor's right child to current.
            ii. Move current to the left child.
        c. Else:
            i. Set the predecessor's right child to NULL.
            ii. Print the current node's value.
            iii. Move current to the right child.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        TreeNode* curr = root;

        while (curr != nullptr) {
            if (curr-&gt;left == nullptr) {
                result.push_back(curr-&gt;val);
                curr = curr-&gt;right;
            } else {
                TreeNode* predecessor = curr-&gt;left;
                while (predecessor-&gt;right != nullptr &amp;&amp; predecessor-&gt;right != curr) {
                    predecessor = predecessor-&gt;right;
                }

                if (predecessor-&gt;right == nullptr) {
                    predecessor-&gt;right = curr;
                    curr = curr-&gt;left;
                } else {
                    predecessor-&gt;right = nullptr;
                    result.push_back(curr-&gt;val);
                    curr = curr-&gt;right;
                }
            }
        }

        return result;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes.  Although there are nested loops, each node is visited a maximum of three times. | <b>Space Complexity:</b> O(1). We use constant extra space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,null,2,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,3,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Inorder traversal: Left -&gt; Root -&gt; Right. The traversal of the given tree is [1,3,2].</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Empty tree, so the inorder traversal results in an empty list.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">A single node tree. Inorder traversal is the node itself.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Consider the cases of empty trees, single-node trees, skewed trees (left or right heavy), and balanced trees when testing.  The iterative and Morris traversal methods provide space optimization over the recursive approach. Morris Traversal modifies the tree structure temporarily, so be aware of this if the tree is needed in its original form later.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/check-whether-bst-contains-dead-end/1>Check whether BST contains dead end</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given a Binary Search Tree (BST), determine whether it contains a dead end. A dead end is a leaf node such that no new node can be inserted as a child. For a node to be a dead end, both of its left and right children must not exist, and the node's value must be such that no node can be inserted as its child.

In other words, a node is a dead end if:
1. It is a leaf node (no children).
2. No node with value one less than the current node or one greater than the current node can be inserted without violating BST properties.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves traversing the BST and checking for each leaf node if it's a dead end. For each leaf node, we check if the values before and after it (node->data -1 and node->data +1) already exist in the tree. This requires searching in the BST which is expensive and is repeated for all leaf nodes. Also it requires a separate function for checking the existence of nodes which increases complexity.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Node {
    int data;
    Node* left, * right;
};

Node* newNode(int data) {
    Node* node = new Node;
    node-&gt;data = data;
    node-&gt;left = node-&gt;right = NULL;
    return node;
}

// Function to search for a value in BST
bool search(Node* root, int val) {
    if (!root)
        return false;

    if (root-&gt;data == val)
        return true;

    if (val &lt root-&gt;data)
        return search(root-&gt;left, val);
    else
        return search(root-&gt;right, val);
}

// Brute-force approach to check for dead end
bool isDeadEnd(Node* root) {
    if (!root)
        return false;

    if (!root-&gt;left &amp;&amp; !root-&gt;right) {
        if (search(root, root-&gt;data - 1) &amp;&amp; search(root, root-&gt;data + 1))
            return true;
    }

    return isDeadEnd(root-&gt;left) || isDeadEnd(root-&gt;right);
}


</code></pre>
  <p><b>Time Complexity:</b> O(N^2) - In the worst case, for each leaf node (at most N/2 nodes), the search function takes O(N) time.  Here, N is the number of nodes in the BST. | <b>Space Complexity:</b> O(H) -  Recursive stack space, where H is the height of the tree.  In the worst case (skewed tree), H = N.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach (DFS with Sets)</h5>
  <p>We use Depth First Search (DFS) to traverse the BST. We also use two sets: one to store the minimum possible value for each node and another set to store the maximum possible value for each node. For each node encountered, before visiting left and right subtrees, we check if its value -1 is in the min values set, and its value + 1 is in max value set. If yes, it is dead end. We update these sets for each node's subtree. Thus, while traversing, we maintain the range of possible values.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Node {
    int data;
    Node* left, * right;
};

Node* newNode(int data) {
    Node* node = new Node;
    node-&gt;data = data;
    node-&gt;left = node-&gt;right = NULL;
    return node;
}

bool isDeadEndUtil(Node* root, set&lt;int&gt;&amp; min_values, set&lt;int&gt;&amp; max_values) {
    if (!root)
        return false;

    if (min_values.count(root-&gt;data - 1) &amp;&amp; max_values.count(root-&gt;data + 1))
        return true;

    min_values.insert(root-&gt;data);
    max_values.insert(root-&gt;data);

    bool left_dead_end = isDeadEndUtil(root-&gt;left, min_values, max_values);
    bool right_dead_end = isDeadEndUtil(root-&gt;right, min_values, max_values);

    return left_dead_end || right_dead_end;
}

bool isDeadEnd(Node* root) {
    set&lt;int&gt; min_values;
    set&lt;int&gt; max_values;
    return isDeadEndUtil(root, min_values, max_values);
}
</code></pre>
  <p><b>Time Complexity:</b> O(N log N) -  Each node is visited once (O(N)).  Inserting/checking in the sets takes O(log N) time each. | <b>Space Complexity:</b> O(N) - For storing nodes in sets (in the worst case when the tree is a skewed tree).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">8
/
5
/
2
/
1
/
3
/
7
/
10
/
12</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Yes</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Node 1 is a dead end.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">8
/
7
/
6
/
5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No dead ends.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  Consider the edge case of an empty tree (should return false). 2. The key to the optimized solution is efficiently checking for potential dead ends (O(1) lookup using sets) during the traversal. 3.  The problem emphasizes on the leaf node, so focus on the property that both left and right nodes are NULL.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/binary-search-tree-iterator/>Binary Search Tree Iterator</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. The iterator's `next()` method will return the next smallest number in the BST. The `hasNext()` method will return `true` if there is a next smallest number in the BST.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Perform an in-order traversal of the BST and store all the nodes' values in a sorted list. Then, the `next()` method can just return the next element from the list and `hasNext()` can check if there are any more elements in the list.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class BSTIterator {
private:
    vector&lt;int&gt; inorder_values;
    int index;

    void inorderTraversal(TreeNode* root) {
        if (root == nullptr) return;
        inorderTraversal(root-&gt;left);
        inorder_values.push_back(root-&gt;val);
        inorderTraversal(root-&gt;right);
    }

public:
    BSTIterator(TreeNode* root) {
        inorderTraversal(root);
        index = 0;
    }

    int next() {
        return inorder_values[index++];
    }

    bool hasNext() {
        return index &lt inorder_values.size();
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N) for initialization (inorder traversal), O(1) for next() and hasNext() on average. Where N is the number of nodes in the BST. | <b>Space Complexity:</b> O(N) to store the in-order traversal in a list.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized with Stack (Inorder Traversal without precalculation)</h5>
  <p>Use an iterative inorder traversal approach. Maintain a stack to store the nodes.  The `next()` method pops the next smallest element from the stack. The `hasNext()` method checks if the stack is not empty or if there are unexplored nodes in the right subtree of a node in the stack.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class BSTIterator {
private:
    stack&lt;TreeNode*&gt; st;

public:
    BSTIterator(TreeNode* root) {
        // Initialize the stack by pushing leftmost nodes
        TreeNode* curr = root;
        while (curr != nullptr) {
            st.push(curr);
            curr = curr-&gt;left;
        }
    }

    int next() {
        TreeNode* top = st.top();
        st.pop();
        int val = top-&gt;val;
        TreeNode* curr = top-&gt;right;
        while (curr != nullptr) {
            st.push(curr);
            curr = curr-&gt;left;
        }
        return val;
    }

    bool hasNext() {
        return !st.empty();
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(1) for next() and hasNext() on average. In the worst case, next() can be O(H), where H is the height of the tree, for cases when the right subtree needs to be explored.  Initialization is O(H) and in the worst case O(N). | <b>Space Complexity:</b> O(H), where H is the height of the tree. In the worst case (skewed tree), O(N).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [7,3,15,null,null,9,20], next, next, hasNext, next, hasNext, next, hasNext</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[3,7,true,9,true,15,false]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The BST is initialized. The `next()` calls return the smallest numbers in order. `hasNext()` checks if there are more numbers.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,null,2], next, hasNext, next, hasNext</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,true,2,false]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Demonstrates the iterator with a right-skewed tree.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to optimizing is to avoid pre-calculating the inorder traversal.  The stack-based approach provides amortized O(1) time complexity for `next()` and `hasNext()` operations.  Be mindful of edge cases like empty subtrees or null root.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/>Lowest Common Ancestor of a Binary Tree</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a binary tree and two nodes, `p` and `q`, find the lowest common ancestor (LCA) of `p` and `q`. The LCA is defined as the lowest node in the tree that has both `p` and `q` as descendants (where a node can be a descendant of itself).</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Find the paths from the root to both `p` and `q`.  Then, traverse both paths simultaneously until the nodes differ.  The node before the differing nodes is the LCA.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

vector&lt;TreeNode*&gt; findPath(TreeNode* root, TreeNode* target) {
    vector&lt;TreeNode*&gt; path;
    if (!root)
        return path;

    stack&lt;TreeNode*&gt; s;
    unordered_map&lt;TreeNode*, TreeNode*&gt; parent;
    s.push(root);
    parent[root] = NULL;

    while (!s.empty()) {
        TreeNode* current = s.top();
        s.pop();

        if (current == target) {
            TreeNode* node = target;
            while (node) {
                path.push_back(node);
                node = parent[node];
            }
            reverse(path.begin(), path.end());
            return path;
        }

        if (current-&gt;left) {
            s.push(current-&gt;left);
            parent[current-&gt;left] = current;
        }
        if (current-&gt;right) {
            s.push(current-&gt;right);
            parent[current-&gt;right] = current;
        }
    }
    return {}; // Should not happen as p and q are always in the tree
}

TreeNode* lowestCommonAncestorBruteForce(TreeNode* root, TreeNode* p, TreeNode* q) {
    vector&lt;TreeNode*&gt; pathP = findPath(root, p);
    vector&lt;TreeNode*&gt; pathQ = findPath(root, q);

    TreeNode* lca = nullptr;
    int i = 0, j = 0;
    while (i &lt pathP.size() &amp;&amp; j &lt pathQ.size() &amp;&amp; pathP[i] == pathQ[j]) {
        lca = pathP[i];
        i++;
        j++;
    }
    return lca;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree. Finding paths to p and q takes O(N) in the worst case. | <b>Space Complexity:</b> O(N), to store the paths and potentially the parent map in the worst case.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Recursive Approach</h5>
  <p>Recursively traverse the tree.  If the current node is equal to `p` or `q`, return the current node.  Otherwise, recursively check the left and right subtrees. If both subtrees return non-null values, the current node is the LCA. If only one subtree returns a non-null value, return that subtree's result.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

TreeNode* lowestCommonAncestorOptimized(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (!root || root == p || root == q) {
        return root;
    }

    TreeNode* left = lowestCommonAncestorOptimized(root-&gt;left, p, q);
    TreeNode* right = lowestCommonAncestorOptimized(root-&gt;right, p, q);

    if (left &amp;&amp; right) {
        return root;
    }
    return left ? left : right;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree.  We visit each node at most once. | <b>Space Complexity:</b> O(H), where H is the height of the tree, due to the recursive call stack. In the worst case (skewed tree), H can be N.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [3,5,1,6,2,0,8], p = 5, q = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The LCA of nodes 5 and 1 is 3. The path to node 5 is 3 -> 5 and the path to node 1 is 3 -> 1. The LCA is the point where the paths diverged, which is 3.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [3,5,1,6,2,0,8], p = 5, q = 4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The LCA of nodes 5 and 4 is 5, because node 4 is not present in the tree, the LCA is 5.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,2], p = 1, q = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The LCA of nodes 1 and 2 is 1.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. Both `p` and `q` are guaranteed to exist in the tree.
2. A node can be its own ancestor.
3. The recursive approach is generally preferred due to its elegance and efficiency. The brute force approach, though correct, is less efficient due to the extra overhead of calculating paths.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/unique-binary-search-trees-ii/>Unique Binary Search Trees II</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an integer n, return all the structurally unique BST's (binary search trees) which has node values 1 to n. Return the answer in any order.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach would involve generating all possible binary trees with nodes from 1 to n and then checking if each tree is a valid BST. This would involve recursively generating all possible left and right subtrees for each node and combining them. This approach would be highly inefficient due to the large number of generated trees and the need for BST validation.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

// This brute-force approach is highly inefficient and not recommended.  It's commented out to avoid confusion.
// vector&lt;TreeNode*&gt; generateTrees(int n) {
//     vector&lt;TreeNode*&gt; result;
//     if (n == 0) {
//         result.push_back(nullptr);
//         return result;
//     }
//
//     for (int i = 1; i &lt;= n; ++i) {
//         vector&lt;TreeNode*&gt; leftSubtrees = generateTrees(i - 1);
//         vector&lt;TreeNode*&gt; rightSubtrees = generateTrees(n - i);
//
//         for (TreeNode* left : leftSubtrees) {
//             for (TreeNode* right : rightSubtrees) {
//                 TreeNode* root = new TreeNode(i);
//                 root-&gt;left = left;
//                 root-&gt;right = right;
//                 result.push_back(root);
//             }
//         }
//     }
//     return result;
// }
</code></pre>
  <p><b>Time Complexity:</b> Exponential, O(n * 2^n) | <b>Space Complexity:</b> Exponential, O(n * 2^n)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming with Recursion (Memoization)</h5>
  <p>This approach utilizes dynamic programming with recursion and memoization to avoid redundant computations. The core idea is to recursively generate BSTs for subranges of the input numbers. The result for a given range [start, end] is built by iterating through each number within the range, treating it as the root, and combining the results of generating BSTs for the left and right subranges.  Memoization is used to store the results of subproblems to avoid recomputation.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

vector&lt;TreeNode*&gt; generateTreesHelper(int start, int end, unordered_map&lt;pair&lt;int, int&gt;, vector&lt;TreeNode*&gt;, hash&lt;pair&lt;int, int&gt;&gt;&gt;&amp; memo) {
    vector&lt;TreeNode*&gt; result;
    if (start &gt; end) {
        result.push_back(nullptr);
        return result;
    }

    if (memo.count({start, end})) {
        return memo[{start, end}];
    }

    for (int i = start; i &lt;= end; ++i) {
        vector&lt;TreeNode*&gt; leftSubtrees = generateTreesHelper(start, i - 1, memo);
        vector&lt;TreeNode*&gt; rightSubtrees = generateTreesHelper(i + 1, end, memo);

        for (TreeNode* left : leftSubtrees) {
            for (TreeNode* right : rightSubtrees) {
                TreeNode* root = new TreeNode(i);
                root-&gt;left = left;
                root-&gt;right = right;
                result.push_back(root);
            }
        }
    }
    memo[{start, end}] = result;
    return result;
}

vector&lt;TreeNode*&gt; generateTrees(int n) {
    unordered_map&lt;pair&lt;int, int&gt;, vector&lt;TreeNode*&gt;, hash&lt;pair&lt;int, int&gt;&gt;&gt; memo;
    if (n == 0) return {};
    return generateTreesHelper(1, n, memo);
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2 * (number of trees possible)) which simplifies to O(n * 4^n) | <b>Space Complexity:</b> O(n^2) due to the memoization table. Also O(4^n) to store the trees</p>
  <h5>‚û§ Iterative Dynamic Programming</h5>
  <p>This approach uses dynamic programming to iteratively build the BSTs. It builds a table where each cell (i, j) stores a list of BSTs that can be formed from the numbers in the range [i, j]. The table is filled in a bottom-up manner, starting with single-node trees and gradually building larger trees by combining smaller ones. This avoids recursion entirely and is more efficient than brute force, but requires a good understanding of the iterative approach.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

vector&lt;TreeNode*&gt; generateTrees(int n) {
    if (n == 0) return {};

    vector&lt;vector&lt;vector&lt;TreeNode*&gt;&gt;&gt; dp(n + 1, vector&lt;vector&lt;TreeNode*&gt;&gt;(n + 1));

    for (int i = 1; i &lt;= n; ++i) {
        dp[i][i].push_back(new TreeNode(i));
    }

    for (int len = 2; len &lt;= n; ++len) {
        for (int i = 1; i &lt;= n - len + 1; ++i) {
            int j = i + len - 1;
            for (int k = i; k &lt;= j; ++k) {
                vector&lt;TreeNode*&gt; leftSubtrees = (k == i) ? vector&lt;TreeNode*&gt;{nullptr} : dp[i][k - 1];
                vector&lt;TreeNode*&gt; rightSubtrees = (k == j) ? vector&lt;TreeNode*&gt;{nullptr} : dp[k + 1][j];

                for (TreeNode* left : leftSubtrees) {
                    for (TreeNode* right : rightSubtrees) {
                        TreeNode* root = new TreeNode(k);
                        root-&gt;left = left;
                        root-&gt;right = right;
                        dp[i][j].push_back(root);
                    }
                }
            }
        }
    }

    return dp[1][n];
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^3) | <b>Space Complexity:</b> O(n^3)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The problem asks for all structurally unique BSTs with nodes having values from 1 to n. When n = 3, the valid BSTs are those shown in the output.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">When n = 1, there is only one BST with a single node with value 1.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,null,2],[2,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">With n = 2, two unique BSTs can be formed.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to solving this problem efficiently is to use dynamic programming to avoid recomputing the same subproblems. The choice of which approach (memoized recursion or iterative DP) depends on coding preference, although iterative DP often results in slightly better performance, especially with large n. It's crucial to handle edge cases like n=0 (return an empty list of trees) and the cases where a subtree is empty (null pointers). Remember to free the memory of the created tree nodes, particularly in a production setting.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/>All Nodes Distance K in Binary Tree</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given the root of a binary tree, the value of a target node, and an integer k, return an array of the values of all nodes that are distance k from the target node. You can return the answer in any order.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>This approach first traverses the tree to find the target node. Then, for each node in the tree, it calculates the distance to the target node using a helper function. If the distance is equal to k, the node's value is added to the result. This approach involves multiple traversals of the tree.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

int distance(TreeNode* root, TreeNode* target) {
    if (!root) return -1;
    if (root == target) return 0;
    int leftDist = distance(root-&gt;left, target);
    if (leftDist != -1) return leftDist + 1;
    int rightDist = distance(root-&gt;right, target);
    if (rightDist != -1) return rightDist + 1;
    return -1;
}

vector&lt;int&gt; distanceK_brute_force(TreeNode* root, TreeNode* target, int k) {
    vector&lt;int&gt; result;
    if (!root || !target || k &lt 0) return result;

    queue&lt;TreeNode*&gt; q; 
    q.push(root);
    while(!q.empty()){
        TreeNode* curr = q.front();
        q.pop();
        int dist = distance(root, target);
        if (dist != -1 && dist != -1) {
            if (distance(curr, target) == k) {
                result.push_back(curr-&gt;val);
            }
        }
        if (curr-&gt;left) q.push(curr-&gt;left);
        if (curr-&gt;right) q.push(curr-&gt;right);
    }

    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N^2), where N is the number of nodes in the tree.  Finding the target and calculating distance to each node takes O(N) in the worst case, and this is done for each of the N nodes. | <b>Space Complexity:</b> O(N) in the worst case, due to the recursion stack in the distance function and the queue to traverse the tree.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Using Parent Pointers and DFS</h5>
  <p>1. **Build Parent Pointers:** Perform a Depth-First Search (DFS) to store parent pointers for each node in the tree. This allows traversal upwards.
2. **Find Target:** Locate the target node using DFS or a simple traversal.
3. **DFS from Target:** Perform another DFS starting from the target node to find nodes at distance k.  Maintain a set to avoid revisiting nodes and to prevent cycles. We can traverse in all directions now ‚Äì up (using parent pointers), left, and right.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

void buildParentMap(TreeNode* root, unordered_map&lt;TreeNode*, TreeNode*&gt;&amp; parentMap) {
    if (!root) return;
    if (root-&gt;left) {
        parentMap[root-&gt;left] = root;
        buildParentMap(root-&gt;left, parentMap);
    }
    if (root-&gt;right) {
        parentMap[root-&gt;right] = root;
        buildParentMap(root-&gt;right, parentMap);
    }
}

void dfs(TreeNode* node, int depth, int k, unordered_map&lt;TreeNode*, TreeNode*&gt;&amp; parentMap, unordered_set&lt;TreeNode*&gt;&amp; visited, vector&lt;int&gt;&amp; result) {
    if (!node || visited.count(node)) return;
    visited.insert(node);
    if (depth == k) {
        result.push_back(node-&gt;val);
        return;
    }

    if (node-&gt;left) dfs(node-&gt;left, depth + 1, k, parentMap, visited, result);
    if (node-&gt;right) dfs(node-&gt;right, depth + 1, k, parentMap, visited, result);
    if (parentMap.count(node)) dfs(parentMap[node], depth + 1, k, parentMap, visited, result);
}

vector&lt;int&gt; distanceK(TreeNode* root, TreeNode* target, int k) {
    vector&lt;int&gt; result;
    if (!root || !target || k &lt 0) return result;

    unordered_map&lt;TreeNode*, TreeNode*&gt; parentMap;
    buildParentMap(root, parentMap);

    unordered_set&lt;TreeNode*&gt; visited;
    dfs(target, 0, k, parentMap, visited, result);

    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree.  We traverse the tree a constant number of times (for parent pointers and the final DFS). | <b>Space Complexity:</b> O(N) in the worst case.  The parentMap, visited set, and recursion call stack can all potentially store N nodes.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[7,4,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Nodes 7, 4, and 1 are distance 2 from node 5.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,2,3,null,4,null,null], target = 2, k = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Node 4 is the only node distance 3 from node 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1], target = 1, k = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The target node itself has distance 0.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  **Handling Cycles:**  The 'visited' set in the optimal solution is crucial to avoid infinite loops if there are cycles (which can happen if we go up to parent and then back down).
2.  **Edge Cases:**
    -   `k = 0`: The target node itself should be included.
    -   `target` is the root:  Consider the possible cases (k = 0, k > 0).
    -   `k` is larger than the tree's height: Returns an empty result.
3. **Alternative Optimized Solution (BFS):**  A BFS approach can also be used after building the parent pointers, starting from the target node. This avoids the potential for stack overflow in deep trees. The time and space complexities would remain similar to the DFS approach.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/validate-binary-search-tree/>Validate Binary Search Tree</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given the `root` of a binary tree, determine if it is a valid binary search tree (BST).

A valid BST is defined as follows:

*   The left subtree of a node contains only nodes with keys less than the node's key.
*   The right subtree of a node contains only nodes with keys greater than the node's key.
*   Both the left and right subtrees must also be binary search trees.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Inorder traversal and check if the nodes are sorted in ascending order. If not, the tree is not a valid BST. The inorder traversal visits nodes in the order: left-subtree, root, right-subtree. We keep track of the previously visited node and compare it with the current node.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    bool isValidBST(TreeNode* root) {
        vector&lt;int&gt; inorder;
        inorderTraversal(root, inorder);

        for (int i = 1; i &lt inorder.size(); i++) {
            if (inorder[i] &lt= inorder[i - 1]) {
                return false;
            }
        }
        return true;
    }

private:
    void inorderTraversal(TreeNode* root, vector&lt;int&gt;&amp; inorder) {
        if (!root) {
            return;
        }
        inorderTraversal(root-&gt;left, inorder);
        inorder.push_back(root-&gt;val);
        inorderTraversal(root-&gt;right, inorder);
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree. Inorder traversal visits each node once. | <b>Space Complexity:</b> O(N) in the worst-case scenario (skewed tree) for the inorder traversal stack and the vector to store inorder traversal values. O(logN) in the average case (balanced tree) for the recursion stack.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Inorder Traversal with Previous Node</h5>
  <p>During inorder traversal, we keep track of the previously visited node's value.  If the current node's value is less than or equal to the previous node's value, the BST is invalid. This avoids storing all node values in a separate array.  We can initialize a `prev` variable to `NULL` (or a sufficiently small number) to handle the very first node in traversal.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    bool isValidBST(TreeNode* root) {
        TreeNode* prev = nullptr;
        return inorder(root, prev);
    }

private:
    bool inorder(TreeNode* root, TreeNode*& prev) {
        if (!root) {
            return true;
        }

        if (!inorder(root-&gt;left, prev)) {
            return false;
        }

        if (prev != nullptr &amp;&amp; root-&gt;val &lt= prev-&gt;val) {
            return false;
        }

        prev = root;
        return inorder(root-&gt;right, prev);
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree.  Each node is visited once. | <b>Space Complexity:</b> O(H), where H is the height of the tree.  This is due to the recursion stack used by the inorder traversal. In the best and average case, it is O(log N). In the worst case (skewed tree), it is O(N).</p>
  <h5>‚û§ Recursive with Range</h5>
  <p>Recursively check each node, ensuring its value falls within a valid range (min, max). The range is updated as we traverse the tree.

*   For a node's left child, the upper bound becomes the current node's value.
*   For a node's right child, the lower bound becomes the current node's value.

We propagate the bounds down the tree.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    bool isValidBST(TreeNode* root) {
        return isValidBSTHelper(root, nullptr, nullptr);
    }

private:
    bool isValidBSTHelper(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) {
        if (!root) {
            return true;
        }

        if (minNode &amp;&amp; root-&gt;val &lt;= minNode-&gt;val) {
            return false;
        }
        if (maxNode &amp;&amp; root-&gt;val &gt;= maxNode-&gt;val) {
            return false;
        }

        return isValidBSTHelper(root-&gt;left, minNode, root) &amp;&amp; isValidBSTHelper(root-&gt;right, root, maxNode);
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree. | <b>Space Complexity:</b> O(H), where H is the height of the tree, due to the recursion stack.  In a balanced tree, this is O(log N), and in a skewed tree, this is O(N).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [2,1,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The tree is a valid BST.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [5,1,4,null,null,3,6]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The root node's value is 5, but its right child's value is 4, which is smaller.  Also, the value of 3 is not valid since it is in the left subtree of 4, meaning it should be &lt; 4.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [2,2,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The nodes with value 2 are not in BST order because values should be unique.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [3,1,5,0,2,4,6]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">A valid BST with multiple levels.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [10,5,15,null,null,6,20]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Node with value 6 is in the right subtree of 5, so it needs to be greater than 5, but it is also smaller than 15 (the root's right node).</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Important edge cases include:

*   Empty tree: A tree with no nodes is considered a valid BST.
*   Nodes with the same value: While not explicitly forbidden, duplicate values might lead to invalid BST structures if not handled carefully. Most BST implementations will not allow duplicates, but if they are allowed, the validation might need minor changes (allowing the current value to be <= the right child).
*   Integer overflow/underflow: When comparing values, use the correct data types to prevent potential overflow issues, especially if dealing with `INT_MAX` or `INT_MIN`. The recursive approach with ranges inherently helps with this, because we can consider INT_MIN and INT_MAX as valid boundary values.
*   Single-node tree: a single node is valid. 

The recursive approach with range is generally preferred due to its elegance and efficiency.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/binary-tree-right-side-view/>Binary Tree Right Side View</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given the root of a binary tree, imagine yourself standing on the right side of it. Return the values of the nodes you can see ordered from top to bottom.

For example:
Input: root = [1,2,3,null,5,null,4]
Output: [1,3,4]</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Perform a level order traversal (breadth-first search) of the tree. For each level, the rightmost node is the one visible from the right side. Store the rightmost node's value for each level in the result.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

vector&lt;int&gt; rightSideViewBruteForce(TreeNode* root) {
    vector&lt;int&gt; result;
    if (!root) return result;

    queue&lt;TreeNode*&gt; q;
    q.push(root);

    while (!q.empty()) {
        int levelSize = q.size();
        for (int i = 0; i &lt levelSize; ++i) {
            TreeNode* node = q.front();
            q.pop();

            if (i == levelSize - 1) {
                result.push_back(node-&gt;val);
            }

            if (node-&gt;left) q.push(node-&gt;left);
            if (node-&gt;right) q.push(node-&gt;right);
        }
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree.  We visit each node once during the level order traversal. | <b>Space Complexity:</b> O(W), where W is the maximum width of the tree.  This is due to the queue used for level order traversal. In the worst case (a complete binary tree), W will be close to N/2.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized with DFS</h5>
  <p>Use Depth-First Search (DFS) to traverse the tree. Keep track of the current depth.  Maintain a result vector where the index corresponds to the level.  For each node, if its depth is equal to the result vector's size, it means it's the first node we've seen at that depth from the right side, so add its value to the result. This avoids level order traversal and can be more efficient.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

void rightSideViewHelper(TreeNode* root, int depth, vector&lt;int&gt;&amp; result) {
    if (!root) return;

    if (depth == result.size()) {
        result.push_back(root-&gt;val);
    }

    rightSideViewHelper(root-&gt;right, depth + 1, result);
    rightSideViewHelper(root-&gt;left, depth + 1, result);
}

vector&lt;int&gt; rightSideViewOptimized(TreeNode* root) {
    vector&lt;int&gt; result;
    rightSideViewHelper(root, 0, result);
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree. We visit each node once. | <b>Space Complexity:</b> O(H), where H is the height of the tree.  This is due to the recursive call stack in DFS. In the worst case (skewed tree), H can be N, and in the balanced case, it is log(N).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,2,3,null,5,null,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,3,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The right side view is the rightmost node at each level.  The right side nodes are 1, 3, and 4.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,null,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The right side view is 1 and 3.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">If the root is null, then the output is an empty array.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The level order traversal approach is conceptually simpler to understand. The DFS approach is often slightly more efficient in practice, especially because we process the right child before the left child, thus ensuring that nodes on the right side are added to the result first. Edge cases include empty tree (root is null).</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/redundant-connection/>Redundant Connection</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>In this problem, we're given a graph that is represented as a collection of edges. The graph is guaranteed to be connected, meaning there's a path between any two nodes. However, there's one key detail: the graph contains exactly one redundant edge, causing a cycle. Our task is to find and return this redundant edge.  An edge is represented as a pair of nodes [u, v], where u and v are connected in the graph. The output should be the edge that, if removed, would eliminate the cycle.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves iterating through each edge and temporarily removing it.  After removing an edge, we check if the graph is still connected and cycle-free (using Depth-First Search or Breadth-First Search). If removing the edge breaks the cycle, then that edge is the redundant one. We iterate through the edges, check connectivity for each edge and return the first edge that breaks the cycle.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    bool hasCycle(int n, vector&lt;vector&lt;int&gt;&gt;& edges, int excluded_edge_index = -1) {
        vector&lt;vector&lt;int&gt;&gt; adj(n + 1);
        for (int i = 0; i &lt; edges.size(); ++i) {
            if (i != excluded_edge_index) {
                adj[edges[i][0]].push_back(edges[i][1]);
                adj[edges[i][1]].push_back(edges[i][0]);
            }
        }

        vector&lt;bool&gt; visited(n + 1, false);
        bool cycle_detected = false;
        for (int i = 1; i &lt;= n; ++i) {
            if (!visited[i] &amp;&amp; !adj[i].empty()) {
                if (dfs(i, -1, adj, visited)) {
                    cycle_detected = true;
                    break;
                }
            }
        }

        return cycle_detected;
    }

    bool dfs(int u, int parent, vector&lt;vector&lt;int&gt;&gt;& adj, vector&lt;bool&gt;&amp; visited) {
        visited[u] = true;
        for (int v : adj[u]) {
            if (v != parent) {
                if (visited[v]) {
                    return true;
                }
                if (dfs(v, u, adj, visited)) {
                    return true;
                }
            }
        }
        return false;
    }

    vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;& edges) {
        int n = edges.size(); // Assuming nodes are labeled from 1 to n
        for (int i = n - 1; i &gt;= 0; --i) {
            if (!hasCycle(n, edges, i)) {
                return edges[i];
            }
        }
        return {}; // Should not reach here as problem statement guarantees a redundant edge
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(E^2 * (V + E)), where E is the number of edges and V is the number of vertices.  For each edge (O(E)), we rebuild the graph (O(E)) and perform DFS (O(V+E)) | <b>Space Complexity:</b> O(V + E) due to the adjacency list and visited array in DFS.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Union-Find (Disjoint Set)</h5>
  <p>The Union-Find approach efficiently detects cycles. We initialize a Union-Find data structure.  For each edge [u, v], we check if u and v are already connected (i.e., they have the same parent in the Union-Find structure).  If they are, then adding this edge creates a cycle, so this is the redundant edge.  If they're not connected, we unite u and v in the Union-Find structure, merging their sets.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    int find(vector&lt;int&gt;&amp; parent, int i) {
        if (parent[i] == i) {
            return i;
        }
        return parent[i] = find(parent, parent[i]); // Path compression
    }

    void unite(vector&lt;int&gt;&amp; parent, vector&lt;int&gt;&amp; rank, int x, int y) {
        int rootX = find(parent, x);
        int rootY = find(parent, y);
        if (rootX != rootY) {
            if (rank[rootX] &lt; rank[rootY]) {
                parent[rootX] = rootY;
            } else if (rank[rootX] &gt; rank[rootY]) {
                parent[rootY] = rootX;
            } else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
        }
    }

    vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;& edges) {
        int n = edges.size();
        vector&lt;int&gt; parent(n + 1);
        vector&lt;int&gt; rank(n + 1, 0);

        for (int i = 1; i &lt;= n; i++) {
            parent[i] = i;
        }

        for (auto& edge : edges) {
            int u = edge[0];
            int v = edge[1];
            int rootU = find(parent, u);
            int rootV = find(parent, v);
            if (rootU == rootV) {
                return edge;
            }
            unite(parent, rank, u, v);
        }
        return {}; // Should not reach here as problem statement guarantees a redundant edge
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(E * Œ±(V)), where E is the number of edges, V is the number of vertices, and Œ±(V) is the inverse Ackermann function, which grows extremely slowly and can be considered almost constant in practice (for reasonable input sizes). | <b>Space Complexity:</b> O(V) for the parent and rank arrays in Union-Find.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,2],[1,3],[2,3]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[2,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The edge [2,3] creates a cycle.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,2],[2,3],[3,4],[1,4],[1,5]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The edge [1,4] creates a cycle.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,2],[1,2]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The edge [1,2] creates a self cycle</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Key considerations include:

*   The graph is connected and contains exactly one redundant edge.
*   Nodes are numbered from 1 to n (or implicitly determined from the edges).
*   The Union-Find approach with path compression and union by rank is highly efficient for cycle detection in graphs.  This is generally the preferred and fastest solution for this problem.
*   Edge cases: a single self-loop (e.g., [1,1]) creates a cycle and is the redundant edge; duplicate edges will also be the redundant edge.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/binary-tree-level-order-traversal/>Binary Tree Level Order Traversal</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves recursively traversing the tree. For each level, we collect node values into a list. This is done by maintaining the current level and recursively calling the function for the left and right children and incrementing the level.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        vector&lt;vector&lt;int&gt;&gt; result;
        if (!root) return result;
        traverse(root, 0, result);
        return result;
    }

    void traverse(TreeNode* node, int level, vector&lt;vector&lt;int&gt;&gt;&amp; result) {
        if (!node) return;
        if (result.size() &lt;= level) {
            result.push_back({});
        }
        result[level].push_back(node-&gt;val);
        traverse(node-&gt;left, level + 1, result);
        traverse(node-&gt;right, level + 1, result);
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N^2) in worst case where N is the number of nodes. Due to the repeated appending to vectors at each level. | <b>Space Complexity:</b> O(N) in the worst case for the call stack (skewed tree) and the result vector.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ BFS (Level Order Traversal)</h5>
  <p>This approach uses Breadth-First Search (BFS). We use a queue to store nodes to visit. We start by enqueuing the root. Then, in a loop, we dequeue a node and add its value to the current level's list. We enqueue its left and right children if they exist.  We repeat this process until the queue is empty. The level changes when we finish processing all nodes at the current level. The queue will implicitly manage the level order. The time complexity and space complexity is optimal for this task.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        vector&lt;vector&lt;int&gt;&gt; result;
        if (!root) return result;

        queue&lt;TreeNode*&gt; q;
        q.push(root);

        while (!q.empty()) {
            int levelSize = q.size();
            vector&lt;int&gt; currentLevel;
            for (int i = 0; i &lt; levelSize; i++) {
                TreeNode* node = q.front();
                q.pop();
                currentLevel.push_back(node-&gt;val);
                if (node-&gt;left) q.push(node-&gt;left);
                if (node-&gt;right) q.push(node-&gt;right);
            }
            result.push_back(currentLevel);
        }
        return result;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree. Each node is visited and processed exactly once. | <b>Space Complexity:</b> O(W), where W is the maximum width of the binary tree. In the worst-case scenario (a complete binary tree), the space complexity is O(N).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [3,9,20,null,null,15,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[3],[9,20],[15,7]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The level order traversal goes level by level from left to right.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">A tree with only a root node has only one level.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">An empty tree returns an empty list.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases include an empty tree (return an empty list) and a tree with a single node. The queue in the BFS solution is crucial for maintaining the level order.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/path-sum-iii/>Path Sum III</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p>

  <h4>üß† Brute Force Approach</h4>
  <p>This approach iterates through all possible paths in the tree.  For each node, it starts a path and traverses down the tree, calculating the sum of the path. If the sum equals the targetSum, it increments the count.  This is done recursively for every node in the tree.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;numeric&gt; // for std::accumulate

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    int pathSum(TreeNode* root, int targetSum) {
        int count = 0;
        if (!root) return 0;
        
        // DFS starting from the current node
        function&lt;void(TreeNode*, long long)&gt; dfs = [&](TreeNode* node, long long currentSum) {
            if (!node) return;

            currentSum += node-&gt;val;
            if (currentSum == targetSum) {
                count++;
            }

            dfs(node-&gt;left, currentSum);
            dfs(node-&gt;right, currentSum);
        };

        // Iterate through each node in the tree as a starting point
        function&lt;void(TreeNode*)&gt; traverse = [&](TreeNode* node) {
            if (!node) return;
            dfs(node, 0); // Start DFS from the current node
            traverse(node-&gt;left);
            traverse(node-&gt;right);
        };

        traverse(root);
        return count;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N^2) in the worst case, where N is the number of nodes in the tree.  The outer loop iterates through each node (O(N)), and the inner DFS can potentially traverse all nodes below each node (O(N) in a skewed tree). | <b>Space Complexity:</b> O(H) in the average case and O(N) in the worst case (skewed tree) due to the recursion stack, where H is the height of the tree.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Solution using Prefix Sum and Hash Map</h5>
  <p>This solution uses the concept of prefix sums and a hash map to optimize the path sum calculation. It performs a depth-first search (DFS) traversal of the tree.  At each node, it calculates the current prefix sum (sum of values from the root to the current node). It then checks if there's a previous prefix sum that, when subtracted from the current prefix sum, equals the targetSum.  If so, it means there's a path from some ancestor to the current node with the desired sum. The hash map stores the frequencies of different prefix sums encountered so far.  This approach effectively avoids recalculating path sums repeatedly.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;unordered_map&gt;

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    int pathSum(TreeNode* root, int targetSum) {
        unordered_map&lt;long long, int&gt; prefixSumCount;
        prefixSumCount[0] = 1; // Initialize with a prefix sum of 0, count 1 (for the case where a path starts from the root)
        int count = 0;
        
        function&lt;void(TreeNode*, long long)&gt; dfs = [&](TreeNode* node, long long currentSum) {
            if (!node) return;

            currentSum += node-&gt;val;
            if (prefixSumCount.count(currentSum - targetSum)) {
                count += prefixSumCount[currentSum - targetSum];
            }
            
            prefixSumCount[currentSum]++;

            dfs(node-&gt;left, currentSum);
            dfs(node-&gt;right, currentSum);
            
            prefixSumCount[currentSum]--; // Backtrack: Remove the current prefix sum count
        };
        
        dfs(root, 0);
        return count;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N) where N is the number of nodes in the tree. Each node is visited once in the DFS. | <b>Space Complexity:</b> O(N) in the worst case (skewed tree) for the hash map, which stores prefix sums.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Path 1: 5 -> 3
Path 2: 5 -> 2 -> 1
Path 3: -3 -> 11</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Path 1: 5 -> 4 -> 11 -> 2
Path 2: 5 -> 8 -> 4 -> 5
Path 3: 4 -> 11 -> 7</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [], targetSum = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Empty tree has no paths.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Key considerations include:

*   **Handling Empty Trees:** The code should correctly handle cases where the input tree is empty.
*   **Negative Node Values:** The tree can contain negative node values, which is important for path sum calculations.
*   **Path Definitions:** Paths can start and end at any node, not just root-to-leaf.
*   **Overflow:** When summing the path, use long long or a data type that can accommodate a large sum of integers to prevent potential integer overflow.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/>Construct Binary Tree from Preorder and Postorder Traversal</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given two integer arrays, `preorder` and `postorder`, where `preorder` is the preorder traversal of a binary tree of distinct values and `postorder` is the postorder traversal of the same tree, reconstruct and return the binary tree.

If there is more than one possible answer, return any of them.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves trying all possible combinations of nodes to form a binary tree and checking if the preorder and postorder traversals match the given arrays. This is not efficient and has a very high time complexity. Therefore, it is not a practical approach for this problem.</p>
  <pre><code class="language-python">// Brute-force approach is not practical for this problem due to its exponential time complexity.
#include &lt;bits/stdc++.h&gt;
using namespace std;

// This approach is omitted as it is not feasible.
</code></pre>
  <p><b>Time Complexity:</b> O(N!), where N is the number of nodes. This is due to trying all possible tree structures. | <b>Space Complexity:</b> O(N) to store the tree.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Recursive Approach</h5>
  <p>This approach leverages the properties of preorder and postorder traversals.  The first element of preorder is always the root. We then find the root's left child in postorder.  Knowing the position of the left child in the postorder, we can determine the size of the left subtree. We recursively construct the left and right subtrees using the remaining elements in preorder and postorder, creating the binary tree.</p>
  <pre><code class="language-python">#include &lt;bits/stdc++.h&gt;
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; postorder) {
    int preIndex = 0;
    int postIndex = 0;
    return buildTreeHelper(preorder, postorder, preIndex, postIndex, preorder.size());
}

TreeNode* buildTreeHelper(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; postorder, int&amp; preIndex, int&amp; postIndex, int n) {
    if (preIndex &gt;= n || postIndex &gt;= n)
        return nullptr;

    TreeNode* root = new TreeNode(preorder[preIndex++]);

    if (preIndex &gt;= n || preorder[preIndex] == postorder[postIndex]) {
        return root;
    }

    int postIndexLeftChild = -1;
    for (int i = postIndex; i &lt; n; ++i) {
        if (postorder[i] == preorder[preIndex]) {
            postIndexLeftChild = i;
            break;
        }
    }
    
    if(postIndexLeftChild != -1) {
    root-&gt;left = buildTreeHelper(preorder, postorder, preIndex, postIndex, n);
    }
    postIndex++;
    if (preIndex &lt; n &amp;&amp; postIndex &lt; n &amp;&amp; preorder[preIndex] != postorder[postIndex-1]){
       root-&gt;right = buildTreeHelper(preorder, postorder, preIndex, postIndex, n);
    }

    return root;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N^2) in the worst case.  In the worst case, for each node, we may need to search the postorder array to find the left child, which takes O(N) time. In the best case and average case, this is closer to O(N log N). | <b>Space Complexity:</b> O(N) due to the recursive call stack (in the worst case, skewed tree) and the space to store the tree.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,3,4,5,6,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The preorder traversal gives the root first, followed by the left subtree, and then the right subtree. The postorder traversal gives the left subtree first, then the right subtree, and then the root. By combining these two, we can reconstruct the tree.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">preorder = [1,2,3], postorder = [3,2,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,null,null,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Example of a skewed tree.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. The problem states there are unique values in the input. 2. If multiple valid trees are possible, any one of them is acceptable. 3. The order of nodes in the output matters. Specifically, the nodes must be at their respective positions.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/unique-binary-search-trees/>Unique Binary Search Trees</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an integer n, return the number of structurally unique binary search trees (BSTs) which has exactly n nodes of unique values from 1 to n.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves generating all possible BST structures for a given n.  For each node i from 1 to n, we can consider it as the root.  Then, recursively generate all possible left and right subtrees for each root. This results in a combinatorial explosion.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

// Function to calculate the number of unique BSTs (Brute Force - inefficient for larger n)
int numTreesBruteForce(int n) {
    if (n &lt= 1) return 1;

    int count = 0;
    for (int i = 1; i &lt= n; ++i) {
        int leftCount = numTreesBruteForce(i - 1);
        int rightCount = numTreesBruteForce(n - i);
        count += leftCount * rightCount;
    }
    return count;
}

// Example usage (for demonstration, but inefficient for larger n)
// int main() {
//     int n = 3;
//     cout &lt&lt "Number of unique BSTs for n = " &lt&lt n &lt&lt ": " &lt&lt numTreesBruteForce(n) &lt&lt endl;
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(n * 2^n).  The recursive calls lead to exponential time complexity because of redundant computations. | <b>Space Complexity:</b> O(n) due to the recursion depth in the worst-case scenario (skewed tree).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming (Catalan Number)</h5>
  <p>This approach utilizes dynamic programming to efficiently compute the number of unique BSTs. We can define dp[i] as the number of unique BSTs with i nodes. The root node can be any value from 1 to i. For each possible root value j, the left subtree will have j-1 nodes, and the right subtree will have i-j nodes. The number of unique BSTs is then calculated as the product of the counts of the left and right subtrees. The key is the recurrence relation: dp[i] = sum(dp[j-1] * dp[i-j]) for j = 1 to i. This is closely related to the Catalan numbers.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

int numTreesDP(int n) {
    vector&lt;int&gt; dp(n + 1, 0);
    dp[0] = 1; // Base case: empty tree
    dp[1] = 1; // Base case: one node

    for (int i = 2; i &lt= n; ++i) {
        for (int j = 1; j &lt= i; ++j) {
            dp[i] += dp[j - 1] * dp[i - j];
        }
    }
    return dp[n];
}

// Example usage
// int main() {
//     int n = 3;
//     cout &lt&lt "Number of unique BSTs for n = " &lt&lt n &lt&lt ": " &lt&lt numTreesDP(n) &lt&lt endl;
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(n^2).  There are nested loops.  The outer loop iterates from 2 to n, and the inner loop iterates up to i. | <b>Space Complexity:</b> O(n).  We use a dp array of size n+1 to store the intermediate results.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There are 5 unique BSTs with nodes 1, 2, and 3:
   1         3     3      2      1
    \       /     /      / \      \
     3      2     1      1   3      2
    /      /       \                 \
   2      1         2                 3</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There is only one BST with a single node.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">An empty tree is considered a valid BST.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The dynamic programming solution is significantly more efficient than the brute-force approach. 2. The problem is a direct application of the Catalan number formula. 3. Edge cases include n = 0 (empty tree) and n = 1 (single node). 4. Understanding how subtrees influence the number of BSTs is critical for solving the problem.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/recover-binary-search-tree/>Recover Binary Search Tree</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>You are given the root of a binary tree. Two of the nodes of the tree were swapped by mistake. Recover the tree without changing its structure.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>1. Inorder Traversal: Perform an inorder traversal of the binary tree and store the node values in a list.
2. Identify Swapped Nodes:  Scan the inorder traversal list.  In a correctly sorted list, the elements are in increasing order. Identify the two nodes that are out of order. These are the nodes that were swapped.
3. Swap Values: Swap the values of the two identified nodes in the binary tree.</p>
  <pre><code class="language-python">#include &ltiostream&gt
#include &ltvector&gt
#include &ltalgorithm&gt  // For swap

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    void recoverTree(TreeNode* root) {
        vector&lt;int&gt; inorderValues;
        vector&lt;TreeNode*&gt; inorderNodes;
        inorderTraversal(root, inorderValues, inorderNodes);

        TreeNode *first = nullptr, *second = nullptr;
        for (int i = 0; i &lt; inorderValues.size() - 1; ++i) {
            if (inorderValues[i] &gt; inorderValues[i + 1]) {
                if (!first) {
                    first = inorderNodes[i];
                }
                second = inorderNodes[i + 1];
            }
        }

        if (first &amp;&amp; second) {
            swap(first-&gt;val, second-&gt;val);
        }
    }

private:
    void inorderTraversal(TreeNode* root, vector&lt;int&gt;&amp; values, vector&lt;TreeNode*&gt;&amp; nodes) {
        if (!root) return;
        inorderTraversal(root-&gt;left, values, nodes);
        values.push_back(root-&gt;val);
        nodes.push_back(root);
        inorderTraversal(root-&gt;right, values, nodes);
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree.  Inorder traversal takes O(N) and finding the swapped nodes takes O(N). Swapping takes O(1). | <b>Space Complexity:</b> O(N) due to the inorder traversal list and the nodes list in worst-case scenario (skewed tree).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Inorder Traversal (Morris Traversal)</h5>
  <p>1.  Inorder Traversal with Morris Traversal: Implement Morris Traversal to perform inorder traversal without using extra space for the inorder list. Morris Traversal modifies the tree structure temporarily to achieve this.
2. Identify Swapped Nodes:  During the Morris traversal, compare the current node's value with the previous node's value. If out of order, record the first and second incorrect nodes.  The first will be the first node that violates the inorder sequence, and the second will be the second node that violates it (either the second out-of-place node, or the last violating node if it's a consecutive violation).
3. Swap Values: Swap the values of the identified nodes.</p>
  <pre><code class="language-python">#include &ltiostream&gt
#include &ltvector&gt
#include &ltalgorithm&gt

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    void recoverTree(TreeNode* root) {
        TreeNode *first = nullptr, *second = nullptr, *prev = nullptr;
        TreeNode *curr = root;

        while (curr) {
            if (curr-&gt;left) {
                TreeNode *predecessor = curr-&gt;left;
                while (predecessor-&gt;right &amp;&amp; predecessor-&gt;right != curr) {
                    predecessor = predecessor-&gt;right;
                }

                if (!predecessor-&gt;right) {
                    predecessor-&gt;right = curr;
                    curr = curr-&gt;left;
                } else {
                    predecessor-&gt;right = nullptr;
                    if (prev &amp;&amp; prev-&gt;val &gt; curr-&gt;val) {
                        if (!first) {
                            first = prev;
                        }
                        second = curr;
                    }
                    prev = curr;
                    curr = curr-&gt;right;
                }
            } else {
                if (prev &amp;&amp; prev-&gt;val &gt; curr-&gt;val) {
                    if (!first) {
                        first = prev;
                    }
                    second = curr;
                }
                prev = curr;
                curr = curr-&gt;right;
            }
        }

        if (first &amp;&amp; second) {
            swap(first-&gt;val, second-&gt;val);
        }
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree.  Morris traversal takes O(N). | <b>Space Complexity:</b> O(1).  Morris traversal modifies the tree in place, without using extra space for the inorder traversal list.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,3,null,null,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[3,1,null,null,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3 and 1 are swapped.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [3,1,4,null,null,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[2,1,4,null,null,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2 and 3 are swapped.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [2,3,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[2,1,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 and 3 are swapped.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The problem assumes that exactly two nodes are swapped.
2.  The tree's structure must not be changed; only the node values can be swapped.
3.  Consider the case where the swapped nodes are not adjacent in inorder traversal.  For example, [3, 1, 4, null, null, 2].  The correct inorder traversal would be [1, 2, 3, 4], and here nodes 3 and 2 are the ones swapped. When more than two are messed up the logic does not provide the right result.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/populating-next-right-pointers-in-each-node/>Populating Next Right Pointers in Each Node</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a perfect binary tree, populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.
</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Level order traversal using a queue.  For each level, iterate through the nodes and link them to their right neighbors.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};

Node* connect_brute_force(Node* root) {
    if (!root) return nullptr;

    queue&ltNode*&gt; q;
    q.push(root);

    while (!q.empty()) {
        int levelSize = q.size();
        Node* prev = nullptr;

        for (int i = 0; i &lt levelSize; ++i) {
            Node* curr = q.front();
            q.pop();

            if (prev) {
                prev-&gt;next = curr;
            }
            prev = curr;

            if (curr-&gt;left) {
                q.push(curr-&gt;left);
            }
            if (curr-&gt;right) {
                q.push(curr-&gt;right);
            }
        }
    }

    return root;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree. We visit each node once. | <b>Space Complexity:</b> O(W), where W is the maximum width of the binary tree. In the worst-case scenario (a complete binary tree), W can be N/2.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Level Order Traversal without extra space</h5>
  <p>Connect nodes at each level by traversing the tree using pointers. This is achieved using the next pointer of each node. First, handle the root node's children. Then, utilize the next pointers to connect the children of other nodes on the same level.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};

Node* connect_optimized(Node* root) {
    if (!root) return nullptr;

    Node* leftmost = root;

    while (leftmost-&gt;left) {
        Node* curr = leftmost;

        while (curr) {
            // Connection 1: left to right
            curr-&gt;left-&gt;next = curr-&gt;right;

            // Connection 2: right to left (check if next is available)
            if (curr-&gt;next) {
                curr-&gt;right-&gt;next = curr-&gt;next-&gt;left;
            }

            curr = curr-&gt;next;
        }
        leftmost = leftmost-&gt;left;
    }
    return root;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes. We visit each node exactly once. | <b>Space Complexity:</b> O(1). We only use a few pointers, regardless of the tree size.</p>
  <h5>‚û§ Recursive Solution</h5>
  <p>Recursively connect the left and right children of each node and utilize the next pointers to connect children of different nodes at the same level.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};

void connect_recursive_helper(Node* node) {
    if (!node) return;

    if (node-&gt;left) {
        node-&gt;left-&gt;next = node-&gt;right;
    }
    if (node-&gt;right &amp;&amp; node-&gt;next) {
        node-&gt;right-&gt;next = node-&gt;next-&gt;left;
    }

    connect_recursive_helper(node-&gt;left);
    connect_recursive_helper(node-&gt;right);
}

Node* connect_recursive(Node* root) {
    if (!root) return nullptr;
    connect_recursive_helper(root);
    return root;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes. We visit each node once. | <b>Space Complexity:</b> O(H), where H is the height of the tree, due to the recursion call stack. In the worst case (skewed tree), this becomes O(N). In a balanced tree, it's O(logN).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,3,4,5,6,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,#,2,3,#,4,5,6,7,#]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The input represents a perfect binary tree.  The output shows the nodes connected with their next pointers.  '#' denotes the end of a level.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Empty tree: no nodes to connect.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,#]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Single node tree: no connection needed</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The problem assumes a perfect binary tree (all levels are completely filled).  The optimal solution leverages the existing 'next' pointers to connect the children. Recursive solution has O(H) space complexity (where H is the height of the tree) due to recursion depth, whereas the iterative solution has O(1) space complexity.  Be mindful of handling null checks.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/flatten-binary-tree-to-linked-list/>Flatten Binary Tree to Linked List</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given the root of a binary tree, flatten the tree into a "linked list":

*   The "linked list" should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.
*   The "linked list" should be in the same order as a pre-order traversal of the binary tree.
</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves performing a pre-order traversal of the binary tree to store the node values in a list. Then, create a new linked list by setting the right child of each node to the next node in the list and setting the left child of each node to null.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    void flatten(TreeNode* root) {
        if (!root) return;

        vector&lt;TreeNode*&gt; nodes;
        preorder(root, nodes);

        for (int i = 0; i &lt nodes.size() - 1; ++i) {
            nodes[i]-&gt;right = nodes[i+1];
            nodes[i]-&gt;left = nullptr;
        }
    }

    void preorder(TreeNode* root, vector&lt;TreeNode*&gt;&amp; nodes) {
        if (!root) return;

        nodes.push_back(root);
        preorder(root-&gt;left, nodes);
        preorder(root-&gt;right, nodes);
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the binary tree, due to the pre-order traversal and the construction of the linked list. | <b>Space Complexity:</b> O(N), where N is the number of nodes, to store the nodes in the vector.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Iterative In-Place</h5>
  <p>This approach uses a stack to simulate the pre-order traversal in an iterative manner. It modifies the tree in-place without using extra space for storing the nodes. For each node, it connects its left subtree to its right subtree after moving the right subtree to the end of the left subtree.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    void flatten(TreeNode* root) {
        TreeNode* curr = root;
        while (curr) {
            if (curr-&gt;left) {
                TreeNode* predecessor = curr-&gt;left;
                while (predecessor-&gt;right) {
                    predecessor = predecessor-&gt;right;
                }
                predecessor-&gt;right = curr-&gt;right;
                curr-&gt;right = curr-&gt;left;
                curr-&gt;left = nullptr;
            }
            curr = curr-&gt;right;
        }
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the binary tree, as each node is visited and processed at most once. | <b>Space Complexity:</b> O(1), as the solution modifies the tree in-place and uses a constant amount of extra space.</p>
  <h5>‚û§ Recursive In-Place</h5>
  <p>This approach uses recursion. It recursively flattens the left and right subtrees.  After flattening, the right subtree is connected to the end of the left subtree and the left subtree becomes null. Finally it sets the right node to the left node and left node to null.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    void flatten(TreeNode* root) {
        if (!root) return;
        flattenHelper(root);
    }

    TreeNode* flattenHelper(TreeNode* root) {
        if (!root) return nullptr;

        TreeNode* leftTail = flattenHelper(root-&gt;left);
        TreeNode* rightTail = flattenHelper(root-&gt;right);

        if (leftTail) {
            leftTail-&gt;right = root-&gt;right;
            root-&gt;right = root-&gt;left;
            root-&gt;left = nullptr;
        }

        return rightTail ? rightTail : (leftTail ? leftTail : root);
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the binary tree. | <b>Space Complexity:</b> O(H), where H is the height of the binary tree, due to the recursion call stack. In the worst-case scenario (skewed tree), H can be N.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,2,5,3,4,null,6]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,null,2,null,3,null,4,null,5,null,6]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The tree is flattened in a pre-order fashion. The left children are set to null, and right children form a linked list.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">If the tree is empty, the flattened list is also empty.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">A single node tree remains as a single node list.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,null,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Simple tree flattening</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to this problem is to understand pre-order traversal and how to manipulate the tree's pointers in-place. The iterative in-place solution is the most efficient in terms of space complexity.  Consider the edge case of an empty tree and a tree with only one node. The recursive solution offers a more concise implementation but comes at the cost of additional space from the call stack.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/maximum-width-of-binary-tree/>Maximum Width of Binary Tree</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given the root of a binary tree, return the maximum width of the given tree. The width of one level is defined as the length between the end-nodes (leftmost and rightmost non-null nodes), where the null nodes between the end-nodes are also counted into the length calculation. The width of the binary tree is the maximum of the widths of all levels.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Traverse the tree level by level using BFS. For each level, calculate the width by finding the difference between the leftmost and rightmost node indices. The node indices start from 1. The index of a left child is 2 * parentIndex and the index of the right child is 2 * parentIndex + 1. Keep track of the maximum width found so far.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

int widthOfBinaryTree(TreeNode* root) {
    if (!root) return 0;

    int maxWidth = 0;
    queue&ltpair&lt;TreeNode*, long long&gt;&gt; q; // &ltNode, index&gt;
    q.push({root, 1});

    while (!q.empty()) {
        int levelSize = q.size();
        long long leftmostIndex = -1, rightmostIndex = -1;

        for (int i = 0; i &lt levelSize; ++i) {
            auto [node, index] = q.front();
            q.pop();

            if (leftmostIndex == -1) {
                leftmostIndex = index;
            }
            rightmostIndex = index;

            if (node-&gt;left) {
                q.push({node-&gt;left, index * 2LL});
            }
            if (node-&gt;right) {
                q.push({node-&gt;right, index * 2LL + 1});
            }
        }
        maxWidth = max(maxWidth, (int)(rightmostIndex - leftmostIndex + 1));
    }

    return maxWidth;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree. We visit each node once. | <b>Space Complexity:</b> O(W), where W is the maximum width of the tree. In the worst case (a complete binary tree), the queue can hold up to W nodes at a time.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized BFS with index tracking</h5>
  <p>Similar to brute force, but optimizes the space used by storing indices as long long to prevent overflow issues. We maintain a queue of pairs (TreeNode*, index). In each level, find the leftmost and rightmost node indices and calculate the width. This is essentially the same algorithm as the brute force but optimized in index size.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

int widthOfBinaryTree(TreeNode* root) {
    if (!root) return 0;

    int maxWidth = 0;
    queue&ltpair&lt;TreeNode*, long long&gt;&gt; q; // &ltNode, index&gt;
    q.push({root, 1});

    while (!q.empty()) {
        int levelSize = q.size();
        long long leftmostIndex = -1, rightmostIndex = -1;

        for (int i = 0; i &lt levelSize; ++i) {
            auto [node, index] = q.front();
            q.pop();

            if (leftmostIndex == -1) {
                leftmostIndex = index;
            }
            rightmostIndex = index;

            if (node-&gt;left) {
                q.push({node-&gt;left, index * 2LL});
            }
            if (node-&gt;right) {
                q.push({node-&gt;right, index * 2LL + 1});
            }
        }
        maxWidth = max(maxWidth, (int)(rightmostIndex - leftmostIndex + 1));
    }

    return maxWidth;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree. | <b>Space Complexity:</b> O(W), where W is the maximum width of the tree.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,3,2,5,3,null,9]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The maximum width existing in the level 2, whose end nodes are 5 and 3, and the length between is 4</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,3,null,5,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The maximum width existing in the level 2, whose end nodes are 5 and 3, and the length between is 2</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,3,2,5,null,null,9,6,null,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">7</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The maximum width existing in the level 4, whose end nodes are 6 and 7, and the length between is 7</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The index of a node can become very large for a skewed or deep tree. Using `long long` is important to avoid integer overflow.
2. Consider null nodes in between the leftmost and rightmost non-null nodes when calculating the width. The index formula is: left child: 2 * parentIndex; right child: 2 * parentIndex + 1.
3. An empty tree has a width of 0.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/min-distance-between-two-given-nodes-of-a-binary-tree/1>Min distance between two given nodes of a Binary Tree</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a binary tree and two node values, find the minimum distance between these two nodes in the binary tree. The distance between two nodes is the number of edges on the path between them.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>1. Find the paths from the root to both nodes (node1 and node2). 
2. Find the lowest common ancestor (LCA) of the two nodes. 
3. Calculate the distance from node1 to LCA and node2 to LCA and add them.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Node {
    int data;
    Node* left, * right;
    Node(int val) : data(val), left(nullptr), right(nullptr) {}
};

// Function to find the path from root to a node
bool findPath(Node* root, int key, vector&lt;int&gt;& path) {
    if (!root)
        return false;

    path.push_back(root-&gt;data);

    if (root-&gt;data == key)
        return true;

    if ((root-&gt;left &amp;&amp; findPath(root-&gt;left, key, path)) ||
        (root-&gt;right &amp;&amp; findPath(root-&gt;right, key, path)))
        return true;

    path.pop_back();
    return false;
}

// Function to find the LCA of two nodes
Node* findLCA(Node* root, int n1, int n2) {
    if (!root)
        return nullptr;

    if (root-&gt;data == n1 || root-&gt;data == n2)
        return root;

    Node* left = findLCA(root-&gt;left, n1, n2);
    Node* right = findLCA(root-&gt;right, n1, n2);

    if (left &amp;&amp; right)
        return root;

    return (left != nullptr) ? left : right;
}

int findDistance(Node* root, int node, int dist) {
    if (!root)
        return -1;

    if (root-&gt;data == node)
        return dist;

    int leftDist = findDistance(root-&gt;left, node, dist + 1);
    if (leftDist != -1)
        return leftDist;

    int rightDist = findDistance(root-&gt;right, node, dist + 1);
    return rightDist;
}

int findDist(Node* root, int n1, int n2) {
    Node* lca = findLCA(root, n1, n2);

    int dist1 = findDistance(lca, n1, 0);
    int dist2 = findDistance(lca, n2, 0);

    if (dist1 != -1 &amp;&amp; dist2 != -1)
        return dist1 + dist2;

    return -1;
}

int main() {
    Node* root = new Node(1);
    root-&gt;left = new Node(2);
    root-&gt;right = new Node(3);
    root-&gt;left-&gt;left = new Node(4);
    root-&gt;left-&gt;right = new Node(5);

    int n1 = 4, n2 = 5;
    cout &lt;&lt; "Min distance between " &lt;&lt; n1 &lt;&lt; " and " &lt;&lt; n2 &lt;&lt; " is: " &lt;&lt; findDist(root, n1, n2) &lt;&lt; endl;

    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N) where N is the number of nodes in the tree (in the worst case, we might traverse the entire tree) | <b>Space Complexity:</b> O(H) for recursive call stack and path vectors, where H is the height of the tree. In the worst case, the height can be N</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach (LCA and Distance Calculation in one pass)</h5>
  <p>1. Find the LCA of the two nodes (n1 and n2).
2. While finding the LCA, simultaneously calculate the distances from LCA to n1 and n2.  If either node is an ancestor of the other, find the distance from the ancestor to the descendant.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Node {
    int data;
    Node* left, * right;
    Node(int val) : data(val), left(nullptr), right(nullptr) {}
};

Node* lca = nullptr;  // Global variable to store the LCA

int findDistanceUtil(Node* root, int n1, int n2, int& dist1, int& dist2, int depth) {
    if (!root)
        return 0;

    if (root-&gt;data == n1) {
        dist1 = depth;
        return 1;
    }

    if (root-&gt;data == n2) {
        dist2 = depth;
        return 1;
    }

    int left = findDistanceUtil(root-&gt;left, n1, n2, dist1, dist2, depth + 1);
    int right = findDistanceUtil(root-&gt;right, n1, n2, dist1, dist2, depth + 1);

    if (left &amp;&amp; right) {
        lca = root;
        return 2;
    }

    if (left || right) {
        return 1;
    }

    return 0;
}

int findDistance(Node* root, int n1, int n2) {
    lca = nullptr;
    int dist1 = -1, dist2 = -1;

    findDistanceUtil(root, n1, n2, dist1, dist2, 0);

    if (lca == nullptr) {
      if(dist1 != -1) {
        return dist1;
      } else if(dist2 != -1) {
        return dist2;
      } else {
        return -1;
      }
    }

    int distance = 0;
    if(dist1 != -1) distance += dist1;
    if(dist2 != -1) distance += dist2;

    return distance;
}

int main() {
    Node* root = new Node(1);
    root-&gt;left = new Node(2);
    root-&gt;right = new Node(3);
    root-&gt;left-&gt;left = new Node(4);
    root-&gt;left-&gt;right = new Node(5);

    int n1 = 4, n2 = 5;
    cout &lt;&lt; "Min distance between " &lt;&lt; n1 &lt;&lt; " and " &lt;&lt; n2 &lt;&lt; " is: " &lt;&lt; findDistance(root, n1, n2) &lt;&lt; endl;

    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N) - One traversal of the tree. | <b>Space Complexity:</b> O(H) for the recursive call stack, where H is the height of the tree.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = {1,2,3,4,5}, n1 = 4, n2 = 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The LCA of 4 and 5 is 2. Distance(4,2) = 1 and Distance(5,2) = 1. Therefore, the total distance is 1 + 1 = 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = {1,2,3,4,5}, n1 = 4, n2 = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">LCA(4, 3) is 1. Distance(4,1) = 2, Distance(3,1) = 1.  Total Distance = 2</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = {1,2,3,4,5}, n1 = 2, n2 = 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">LCA(2, 5) is 2. Distance(2,2) = 0, Distance(5,2) = 2.  Total Distance = 2</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = {1,2,3,4,5}, n1 = 1, n2 = 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">LCA(1, 5) is 1. Distance(1,1) = 0, Distance(5,1) = 2.  Total Distance = 2</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. The distance between a node and itself is 0.
2. Handle cases where one or both nodes might not exist in the tree.
3.  Optimized solution is generally preferred as it combines LCA and distance calculation in a single traversal.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/kth-smallest-element-in-a-bst/>Kth Smallest Element in a BST</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Perform an inorder traversal of the BST to get a sorted list of all the nodes. Then, return the element at index k-1.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

vector&lt;int&gt; inorderTraversal(TreeNode* root) {
    vector&lt;int&gt; result;
    stack&lt;TreeNode*&gt; s;
    TreeNode* curr = root;

    while (curr != nullptr || !s.empty()) {
        while (curr != nullptr) {
            s.push(curr);
            curr = curr-&gt;left;
        }

        curr = s.top();
        s.pop();
        result.push_back(curr-&gt;val);
        curr = curr-&gt;right;
    }
    return result;
}

int kthSmallest_bruteForce(TreeNode* root, int k) {
    vector&lt;int&gt; inorder = inorderTraversal(root);
    return inorder[k - 1];
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the BST, as we need to perform an inorder traversal. | <b>Space Complexity:</b> O(N) in the worst case, due to the inorder traversal storing all nodes in a vector, or O(H) for stack space in inorder traversal, where H is the height of the tree.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Inorder Traversal with Early Termination</h5>
  <p>Perform an inorder traversal of the BST. While traversing, keep a counter. When the counter reaches k, return the current node's value. This avoids storing all nodes in a separate array, improving space complexity. We can also use recursion.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

int kthSmallest_optimized(TreeNode* root, int& k) {
    if (root == nullptr) {
        return -1;
    }

    int left_val = kthSmallest_optimized(root-&gt;left, k);
    if (left_val != -1) {
        return left_val;
    }

    k--;
    if (k == 0) {
        return root-&gt;val;
    }

    return kthSmallest_optimized(root-&gt;right, k);
}

int kthSmallest(TreeNode* root, int k) {
    return kthSmallest_optimized(root, k);
}
</code></pre>
  <p><b>Time Complexity:</b> O(H), where H is the height of the BST. In the best and average case, this is O(log N). In the worst case (skewed tree), this is O(N). | <b>Space Complexity:</b> O(H) in the average and worst case due to recursion call stack (where H is the height of the tree). In a balanced tree, it is O(log N) and in a skewed tree it is O(N).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [3,1,4,null,2], k = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The inorder traversal of the BST is [1, 2, 3, 4]. The 1st smallest element is 1.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [5,3,6,2,4,null,null,1], k = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The inorder traversal of the BST is [1, 2, 3, 4, 5, 6]. The 3rd smallest element is 3.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1], k = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The inorder traversal of the BST is [1]. The 1st smallest element is 1.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to solving this problem efficiently is leveraging the properties of a BST, which is that an inorder traversal yields a sorted sequence. Be mindful of edge cases like empty trees and k being out of bounds. Also, optimize for space complexity by avoiding storing the entire inorder traversal when only the kth element is needed.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/>Binary Tree Zigzag Level Order Traversal</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given the `root` of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Perform a level order traversal using a queue. For each level, if the level number is even, reverse the order of elements before adding them to the result.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder_brute(TreeNode* root) {
    vector&lt;vector&lt;int&gt;&gt; result;
    if (!root) return result;

    queue&lt;TreeNode*&gt; q;
    q.push(root);
    int level = 0;

    while (!q.empty()) {
        int size = q.size();
        vector&lt;int&gt; currentLevel;

        for (int i = 0; i &lt size; ++i) {
            TreeNode* node = q.front();
            q.pop();
            currentLevel.push_back(node-&gt;val);

            if (node-&gt;left) q.push(node-&gt;left);
            if (node-&gt;right) q.push(node-&gt;right);
        }

        if (level % 2 != 0) {
            reverse(currentLevel.begin(), currentLevel.end());
        }
        result.push_back(currentLevel);
        level++;
    }

    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree. We visit each node once. | <b>Space Complexity:</b> O(W), where W is the maximum width of the binary tree. This is due to the queue storing nodes at each level. In the worst-case scenario (complete binary tree), W will be close to N/2.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Level Order Traversal with Double-Ended Queue</h5>
  <p>Perform a level order traversal using a queue and a double-ended queue (deque). For each level, add nodes to the deque either from the front or the back, depending on the level's parity (even or odd). This avoids the need to reverse the list at each odd level.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) {
    vector&lt;vector&lt;int&gt;&gt; result;
    if (!root) return result;

    queue&lt;TreeNode*&gt; q;
    q.push(root);
    int level = 0;

    while (!q.empty()) {
        int size = q.size();
        vector&lt;int&gt; currentLevel(size);

        for (int i = 0; i &lt size; ++i) {
            TreeNode* node = q.front();
            q.pop();
            int index = (level % 2 == 0) ? i : (size - 1 - i);
            currentLevel[index] = node-&gt;val;

            if (node-&gt;left) q.push(node-&gt;left);
            if (node-&gt;right) q.push(node-&gt;right);
        }
        result.push_back(currentLevel);
        level++;
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree. We visit each node once. | <b>Space Complexity:</b> O(W), where W is the maximum width of the binary tree.  This is due to the queue storing nodes at each level. In the worst-case scenario (complete binary tree), W will be close to N/2.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [3,9,20,null,null,15,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[3],[20,9],[15,7]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The tree is traversed level by level. At each level, the values are added to the result vector. The odd-numbered levels have their values reversed.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">A tree with only one node. The output is a vector containing the root's value.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">An empty tree. The output is an empty vector.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to this problem is to correctly track the level and reverse the elements in the result for odd-numbered levels. The optimized solution avoids the explicit reversal by calculating the correct index for each node based on its level and its position within the level.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/count-bst-nodes-that-lie-in-a-given-range/1>Count BST nodes that lie in a given range</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a Binary Search Tree (BST) and a range (inclusive) [low, high], count the number of nodes in the BST that lie within this range.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Perform an inorder traversal of the BST. For each node encountered, check if its value falls within the given range [low, high]. Increment a counter if it does. This approach is simple but may involve traversing the entire tree even if the range is narrow.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) : data(val), left(nullptr), right(nullptr) {}
};

void inorder(Node* root, int low, int high, int& count) {
    if (!root)
        return;

    inorder(root-&gt;left, low, high, count);
    if (root-&gt;data &gt= low &amp;&amp; root-&gt;data &lt= high)
        count++;
    inorder(root-&gt;right, low, high, count);
}

int getCount(Node* root, int low, int high) {
    int count = 0;
    inorder(root, low, high, count);
    return count;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the BST. In the worst case (e.g., the range covers all nodes or the BST is skewed), we might need to visit all nodes. | <b>Space Complexity:</b> O(H), where H is the height of the BST. This space is mainly for the recursion call stack. In the worst case (skewed tree), H can be N, resulting in O(N) space complexity.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Traversal (Leveraging BST Properties)</h5>
  <p>Utilize the properties of a BST to optimize the search. If the current node's value is less than 'low', we can skip the left subtree and only explore the right subtree. If the current node's value is greater than 'high', we can skip the right subtree and only explore the left subtree. If the current node's value falls within the range, we increment the count and recursively explore both subtrees.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) : data(val), left(nullptr), right(nullptr) {}
};

int getCountOptimized(Node* root, int low, int high) {
    if (!root)
        return 0;

    int count = 0;

    if (root-&gt;data &gt= low &amp;&amp; root-&gt;data &lt= high)
        count++;

    if (root-&gt;data &gt; low)
        count += getCountOptimized(root-&gt;left, low, high);
    if (root-&gt;data &lt high)
        count += getCountOptimized(root-&gt;right, low, high);

    return count;
}
</code></pre>
  <p><b>Time Complexity:</b> O(H), where H is the height of the BST. In the best and average cases, we don't need to visit all nodes (unlike the brute-force approach). The time complexity is proportional to the height of the tree. In the worst case (skewed tree or all nodes are within range), it can degrade to O(N). | <b>Space Complexity:</b> O(H), where H is the height of the BST, for the recursion call stack.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">BST: 10 5 15 3 7 12 18, low = 7, high = 15</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The nodes within the range [7, 15] are: 7, 10, 12, 15. Count = 4. (Note: problem description expects 7 to be included)</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">BST: 5 3 7 2 4 6 8, low = 4, high = 8</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The nodes within the range [4, 8] are: 4, 5, 6, 7, 8. Count = 5.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">BST: 20 10 30 5 15 25 35, low = 15, high = 35</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The nodes within the range [15, 35] are: 15, 20, 25, 30, 35. Count = 5.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The optimized approach is significantly better when the range is narrow or when the BST is balanced. In the optimized approach, pay attention to the conditions to check if you can skip either the left or right subtrees to avoid unnecessary traversal.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/preorder-to-postorder4423/1>Preorder to Postorder</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an array representing the preorder traversal of a Binary Search Tree (BST), the task is to construct the postorder traversal of the BST. You are not given the tree structure itself; instead, you only have the preorder sequence.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves recursively constructing the BST from the preorder traversal and then performing a postorder traversal of the constructed tree.  Since we are only interested in postorder, directly constructing the tree might be inefficient. We can directly simulate the construction to identify the right subtree and build the postorder traversal. For each node, find the index where the right subtree starts. Recursively process the left and right subtrees. Append the root to the postorder at the end.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

vector&lt;int&gt; preorderToPostorder(vector&lt;int&gt;&amp; pre) {
    vector&lt;int&gt; postorder;
    int n = pre.size();
    function&lt;void(int, int)&gt; solve = [&](int start, int end) {
        if (start &gt; end) return;
        if (start == end) {
            postorder.push_back(pre[start]);
            return;
        }

        int root = pre[start];
        int rightStart = start + 1;
        while (rightStart &lt;= end &amp;&amp; pre[rightStart] &lt; root) {
            rightStart++;
        }

        solve(start + 1, rightStart - 1); // Left subtree
        solve(rightStart, end);           // Right subtree
        postorder.push_back(root);          // Add root
    };

    solve(0, n - 1);
    return postorder;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) in the worst case.  The while loop might iterate through almost the entire array for each node in a skewed tree.  | <b>Space Complexity:</b> O(n) in the worst-case due to the recursive call stack and the postorder array.  In the best case (balanced BST), space is O(log n) for the call stack.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Recursive Approach</h5>
  <p>This approach is a more optimized version of the brute-force method. We avoid actually building the BST structure. We find the boundary of the right subtree using the preorder sequence. For each node, the left subtree contains elements smaller than the root, and the right subtree contains elements greater than the root. Recursively calculate postorder for the left and right subtrees. Append the root after the subtrees are processed.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

vector&lt;int&gt; preorderToPostorder(vector&lt;int&gt;&amp; pre) {
    vector&lt;int&gt; postorder;
    int n = pre.size();
    function&lt;void(int, int)&gt; solve = [&](int start, int end) {
        if (start &gt; end) return;
        if (start == end) {
            postorder.push_back(pre[start]);
            return;
        }

        int root = pre[start];
        int rightStart = start + 1;
        while (rightStart &lt;= end &amp;&amp; pre[rightStart] &lt; root) {
            rightStart++;
        }

        solve(start + 1, rightStart - 1); // Left subtree
        solve(rightStart, end);           // Right subtree
        postorder.push_back(root);          // Add root
    };

    solve(0, n - 1);
    return postorder;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) on average. Each element is visited at most twice (once potentially in the left subtree and once potentially in the right). However, in the worst-case (skewed tree), the time complexity could degrade to O(n^2). | <b>Space Complexity:</b> O(n) in the worst case (skewed tree) due to the call stack and the postorder vector. O(log n) on average for a balanced tree.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">pre = {40, 30, 35, 80, 100}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">35 30 100 80 40</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The given preorder traversal is {40, 30, 35, 80, 100}.  The root is 40. The left subtree contains 30 and 35. The right subtree contains 80 and 100. Therefore, the postorder traversal is 35 30 100 80 40.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">pre = {1, 2, 3, 4, 5}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5 4 3 2 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The given preorder traversal represents a BST where each node's right child is always greater than its left child and the node itself. The output demonstrates postorder traversal.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases include empty input and a single-node tree. The efficiency depends on the balance of the BST. Skewed trees cause worst-case behavior.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/binary-tree-to-dll/1>Binary Tree to DLL</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given a Binary Tree, convert it to a Doubly Linked List in-place. The left and right pointers in nodes are to be used as previous and next pointers respectively in DLL. The order of nodes in DLL must be the same as in Inorder traversal of the given Binary Tree.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>1. Perform an inorder traversal of the binary tree and store the node values in an array. 2. Create a DLL from the array elements, connecting them using the next and prev pointers. 3. Return the head of the DLL.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) : data(val), left(nullptr), right(nullptr) {}
};

void inorderTraversal(Node* root, vector&lt;Node*&gt;& inorder)
{
    if (!root)
        return;

    inorderTraversal(root-&gt;left, inorder);
    inorder.push_back(root);
    inorderTraversal(root-&gt;right, inorder);
}

Node* bToDLLBruteForce(Node* root) {
    if (!root)
        return nullptr;

    vector&lt;Node*&gt; inorder;
    inorderTraversal(root, inorder);

    Node* head = inorder[0];
    Node* prev = nullptr;

    for (Node* node : inorder) {
        node-&gt;left = prev;
        if (prev)
            prev-&gt;right = node;
        prev = node;
    }

    return head;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the binary tree.  Inorder traversal takes O(N) and creating the DLL from the inorder vector takes O(N). | <b>Space Complexity:</b> O(N), for storing the inorder traversal in a vector.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Inorder Traversal with DLL Formation</h5>
  <p>1. Perform an inorder traversal of the binary tree. 2. During the traversal, maintain a 'prev' pointer. 3.  For each node visited in inorder, set its 'left' pointer to 'prev'.  4.  If 'prev' is not null, set 'prev's 'right' pointer to the current node. 5. Update 'prev' to the current node. 6. Return the head of the DLL. Keep track of head during the traversal.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) : data(val), left(nullptr), right(nullptr) {}
};

Node* bToDLL(Node* root) {
    Node* head = nullptr;
    Node* prev = nullptr;
    function&lt;void(Node*)&gt; inorder = [&](Node* node) {
        if (!node)
            return;

        inorder(node-&gt;left);

        if (!prev) {
            head = node;
        }
        else {
            node-&gt;left = prev;
            prev-&gt;right = node;
        }
        prev = node;

        inorder(node-&gt;right);
    };

    inorder(root);
    return head;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the binary tree. We visit each node exactly once. | <b>Space Complexity:</b> O(H), where H is the height of the binary tree.  This is due to the recursion stack.  In the worst case (skewed tree) this is O(N), and in the best case (balanced tree) it is O(log N).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">     1
    / \
   2   3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2 &lt--&gt 1 &lt--&gt 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Inorder traversal: 2, 1, 3.  DLL: 2 &lt--&gt 1 &lt--&gt 3</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">       10
      /  \
     12   15
    /     \
   25     30</td>
        <td style="border: 1px solid #ccc; padding: 6px;">25 &lt--&gt 12 &lt--&gt 10 &lt--&gt 15 &lt--&gt 30</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Inorder traversal: 25, 12, 10, 15, 30. DLL: 25 &lt--&gt 12 &lt--&gt 10 &lt--&gt 15 &lt--&gt 30</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. The inorder traversal is crucial for preserving the original order of nodes in the DLL. 2. The 'prev' pointer is used to link nodes during the inorder traversal, forming the DLL in-place. 3. Ensure to handle the edge case of an empty tree (root == nullptr). 4. Handle the case when the root node itself becomes the head of the DLL.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/binary-tree-maximum-path-sum/>Binary Tree Maximum Path Sum</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given the root of a binary tree, find the maximum path sum. A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. The path does not need to pass through the root.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves traversing the tree and, for each node, calculating all possible path sums that include that node.  This is done by considering all paths that start and end at any of the node's descendants. This requires a recursive function that calculates the maximum path sum for each possible path rooted at every node.  This involves checking paths through left child, right child, and not including a child at all.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    int maxPathSumHelper(TreeNode* root, int& maxSum) {
        if (!root) {
            return 0;
        }

        // Recursively calculate max path sums for left and right subtrees
        int leftSum = max(0, maxPathSumHelper(root->left, maxSum)); // Ignore negative path sums
        int rightSum = max(0, maxPathSumHelper(root->right, maxSum));

        // Calculate the max path sum considering the current node
        int currentMaxSum = root->val + leftSum + rightSum;
        maxSum = max(maxSum, currentMaxSum);

        // Return the max path sum that includes the current node and one of its children
        return root->val + max(leftSum, rightSum);
    }

    int maxPathSum(TreeNode* root) {
        int maxSum = INT_MIN;
        maxPathSumHelper(root, maxSum);
        return maxSum;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) in the worst case. For each node, we potentially traverse all descendants. | <b>Space Complexity:</b> O(n) due to recursion stack in worst case (skewed tree).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach: Recursive with Path Sum Calculation</h5>
  <p>This approach uses recursion to traverse the tree.  At each node, it calculates two things:  1. The maximum path sum that *includes* the current node and goes down to either the left or right child (or neither).  2. The maximum path sum considering the current node as the 'split' point (i.e., including the node and potentially both left and right subtrees). The overall maximum path sum is maintained throughout the recursion.  The key is to calculate and update the maximum path sum at each node, not just the leaf nodes.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    int maxPathSumHelper(TreeNode* root, int& maxSum) {
        if (!root) {
            return 0; // Base case: empty subtree
        }

        // Recursively calculate max path sums for left and right subtrees
        int leftSum = max(0, maxPathSumHelper(root->left, maxSum)); // Ignore negative path sums
        int rightSum = max(0, maxPathSumHelper(root->right, maxSum));

        // Calculate the max path sum considering the current node as a 'split' point
        maxSum = max(maxSum, root->val + leftSum + rightSum);

        // Return the max path sum that can be extended to the parent
        return root->val + max(leftSum, rightSum);
    }

    int maxPathSum(TreeNode* root) {
        int maxSum = INT_MIN;
        maxPathSumHelper(root, maxSum);
        return maxSum;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the number of nodes in the tree. Each node is visited exactly once. | <b>Space Complexity:</b> O(h), where h is the height of the tree. This is due to the recursion call stack.  In the worst case (skewed tree), h can be n.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,2,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The optimal path is 2 -> 1 -> 3 with a sum of 6.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [-10,9,20,null,null,15,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">42</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The optimal path is 15 -> 20 -> 7 with a sum of 42.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [-3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The path is just the node -3.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [5,4,8,11,null,13,4,7,2,null,null,null,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">48</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The optimal path is 11 -> 4 -> 5 -> 8 -> 13 (7+11+4+5+8+13=48)</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Key points:
1.  Handle negative node values.  If the path sum through a child is negative, it's better to not include that child (treat it as 0).
2.  The path can start and end at any node in the tree, and it doesn't have to pass through the root.  This is why at each node we consider the path sum that includes the node and its left/right children, as well as the path sum considering both children and the node (the split point).
3.  The recursion returns the maximum path sum *from* a node *down* to one of its children (or zero if that path is negative). This is used by the parent node to calculate the overall maximum path sum.
4.  Initialize `maxSum` to `INT_MIN` to handle cases where all node values are negative. The recursive calls will handle the path calculations correctly.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/sum-of-distances-in-tree/>Sum of Distances in Tree</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given an undirected, connected tree with  `n`  nodes labeled from  `0`  to  `n - 1`  and an array of  `edges`  where  `edges[i] = [ai, bi]`  is an edge of the tree. Return an array  `answer`  of length  `n`  where  `answer[i]`  is the sum of the distances between node  `i`  and all other nodes.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>For each node, calculate the distance to every other node in the tree using a breadth-first search (BFS) or depth-first search (DFS). Sum these distances for each node to get the final result. This approach is inefficient because it recalculates distances repeatedly.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    vector&lt;int&gt; sumOfDistancesInTree(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) {
        vector&lt;vector&lt;int&gt;&gt; adj(n);
        for (const auto&amp; edge : edges) {
            adj[edge[0]].push_back(edge[1]);
            adj[edge[1]].push_back(edge[0]);
        }

        vector&lt;int&gt; answer(n, 0);
        for (int i = 0; i &lt; n; ++i) {
            int total_distance = 0;
            vector&lt;int&gt; distance(n, -1);
            queue&lt;int&gt; q;

            q.push(i);
            distance[i] = 0;

            while (!q.empty()) {
                int u = q.front();
                q.pop();

                for (int v : adj[u]) {
                    if (distance[v] == -1) {
                        distance[v] = distance[u] + 1;
                        q.push(v);
                    }
                }
            }

            for (int j = 0; j &lt; n; ++j) {
                total_distance += distance[j];
            }
            answer[i] = total_distance;
        }
        return answer;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N^2), where N is the number of nodes.  For each node, BFS takes O(N) time, and this is done for N nodes. | <b>Space Complexity:</b> O(N) to store adjacency list, distance array, and queue.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming with Tree Traversal</h5>
  <p>This approach uses two passes of Depth-First Search (DFS). The first DFS calculates the sum of distances and the count of nodes in the subtree rooted at each node. The second DFS uses the results of the first DFS to calculate the sum of distances for each node in the tree more efficiently. The core idea is to use the information calculated for a parent node to derive the answer for its children, avoiding redundant calculations. Specifically, `answer[child] = answer[parent] - count[child] + (n - count[child])`.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    vector&lt;int&gt; sumOfDistancesInTree(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) {
        vector&lt;vector&lt;int&gt;&gt; adj(n);
        for (const auto&amp; edge : edges) {
            adj[edge[0]].push_back(edge[1]);
            adj[edge[1]].push_back(edge[0]);
        }

        vector&lt;int&gt; answer(n, 0);
        vector&lt;int&gt; count(n, 1);

        // First DFS: Calculate the initial sum of distances and subtree counts.
        function&lt;void(int, int)&gt; dfs1 = [&](int u, int parent) {
            for (int v : adj[u]) {
                if (v != parent) {
                    dfs1(v, u);
                    count[u] += count[v];
                    answer[u] += answer[v] + count[v];
                }
            }
        };

        dfs1(0, -1);

        // Second DFS: Calculate the sum of distances for each node.
        function&lt;void(int, int)&gt; dfs2 = [&](int u, int parent) {
            for (int v : adj[u]) {
                if (v != parent) {
                    answer[v] = answer[u] - count[v] + (n - count[v]);
                    dfs2(v, u);
                }
            }
        };

        dfs2(0, -1);

        return answer;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes.  Two DFS traversals are performed on the tree. | <b>Space Complexity:</b> O(N) to store the adjacency list, answer array, and count array, and the recursion stack (in worst case, the height of the tree which is O(N)).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[8,12,6,10,10,10]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">For node 0, the sum of distances is 1 + 2 + 2 + 2 + 2 = 9, not 8. Node 1: 1+2+3+3+3 = 12.  Node 2: 1+1+2+2+2 = 8. Node 3: 3+2+1+2+2 = 10. Node 4: 2+2+2+1+2=9. Node 5: 2+2+2+2+1 = 9. Thus [9,12,8,10,10,10] is the accurate result, but there is a slight difference in node 0 value in example output and the problem.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 1, edges = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Trivial case with a single node. The distance to itself is 0.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 2, edges = [[1,0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1, 1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Each node is a distance of 1 from each other.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to the optimized solution is to perform two DFS traversals. The first one computes preliminary values based on the rooted subtree. The second DFS efficiently propagates information from parent nodes to child nodes to compute the final result. The choice of which node to start the DFS on doesn't affect the result, as long as the tree is connected. Edge cases include trees with one or two nodes, and any structure where the tree is degenerate (e.g. a long line).</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/binary-tree-cameras/>Binary Tree Cameras</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given a binary tree, we install cameras on the nodes of the tree. Each camera at a node can monitor its parent, itself, and its immediate children. Determine the minimum number of cameras needed to monitor all nodes of the tree.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach would involve trying out all possible combinations of camera placements on the tree. For each possible placement, we check if all nodes are covered. This involves exploring all subsets of nodes and checking if each subset of nodes (representing camera placements) covers all nodes. This is highly inefficient.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

// NOT A COMPLETE IMPLEMENTATION.  This would be a very complex and inefficient approach.
// Demonstrating the idea of brute force is sufficient here.

int minCameras(TreeNode* root) {
    if (!root) return 0;
    int min_cameras = INT_MAX;
    vector&lt;TreeNode*&gt; nodes;

    function&lt;void(TreeNode*)&gt; inorder = [&](TreeNode* node) {
        if (!node) return;
        inorder(node-&gt;left);
        nodes.push_back(node);
        inorder(node-&gt;right);
    };

    inorder(root);

    for (int i = 0; i &lt; (1 &lt;&lt; nodes.size()); ++i) {
        vector&lt;TreeNode*&gt; cameras;
        for (int j = 0; j &lt; nodes.size(); ++j) {
            if ((i & (1 &lt;&lt; j)) != 0) {
                cameras.push_back(nodes[j]);
            }
        }

        bool covered = true;
        for (TreeNode* node : nodes) {
            bool is_covered = false;
            if (find(cameras.begin(), cameras.end(), node) != cameras.end()) {
                is_covered = true;
            }
            if (node-&gt;left && find(cameras.begin(), cameras.end(), node-&gt;left) != cameras.end()) {
                is_covered = true;
            }
            if (node-&gt;right && find(cameras.begin(), cameras.end(), node-&gt;right) != cameras.end()) {
                is_covered = true;
            }
             if (node-&gt;left && node-&gt;left-&gt;left && find(cameras.begin(), cameras.end(), node-&gt;left-&gt;left) != cameras.end()) {
                is_covered = true;
            }
             if (node-&gt;left && node-&gt;left-&gt;right && find(cameras.begin(), cameras.end(), node-&gt;left-&gt;right) != cameras.end()) {
                is_covered = true;
            }
            if (node-&gt;right && node-&gt;right-&gt;left && find(cameras.begin(), cameras.end(), node-&gt;right-&gt;left) != cameras.end()) {
                is_covered = true;
            }
            if (node-&gt;right && node-&gt;right-&gt;right && find(cameras.begin(), cameras.end(), node-&gt;right-&gt;right) != cameras.end()) {
                is_covered = true;
            }

            if (!is_covered) {
                covered = false;
                break;
            }
        }

        if (covered) {
            min_cameras = min(min_cameras, (int)cameras.size());
        }
    }

    return min_cameras;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N * 2^N), where N is the number of nodes. This is because we explore all subsets of nodes (2^N) and for each subset, we check if all nodes are covered, which takes O(N) time. | <b>Space Complexity:</b> O(N), primarily for storing the nodes in the inorder traversal and the camera placements.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming with State</h5>
  <p>We use dynamic programming and three states for each node: 0: node needs a camera, 1: node has a camera, 2: node is covered. We can perform a post-order traversal to determine the minimum number of cameras needed. The state of a node depends on the states of its children.

1.  **Needs Camera (0)**:  The node needs a camera if both its children are covered (state 2) and its parent doesn't have a camera.
2.  **Has Camera (1)**:  The node has a camera if a camera is placed on it.
3.  **Covered (2)**:  The node is covered if it has a camera or at least one of its children has a camera. If the node is a leaf, then it is covered by default if the parent has a camera. If its covered by parent, the node state will be 2.

When deciding whether to place camera or not, we make decisions based on if any of the child nodes need camera or not. If a child node needs camera we place it, then no camera will be needed for the children.

The root node needs to be handled carefully, if it's needed, we place the camera there.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

// 0: Needs camera
// 1: Has camera
// 2: Covered

class Solution {
public:
    int cameras = 0;

    int dfs(TreeNode* node) {
        if (!node) return 2; // Covered

        int left = dfs(node-&gt;left);
        int right = dfs(node-&gt;right);

        if (left == 0 || right == 0) {
            cameras++;
            return 1; // Has camera
        }

        if (left == 1 || right == 1) {
            return 2; // Covered
        }

        return 0; // Needs camera
    }

    int minCameraCover(TreeNode* root) {
        if (dfs(root) == 0) {
            cameras++;
        }
        return cameras;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the tree.  We visit each node exactly once. | <b>Space Complexity:</b> O(H), where H is the height of the tree, due to the recursive call stack. In the worst-case scenario (skewed tree), H can be equal to N.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [0,0,null,0,0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">One camera is needed at the first node to cover all the nodes.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [0,0,0,null,null,0,0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Placing cameras on the two bottom-most nodes will cover all nodes.  Other configurations also work, but 2 is the minimum.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,2,3,null,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The cameras should be placed on nodes 2 and 3.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Key considerations:

*   **Root node:** The root node might need a camera, especially when its children need coverage.
*   **Leaf nodes:** Leaf nodes are important because they don't cover any other nodes, hence they need to be covered.
*   **Overlapping coverage:** Overlapping coverage is allowed, so placing a camera at a node also covers its children and parent.
*   **Optimal placement:** Focus on minimizing the number of cameras placed, by strategically placing them to cover as many nodes as possible.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/>Vertical Order Traversal of a Binary Tree</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given the root of a binary tree, return the vertical order traversal of its nodes' values. (i.e., from top to bottom, column by column). For each column, order nodes from top to bottom. In the same row, sort nodes from left to right. Return the vertical order traversal as a list of lists of integers.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves traversing the tree and collecting the nodes' values along with their column and row indices.  We can use a hash map (dictionary) to store the values. The keys of the hash map will be the column indices, and the values will be a list of tuples. Each tuple will contain the row index and the node's value. Finally, we sort the values based on the row index and return the list of values for each column.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; verticalTraversal(TreeNode* root) {
        map&lt;int, map&lt;int, vector&lt;int&gt;&gt;&gt; nodes;
        queue&lt;pair&lt;TreeNode*, pair&lt;int, int&gt;&gt;&gt; q;
        q.push({root, {0, 0}});

        while (!q.empty()) {
            TreeNode* node = q.front().first;
            int col = q.front().second.first;
            int row = q.front().second.second;
            q.pop();

            nodes[col][row].push_back(node-&gt;val);

            if (node-&gt;left) {
                q.push({node-&gt;left, {col - 1, row + 1}});
            }
            if (node-&gt;right) {
                q.push({node-&gt;right, {col + 1, row + 1}});
            }
        }

        vector&lt;vector&lt;int&gt;&gt; ans;
        for (auto&amp; col : nodes) {
            vector&lt;int&gt; col_values;
            for (auto&amp; row : col.second) {
                sort(row.second.begin(), row.second.end());
                for (int val : row.second) {
                    col_values.push_back(val);
                }
            }
            ans.push_back(col_values);
        }

        return ans;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N log N) for sorting, where N is the number of nodes.  O(N) for the traversal. | <b>Space Complexity:</b> O(N) to store node values in the map and the queue (in the worst case, a skewed tree).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach with sorting by (col, row, value)</h5>
  <p>This approach uses a breadth-first search (BFS) to traverse the tree.  During the traversal, we store each node's value, column index, and row index in a vector.  After the traversal, we sort this vector first by column, then by row, and finally by value.  This guarantees that nodes are processed in the correct vertical order.  We use a custom comparison function in the sort function to handle the sorting criteria.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; verticalTraversal(TreeNode* root) {
        vector&lt;tuple&lt;int, int, int&gt;&gt; nodes;
        queue&lt;pair&lt;TreeNode*, pair&lt;int, int&gt;&gt;&gt; q;
        q.push({root, {0, 0}});

        while (!q.empty()) {
            TreeNode* node = q.front().first;
            int col = q.front().second.first;
            int row = q.front().second.second;
            q.pop();

            nodes.push_back({col, row, node-&gt;val});

            if (node-&gt;left) {
                q.push({node-&gt;left, {col - 1, row + 1}});
            }
            if (node-&gt;right) {
                q.push({node-&gt;right, {col + 1, row + 1}});
            }
        }

        sort(nodes.begin(), nodes.end(), [](const tuple&lt;int, int, int&gt;&amp; a, const tuple&lt;int, int, int&gt;&amp; b) {
            if (get&lt;0&gt;(a) != get&lt;0&gt;(b)) {
                return get&lt;0&gt;(a) &lt; get&lt;0&gt;(b);
            }
            if (get&lt;1&gt;(a) != get&lt;1&gt;(b)) {
                return get&lt;1&gt;(a) &lt; get&lt;1&gt;(b);
            }
            return get&lt;2&gt;(a) &lt; get&lt;2&gt;(b);
        });

        vector&lt;vector&lt;int&gt;&gt; ans;
        int prev_col = INT_MIN;
        for (auto&amp; node : nodes) {
            int col = get&lt;0&gt;(node);
            int val = get&lt;2&gt;(node);
            if (col != prev_col) {
                ans.push_back({val});
                prev_col = col;
            } else {
                ans.back().push_back(val);
            }
        }

        return ans;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N log N) due to sorting the nodes vector, where N is the number of nodes in the tree.  O(N) for the BFS traversal. | <b>Space Complexity:</b> O(N) to store the nodes in the vector and the queue (worst-case scenario for a skewed tree).</p>
  <h5>‚û§ Optimized Approach using a map</h5>
  <p>This optimized solution uses a map to store values based on their column and row indices. This approach leverages the inherent sorting properties of the map to eliminate the need for sorting the elements manually. It traverses the tree using a BFS and stores the nodes' values, their respective column index, and their row index.  The column index serves as the primary key and the row index is used as a secondary key within a nested map. The node values will be sorted by default due to the property of the `map` data structure.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; verticalTraversal(TreeNode* root) {
        map&lt;int, map&lt;int, vector&lt;int&gt;&gt;&gt; nodes;
        queue&lt;pair&lt;TreeNode*, pair&lt;int, int&gt;&gt;&gt; q;
        q.push({root, {0, 0}});

        while (!q.empty()) {
            TreeNode* node = q.front().first;
            int col = q.front().second.first;
            int row = q.front().second.second;
            q.pop();

            nodes[col][row].push_back(node-&gt;val);

            if (node-&gt;left) {
                q.push({node-&gt;left, {col - 1, row + 1}});
            }
            if (node-&gt;right) {
                q.push({node-&gt;right, {col + 1, row + 1}});
            }
        }

        vector&lt;vector&lt;int&gt;&gt; ans;
        for (auto&amp; col : nodes) {
            vector&lt;int&gt; col_values;
            for (auto&amp; row : col.second) {
                sort(row.second.begin(), row.second.end());
                for (int val : row.second) {
                    col_values.push_back(val);
                }
            }
            ans.push_back(col_values);
        }

        return ans;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N log N) - due to sorting inside the nested map structure for values in the same row and column.  O(N) for the traversal. | <b>Space Complexity:</b> O(N) to store node values in the map and the queue.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [3,9,20,null,null,15,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[9],[3,15],[20],[7]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The tree has the following vertical order:  - Column -2: 9 - Column -1: 3, 15 - Column 0: 20 - Column 1: 7</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,2,3,4,5,6,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[4],[2],[1,5,6],[3,7]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The tree has the following vertical order:  - Column -2: 4 - Column -1: 2 - Column 0: 1, 5, 6 - Column 1: 3 - Column 2: 7</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,2,3,4,6,5,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[4],[2],[1,5,6],[3,7]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The tree has the following vertical order: - Column -2: 4 - Column -1: 2 - Column 0: 1, 5, 6 - Column 1: 3 - Column 2: 7</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. **Column and Row Calculation:** The column is calculated by moving left for the left child (col - 1) and right for the right child (col + 1). The row is incremented for each level (row + 1).
2. **Sorting within a column:** If nodes have the same column and row, sort them based on their values.
3. **Use of data structures:** Choosing appropriate data structures (like map and vector) helps manage the sorting process and makes the code more efficient and readable.
4. **Handling duplicates:** If multiple nodes are at the same column and row, the values are added to the vector.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/print-k-sum-paths-binary-tree/>Print all K-Sum paths in a binary tree</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given a binary tree and an integer k, print all the paths in the tree whose sum equals k. A path can start from any node and end at any node.  Paths can go downwards, upwards, or sideways, and do not need to start at the root or end at a leaf.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves traversing the tree and, for each node, calculating the sum of all possible paths starting from that node and ending at any other node in the subtree or going up to the root. This involves nested loops and repeated calculations, making it inefficient.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Node {
    int data;
    Node* left, * right;
    Node(int val) : data(val), left(nullptr), right(nullptr) {}
};

void printPath(vector&lt;int&gt; path) {
    for (int node : path) {
        cout &lt&lt node &lt&lt " ";
    }
    cout &lt&lt endl;
}

void findPaths(Node* root, int k, vector&lt;int&gt; currentPath, vector&lt;vector&lt;int&gt;&gt;&amp; paths) {
    if (!root) return;

    currentPath.push_back(root-&gt;data);

    // Check for paths ending at the current node
    int sum = 0;
    for (int i = currentPath.size() - 1; i &gt;= 0; --i) {
        sum += currentPath[i];
        if (sum == k) {
            paths.push_back(vector&lt;int&gt;(currentPath.begin() + i, currentPath.end()));
        }
    }

    findPaths(root-&gt;left, k, currentPath, paths);
    findPaths(root-&gt;right, k, currentPath, paths);
}

vector&lt;vector&lt;int&gt;&gt; kSumPathsBruteForce(Node* root, int k) {
    vector&lt;vector&lt;int&gt;&gt; paths;
    vector&lt;int&gt; currentPath;
    findPaths(root, k, currentPath, paths);
    return paths;
}

// Helper function to build a sample tree
Node* buildTree() {
    Node* root = new Node(1);
    root-&gt;left = new Node(3);
    root-&gt;right = new Node( -2);
    root-&gt;left-&gt;left = new Node(2);
    root-&gt;left-&gt;right = new Node(1);
    root-&gt;right-&gt;left = new Node(1);
    root-&gt;left-&gt;left-&gt;left = new Node(5);

    return root;
}

int main() {
    Node* root = buildTree();
    int k = 4;
    vector&lt;vector&lt;int&gt;&gt; paths = kSumPathsBruteForce(root, k);

    for (const auto& path : paths) {
        printPath(path);
    }
    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N^2) in the worst case, where N is the number of nodes.  For each node, we potentially traverse multiple paths. | <b>Space Complexity:</b> O(H) for the recursion stack and path storage, where H is the height of the tree. In the worst case (skewed tree), this is O(N).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach using a Hash Map</h5>
  <p>This approach uses a hash map to store the prefix sums encountered during a depth-first search traversal. For each node, it calculates the prefix sum from the root to the current node.  It then checks if there's a previous prefix sum such that the difference between the current prefix sum and the previous prefix sum equals k.  If it does, a path with sum k exists. The hashmap stores the frequency of each prefix sum, allowing for multiple paths.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Node {
    int data;
    Node* left, * right;
    Node(int val) : data(val), left(nullptr), right(nullptr) {}
};

void printPath(vector&lt;int&gt; path) {
    for (int node : path) {
        cout &lt&lt node &lt&lt " ";
    }
    cout &lt&lt endl;
}

void kSumPathsHelper(Node* root, int k, int currentSum, vector&lt;int&gt;&amp; path, map&lt;int, int&gt;&amp; sumMap, vector&lt;vector&lt;int&gt;&gt;&amp; paths) {
    if (!root) return;

    currentSum += root-&gt;data;
    path.push_back(root-&gt;data);

    if (currentSum == k) {
        paths.push_back(path);
    }

    if (sumMap.find(currentSum - k) != sumMap.end()) {
        int count = sumMap[currentSum - k];
        
        vector&lt;int&gt; tempPath;
        int tempSum = 0;
        for(int i = path.size()-1; i &gt;=0; --i){
            tempSum += path[i];
            if(tempSum == k){
                paths.push_back(vector&lt;int&gt;(path.begin()+i,path.end()));
            }
        }
    }

    sumMap[currentSum]++;
    kSumPathsHelper(root-&gt;left, k, currentSum, path, sumMap, paths);
    kSumPathsHelper(root-&gt;right, k, currentSum, path, sumMap, paths);
    sumMap[currentSum]--;
    path.pop_back();
}

vector&lt;vector&lt;int&gt;&gt; kSumPathsOptimized(Node* root, int k) {
    vector&lt;vector&lt;int&gt;&gt; paths;
    map&lt;int, int&gt; sumMap;
    vector&lt;int&gt; path;
    kSumPathsHelper(root, k, 0, path, sumMap, paths);
    return paths;
}

// Helper function to build a sample tree
Node* buildTree() {
    Node* root = new Node(1);
    root-&gt;left = new Node(3);
    root-&gt;right = new Node( -2);
    root-&gt;left-&gt;left = new Node(2);
    root-&gt;left-&gt;right = new Node(1);
    root-&gt;right-&gt;left = new Node(1);
    root-&gt;left-&gt;left-&gt;left = new Node(5);

    return root;
}

int main() {
    Node* root = buildTree();
    int k = 4;
    vector&lt;vector&lt;int&gt;&gt; paths = kSumPathsOptimized(root, k);

    for (const auto& path : paths) {
        printPath(path);
    }
    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N) where N is the number of nodes.  We traverse each node once. | <b>Space Complexity:</b> O(H) for the recursion stack (H is the height of the tree) and potentially O(N) for the hash map in the worst case (skewed tree).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">Tree: 1,3,-2,2,1,1,5 and K = 4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3 1
1 3
2 1 1
1 -2 1 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The paths with sum 4 are:
1. 3 -> 1
2. 1 -> 3
3. 2 -> 1 -> 1
4. 1 -> -2 -> 1 -> 5</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">Tree: 10,5,-3,3,2,null,11,3,-2,null,1 and K = 8</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5 3
5 2 1
3 5
</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Paths with sum 8:
1. 5 -> 3
2. 5 -> 2 -> 1
3. 3 -> 5</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The hash map approach significantly improves efficiency by avoiding redundant calculations. The space complexity is generally dominated by the recursion stack and the hash map.  Handling negative numbers is important, which the optimized solution handles correctly.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/serialize-and-deserialize-binary-tree/>Serialize and Deserialize Binary Tree</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Design an algorithm to serialize and deserialize a binary tree. Serialization is the process of converting a binary tree into a string format so that it can be stored in a file or memory. Deserialization is the process of reconstructing the original binary tree from its serialized string representation. There are no restrictions on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the same binary tree.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves a pre-order traversal of the tree during serialization. We convert each node into its string representation (e.g., its value). For null nodes, we use a special marker (e.g., '#'). During deserialization, we can reconstruct the tree from the string representation by using a queue or an iterator.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Codec {
public:
    // Serializes a tree to a string.
    string serialize(TreeNode* root) {
        if (!root) return "#";
        return to_string(root-&gt;val) + "," + serialize(root-&gt;left) + "," + serialize(root-&gt;right);
    }

    // Deserializes your encoded data to tree.
    TreeNode* deserialize(string data) {
        stringstream ss(data);
        string token;
        return deserializeHelper(ss);
    }

private:
    TreeNode* deserializeHelper(stringstream& ss) {
        string token;
        getline(ss, token, ',');
        if (token == "#") return nullptr;
        TreeNode* root = new TreeNode(stoi(token));
        root-&gt;left = deserializeHelper(ss);
        root-&gt;right = deserializeHelper(ss);
        return root;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N^2) in the worst case, due to repeated string concatenations during serialization. Deserialization is O(N). N is the number of nodes in the tree. | <b>Space Complexity:</b> O(N) for the recursion stack during serialization and deserialization. The serialized string can take up O(N) space.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Serialization and Deserialization</h5>
  <p>This optimized approach still uses pre-order traversal for serialization, but it builds the serialized string more efficiently by using a stringstream and avoids repeated string concatenation, which makes the serialization process faster.  Deserialization remains similar using a helper function and stringstream to parse the serialized string.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Codec {
public:
    // Serializes a tree to a string.
    string serialize(TreeNode* root) {
        ostringstream out;
        serializeHelper(root, out);
        return out.str();
    }

    // Deserializes your encoded data to tree.
    TreeNode* deserialize(string data) {
        stringstream ss(data);
        return deserializeHelper(ss);
    }

private:
    void serializeHelper(TreeNode* root, ostringstream& out) {
        if (root) {
            out &lt&lt root-&gt;val &lt&lt ",";
            serializeHelper(root-&gt;left, out);
            serializeHelper(root-&gt;right, out);
        } else {
            out &lt&lt "#,";
        }
    }

    TreeNode* deserializeHelper(stringstream& ss) {
        string val;
        getline(ss, val, ',');
        if (val == "#") return nullptr;
        TreeNode* root = new TreeNode(stoi(val));
        root-&gt;left = deserializeHelper(ss);
        root-&gt;right = deserializeHelper(ss);
        return root;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N) for both serialization and deserialization. N is the number of nodes in the tree. | <b>Space Complexity:</b> O(N) due to recursion depth in the worst case during both serialization and deserialization, and also the serialized string can have O(N) space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1,2,3,null,null,4,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,3,null,null,4,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The serialized string is "1,2,#,#,3,4,#,#,5,#,#". Deserialization reconstructs the original tree.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The serialized string is "#". Deserialization reconstructs an empty tree.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">root = [1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The serialized string is "1,#,#". Deserialization reconstructs the tree with a single node.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The choice of the null marker ('#') is arbitrary; any unique delimiter can be used.
2.  Consider using more efficient string building techniques (e.g., stringstream) to improve serialization performance.
3.  The solution should handle empty trees and trees with only one node correctly.
4.  The serialized format must maintain the structure of the binary tree so that it can be correctly deserialized.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/find-median-bst-time-o1-space/>Find median of BST in O(1) space</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given a Binary Search Tree (BST), find the median of its nodes. The median is defined as follows:

-   If the number of nodes in the BST is odd, the median is the value of the middle node.
-   If the number of nodes in the BST is even, the median is the average of the two middle nodes.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Perform an inorder traversal of the BST. Store the node values in a list or array. Sort the list/array. Then, calculate the median based on whether the number of nodes is odd or even. This approach uses O(N) space for storing the inorder traversal and sorting the values.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Node {
    int data;
    Node* left, * right;
    Node(int val) : data(val), left(nullptr), right(nullptr) {}
};

void inorderTraversal(Node* root, vector&lt;int&gt;& values) {
    if (!root) return;
    inorderTraversal(root-&gt;left, values);
    values.push_back(root-&gt;data);
    inorderTraversal(root-&gt;right, values);
}

double findMedianBruteForce(Node* root) {
    vector&lt;int&gt; values;
    inorderTraversal(root, values);
    sort(values.begin(), values.end());
    int n = values.size();
    if (n == 0) return -1; // Or throw an exception, depending on the requirement.

    if (n % 2 == 1) {
        return (double)values[n / 2];
    } else {
        return (double)(values[n / 2 - 1] + values[n / 2]) / 2.0;
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(N log N) due to sorting. Inorder traversal takes O(N). | <b>Space Complexity:</b> O(N) to store the inorder traversal in a vector.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Morris Traversal (O(1) Space)</h5>
  <p>Use Morris Traversal for in-order traversal, which achieves O(1) space complexity. Maintain a count of nodes visited. If the number of nodes is odd, the median is the value of the middle node. If the number of nodes is even, the median is the average of the two middle nodes. While traversing using Morris traversal, keep track of the previous node in the inorder sequence. Use two pointers: one for the current node and another for the previous node.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Node {
    int data;
    Node* left, * right;
    Node(int val) : data(val), left(nullptr), right(nullptr) {}
};

double findMedianMorris(Node* root) {
    if (!root) return -1; // Or throw an exception, depending on the requirement.

    int count = 0;
    Node* current = root;
    Node* pre = nullptr;
    double median = -1;

    while (current) {
        if (!current-&gt;left) {
            count++;
            if (count == (int)floor((double)(count + 1) / 2)) {
                median = current-&gt;data; 
            }
             if (count == (int)floor((double)(count + 2) / 2) ) {
                 median = (median + current-&gt;data) / 2.0;
                 break;
             }
            current = current-&gt;right;
        } else {
            pre = current-&gt;left;
            while (pre-&gt;right && pre-&gt;right != current) {
                pre = pre-&gt;right;
            }
            if (!pre-&gt;right) {
                pre-&gt;right = current;
                current = current-&gt;left;
            } else {
                pre-&gt;right = nullptr;
                count++;
                  if (count == (int)floor((double)(count + 1) / 2)) {
                      median = current-&gt;data;
                  }
                   if (count == (int)floor((double)(count + 2) / 2) ) {
                       median = (median + current-&gt;data) / 2.0;
                       break;
                   }
                current = current-&gt;right;
            }
        }
    }
    return median;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of nodes in the BST, as we visit each node at most twice. | <b>Space Complexity:</b> O(1), constant space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">Input BST: 2 1 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2.0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Inorder traversal is 1, 2, 3.  Median is 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">Input BST: 1 2 3 4 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3.0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Inorder traversal is 1, 2, 3, 4, 5. Median is 3.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">Input BST: 1 2 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2.0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Inorder traversal is 1, 2, 3. Median is 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">Input BST: 10 5 15 3 7</td>
        <td style="border: 1px solid #ccc; padding: 6px;">7.0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Inorder traversal is 3, 5, 7, 10, 15. Median is 7.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. The Morris Traversal modifies the BST temporarily. It restores the original structure after traversal. 2. Handle the edge case of an empty BST. 3.  The use of floor function ensures correct calculation of the middle elements in both odd and even node counts. 4. Check for null root.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/largest-bst-binary-tree-set-2/>Largest BST in a Binary Tree (Set 2)</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given a binary tree, find the largest Binary Search Tree (BST) subtree within it.  The function should return the size (number of nodes) of the largest BST subtree.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>For each node in the tree, check if the subtree rooted at that node is a BST. To do this, recursively check if the left and right subtrees are BSTs and also verify that all nodes in the left subtree have values less than the current node's value, and all nodes in the right subtree have values greater than the current node's value. If it is a BST, calculate its size and update the maximum size found so far. This involves checking all possible subtrees, leading to a high time complexity.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;algorithm&gt;

using namespace std;

struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) : data(val), left(nullptr), right(nullptr) {}
};

// Function to check if a tree is a BST. Also used to find min and max
struct BSTInfo {
    bool isBST;
    int minVal;
    int maxVal;
    int size;
};

BSTInfo isBSTUtil(Node* node) {
    if (!node) {
        return {true, INT_MAX, INT_MIN, 0};
    }

    BSTInfo left = isBSTUtil(node-&gt;left);
    BSTInfo right = isBSTUtil(node-&gt;right);

    BSTInfo current;
    current.size = left.size + right.size + 1;

    if (left.isBST &amp;&amp; right.isBST &amp;&amp;
        node-&gt;data &gt; left.maxVal &amp;&amp;
        node-&gt;data &lt; right.minVal) {
        current.isBST = true;
        current.minVal = (node-&gt;left) ? left.minVal : node-&gt;data;
        current.maxVal = (node-&gt;right) ? right.maxVal : node-&gt;data;
    } else {
        current.isBST = false;
    }

    return current;
}

int largestBSTSize(Node* root) {
    if (!root) {
        return 0;
    }

    if (isBSTUtil(root).isBST){
        return isBSTUtil(root).size;
    }

    return max(largestBSTSize(root-&gt;left), largestBSTSize(root-&gt;right));
}
</code></pre>
  <p><b>Time Complexity:</b> O(N^2) - For each node, we potentially traverse its subtree to check if it's a BST. This check is itself O(N) in worst-case scenarios. Finding size is also O(N). | <b>Space Complexity:</b> O(H) - Recursive calls on the stack (H is the height of the tree) in worst-case scenarios (skewed tree) or O(logN) on average.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized with Postorder Traversal</h5>
  <p>Perform a postorder traversal of the binary tree.  During the traversal, for each node, we calculate the following information:
    1.  Is the subtree rooted at the node a BST?
    2.  The size of the subtree (number of nodes).
    3.  The minimum value in the subtree.
    4.  The maximum value in the subtree.

   This information is computed recursively from the left and right subtrees.  The subtree rooted at the current node is a BST if:
    1.  Both left and right subtrees are BSTs.
    2.  The current node's value is greater than the maximum value in the left subtree (if a left subtree exists).
    3.  The current node's value is less than the minimum value in the right subtree (if a right subtree exists).

    We maintain the maximum BST size seen so far and update it during the traversal. This approach avoids repeated checks and reduces the time complexity substantially.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;algorithm&gt;

using namespace std;

struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) : data(val), left(nullptr), right(nullptr) {}
};

struct BSTInfo {
    bool isBST;
    int minVal;
    int maxVal;
    int size;
};

int maxBSTSize = 0;

BSTInfo largestBSTHelper(Node* node) {
    if (!node) {
        return {true, INT_MAX, INT_MIN, 0};
    }

    BSTInfo left = largestBSTHelper(node-&gt;left);
    BSTInfo right = largestBSTHelper(node-&gt;right);

    BSTInfo current;
    current.size = left.size + right.size + 1;

    current.minVal = node-&gt;data;
    current.maxVal = node-&gt;data;

    if (node-&gt;left) {
        current.minVal = min(current.minVal, left.minVal);
    }
    if (node-&gt;right) {
        current.maxVal = max(current.maxVal, right.maxVal);
    }

    if (left.isBST &amp;&amp; right.isBST &amp;&amp;
        node-&gt;data &gt; left.maxVal &amp;&amp;
        node-&gt;data &lt; right.minVal) {
        current.isBST = true;
        maxBSTSize = max(maxBSTSize, current.size);
    } else {
        current.isBST = false;
        current.size = max(left.size, right.size);
    }

    return current;
}

int largestBSTSizeOptimized(Node* root) {
    maxBSTSize = 0;
    largestBSTHelper(root);
    return maxBSTSize;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N) - Each node is visited exactly once during the postorder traversal. | <b>Space Complexity:</b> O(H) - The recursion stack (H is the height of the tree) in worst-case or O(logN) average.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">  10
 /  \
5   15
   /  \
  6   20</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The largest BST is the subtree rooted at 15, which contains nodes 15, 6, and 20 (size 3).</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">5
/ \
1   4
   / \
  3   6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The largest BST is either the node 1, 3, or 6, each having a size of 1.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">5
/ \
4   8
/   /
2   7</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The largest BST is the subtree rooted at 8, with values 7 and the node 8 (size 2). Or if we remove the node 5 from the tree, then 2,4 is a BST of size 2 or 7,8 is BST of size 2. Hence the max size is 2. If remove node 5 and all of its edges then 2,4 is BST.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>  The problem can be approached using dynamic programming concepts, as subproblems (BST subtrees) are repeatedly evaluated. Key to the optimized approach is the postorder traversal and the use of a struct/class to store necessary information about each subtree (isBST, size, min, max).</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/description/>Construct Binary Search Tree from Preorder Traversal</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given an array of integers `preorder` where `preorder` is a preorder traversal of a binary search tree, construct the binary search tree and return its root.

A binary search tree is a tree where for every node, any node in the left subtree has a value less than node.val, and any node in the right subtree has a value greater than node.val.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves first sorting the `preorder` array to obtain a sorted array. Then, construct the BST by iterating through the `preorder` and inserting elements using the sorted order as a reference. This method is not efficient because sorting takes O(n log n) time and the insertion could be expensive.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

TreeNode* insert(TreeNode* root, int val) {
    if (!root) {
        return new TreeNode(val);
    }
    if (val &lt root-&gtval) {
        root-&gtleft = insert(root-&gtleft, val);
    } else {
        root-&gtright = insert(root-&gtright, val);
    }
    return root;
}

TreeNode* bstFromPreorder_bruteForce(vector&lt;int&gt;&amp; preorder) {
    if (preorder.empty()) {
        return nullptr;
    }

    // Sort the array (not needed for optimal solution)
    // vector&lt;int&gt; sortedPreorder = preorder;
    // sort(sortedPreorder.begin(), sortedPreorder.end());

    TreeNode* root = new TreeNode(preorder[0]);

    for (int i = 1; i &lt preorder.size(); ++i) {
        insert(root, preorder[i]);
    }

    return root;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) due to repeated calls to insert. Sorting would add O(n log n). | <b>Space Complexity:</b> O(n) in worst case due to the BST storing all nodes and recursive stack.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Recursive with Range</h5>
  <p>This approach recursively constructs the BST by maintaining a range for each subtree. For each node, it creates a new node with the current element from the preorder array if the value falls within the valid range.  The left and right subtrees are then built recursively, adjusting the range appropriately.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

int preOrderIndex = 0;

TreeNode* bstFromPreorder_optimized(vector&lt;int&gt;&amp; preorder, int lowerBound, int upperBound) {
    // Base case: Empty tree or invalid range.
    if (preOrderIndex &gt= preorder.size() || preorder[preOrderIndex] &lt lowerBound || preorder[preOrderIndex] &gt upperBound) {
        return nullptr;
    }

    int val = preorder[preOrderIndex++];
    TreeNode* root = new TreeNode(val);

    root-&gtleft = bstFromPreorder_optimized(preorder, lowerBound, val - 1);
    root-&gtright = bstFromPreorder_optimized(preorder, val + 1, upperBound);

    return root;
}

TreeNode* bstFromPreorder(vector&lt;int&gt;&amp; preorder) {
    preOrderIndex = 0;
    return bstFromPreorder_optimized(preorder, INT_MIN, INT_MAX);
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) because each element in the preorder array is processed once. | <b>Space Complexity:</b> O(n) in the worst-case due to recursion depth which is proportional to the tree height (can be n in skewed BST).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">preorder = [8,5,1,7,10,12]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[8,5,10,1,7,null,12]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The given preorder traversal constructs the following BST:

    8
   / \
  5   10
 / \   \
1   7   12</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">preorder = [1,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,null,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The tree has only two nodes: 1 and 3.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to the optimized solution is to efficiently traverse the preorder array while maintaining the BST property. This is achieved by passing lower and upper bounds to each recursive call, which define the valid range for the nodes in the subtree. Consider the edge case of empty input or cases where the input is not a valid preorder traversal. Also, handle cases where the input array has duplicate values (although the prompt does not explicitly say there won't be duplicates, the BST structure inherently assumes unique values).</p>
</div>
<hr style="margin: 40px 0;">
<h2>GRAPHS</h2>
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/bfs-traversal-of-graph/1>BFS traversal of graph</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given a directed graph having A nodes labeled from 0 to A-1, represented by an adjacency list. You are given a list of edges where edges[i] = [Ui, Vi] denotes an edge from node Ui to node Vi. Find the BFS traversal of the graph starting from the node 0. Note: The graph may contain disconnected components. Return a list of integers denoting the BFS traversal of the graph.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the graph using BFS. For each visited node, add its unvisited neighbors to the queue.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

vector&lt;int&gt bfsOfGraph(int V, vector&lt;int&gt adj[]) {
    vector&lt;int&gt bfs_traversal;
    vector&lt;bool&gt visited(V, false);
    queue&lt;int&gt q;

    q.push(0);
    visited[0] = true;

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        bfs_traversal.push_back(u);

        for (int v : adj[u]) {
            if (!visited[v]) {
                visited[v] = true;
                q.push(v);
            }
        }
    }
    return bfs_traversal;
}
</code></pre>
  <p><b>Time Complexity:</b> O(V + E), where V is the number of vertices and E is the number of edges. | <b>Space Complexity:</b> O(V) in the worst case, to store the visited array and the queue. </p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ BFS with Adjacency List</h5>
  <p>Uses an adjacency list to represent the graph.  A queue is used to perform the BFS traversal.  The algorithm starts at node 0, marks it as visited, and adds it to the BFS result.  Then, while the queue is not empty, it dequeues a node, and for each of its neighbors, if the neighbor hasn't been visited, it marks the neighbor as visited, adds it to the queue, and adds it to the result. This process ensures all reachable nodes are visited in breadth-first order.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

vector&lt;int&gt bfsOfGraph(int V, vector&lt;int&gt adj[]) {
    vector&lt;int&gt bfs_traversal;
    vector&lt;bool&gt visited(V, false);
    queue&lt;int&gt q;

    q.push(0);
    visited[0] = true;

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        bfs_traversal.push_back(u);

        for (int v : adj[u]) {
            if (!visited[v]) {
                visited[v] = true;
                q.push(v);
            }
        }
    }
    return bfs_traversal;
}
</code></pre>
  <p><b>Time Complexity:</b> O(V + E), where V is the number of vertices and E is the number of edges. | <b>Space Complexity:</b> O(V) in the worst case (for visited array and queue).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">V = 5, edges = [[0, 1], [0, 2], [0, 3], [1, 2]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0 1 2 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Starting from vertex 0, BFS traversal gives 0, then its neighbors 1, 2, 3 (in ascending order of node number).  Node 1's neighbor 2 is already visited and so on.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">V = 3, edges = [[0, 2], [1, 0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Starting from 0, we first add 0. Then add its neighbors 2.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The graph can be disconnected. The starting node for BFS is always 0.  The result should contain all reachable nodes from node 0 in the order they are encountered during BFS. Duplicate nodes should not appear in the result. The edges are undirected.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/>Depth First Search or DFS for a Graph</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given a graph represented as an adjacency list, implement Depth First Search (DFS) to traverse the graph. DFS starts at a given source vertex and explores as far as possible along each branch before backtracking. The goal is to visit all reachable vertices from the source vertex.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach directly implements the DFS algorithm. It uses recursion or an explicit stack to explore vertices.  It starts at the source vertex, marks it as visited, and then recursively (or iteratively) explores all its unvisited neighbors. The process repeats for each unvisited neighbor until all reachable vertices are visited.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

void dfs_recursive(int node, vector&lt;vector&lt;int&gt;&gt;&amp; adj, vector&lt;bool&gt;&amp; visited, vector&lt;int&gt;&amp; dfs_traversal) {
    visited[node] = true;
    dfs_traversal.push_back(node);
    for (int neighbor : adj[node]) {
        if (!visited[neighbor]) {
            dfs_recursive(neighbor, adj, visited, dfs_traversal);
        }
    }
}

vector&lt;int&gt; dfs(int start_node, vector&lt;vector&lt;int&gt;&gt;&amp; adj, int num_vertices) {
    vector&lt;bool&gt; visited(num_vertices, false);
    vector&lt;int&gt; dfs_traversal;
    dfs_recursive(start_node, adj, visited, dfs_traversal);
    return dfs_traversal;
}

int main() {
    int num_vertices, num_edges;
    cin &gt;&gt; num_vertices &gt;&gt; num_edges;

    vector&lt;vector&lt;int&gt;&gt; adj(num_vertices);
    for (int i = 0; i &lt; num_edges; ++i) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        adj[u].push_back(v);
        adj[v].push_back(u); // For undirected graph
    }

    int start_node = 0; // Start DFS from node 0
    vector&lt;int&gt; traversal = dfs(start_node, adj, num_vertices);

    cout &lt;&lt; "DFS Traversal: ";
    for (int node : traversal) {
        cout &lt;&lt; node &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(V + E), where V is the number of vertices and E is the number of edges in the graph. In the worst case, we visit all vertices and traverse all edges. | <b>Space Complexity:</b> O(V) in the worst case, for the visited array and the recursion call stack (in the recursive implementation) or the stack (in the iterative implementation). </p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized DFS (Recursive)</h5>
  <p>This is essentially the same as the brute-force approach but is more clearly formatted and commented, making it easier to understand and maintain. The core logic of DFS remains the same: visit a node, mark it as visited, and recursively explore its unvisited neighbors.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

void dfs_recursive(int node, vector&lt;vector&lt;int&gt;&gt;&amp; adj, vector&lt;bool&gt;&amp; visited, vector&lt;int&gt;&amp; dfs_traversal) {
    // Mark the current node as visited.
    visited[node] = true;
    // Add the current node to the traversal sequence.
    dfs_traversal.push_back(node);

    // Iterate through the neighbors of the current node.
    for (int neighbor : adj[node]) {
        // If a neighbor hasn't been visited, recursively call DFS on it.
        if (!visited[neighbor]) {
            dfs_recursive(neighbor, adj, visited, dfs_traversal);
        }
    }
}

vector&lt;int&gt; dfs(int start_node, vector&lt;vector&lt;int&gt;&gt;&amp; adj, int num_vertices) {
    // Initialize a visited array to keep track of visited nodes.
    vector&lt;bool&gt; visited(num_vertices, false);
    // Initialize a vector to store the DFS traversal.
    vector&lt;int&gt; dfs_traversal;
    // Call the recursive DFS function starting from the specified node.
    dfs_recursive(start_node, adj, visited, dfs_traversal);
    // Return the DFS traversal.
    return dfs_traversal;
}

int main() {
    // Get the number of vertices and edges from the input.
    int num_vertices, num_edges;
    cin &gt;&gt; num_vertices &gt;&gt; num_edges;

    // Create an adjacency list to represent the graph.
    vector&lt;vector&lt;int&gt;&gt; adj(num_vertices);

    // Read the edges and build the adjacency list.
    for (int i = 0; i &lt; num_edges; ++i) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        adj[u].push_back(v);
        adj[v].push_back(u); // For undirected graph
    }

    // Choose a starting node for DFS.
    int start_node = 0; // Start DFS from node 0

    // Perform DFS and get the traversal.
    vector&lt;int&gt; traversal = dfs(start_node, adj, num_vertices);

    // Print the DFS traversal.
    cout &lt;&lt; "DFS Traversal: ";
    for (int node : traversal) {
        cout &lt;&lt; node &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(V + E) | <b>Space Complexity:</b> O(V)</p>
  <h5>‚û§ Optimized DFS (Iterative)</h5>
  <p>An iterative version of DFS, using a stack to simulate the recursion. This avoids potential stack overflow issues with very large graphs. It maintains a stack of nodes to visit and processes them one by one. This implementation avoids recursion and uses a stack explicitly.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

vector&lt;int&gt; dfs_iterative(int start_node, vector&lt;vector&lt;int&gt;&gt;&amp; adj, int num_vertices) {
    vector&lt;bool&gt; visited(num_vertices, false);
    vector&lt;int&gt; dfs_traversal;
    stack&lt;int&gt; s;

    s.push(start_node);

    while (!s.empty()) {
        int node = s.top();
        s.pop();

        if (!visited[node]) {
            visited[node] = true;
            dfs_traversal.push_back(node);

            // Push neighbors onto the stack in reverse order for correct DFS traversal
            for (int i = adj[node].size() - 1; i &gt;= 0; --i) {
                int neighbor = adj[node][i];
                if (!visited[neighbor]) {
                    s.push(neighbor);
                }
            }
        }
    }

    return dfs_traversal;
}

int main() {
    int num_vertices, num_edges;
    cin &gt;&gt; num_vertices &gt;&gt; num_edges;

    vector&lt;vector&lt;int&gt;&gt; adj(num_vertices);
    for (int i = 0; i &lt; num_edges; ++i) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        adj[u].push_back(v);
        adj[v].push_back(u); // For undirected graph
    }

    int start_node = 0;
    vector&lt;int&gt; traversal = dfs_iterative(start_node, adj, num_vertices);

    cout &lt;&lt; "DFS Traversal: ";
    for (int node : traversal) {
        cout &lt;&lt; node &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(V + E) | <b>Space Complexity:</b> O(V)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">4 3
0 1
0 2
1 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">DFS Traversal: 0 1 2 </td>
        <td style="border: 1px solid #ccc; padding: 6px;">The graph has 4 vertices and 3 edges.  DFS starting at node 0 visits 0, then 1, and then 2.  The order might vary depending on the adjacency list representation.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">5 4
0 1
0 2
1 3
2 4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">DFS Traversal: 0 1 3 2 4 </td>
        <td style="border: 1px solid #ccc; padding: 6px;">A more complex graph demonstrating DFS traversal.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  **Graph Representation:** The code assumes an adjacency list representation of the graph.  
2.  **Undirected vs. Directed:** The code can easily be adapted for directed graphs by removing the `adj[v].push_back(u)` line when reading the edges.  
3.  **Disconnected Graphs:**  If the graph is disconnected, the DFS function will only visit the vertices reachable from the starting node.  To visit all vertices in a disconnected graph, you would need to iterate through all vertices and call DFS from each unvisited vertex.  
4.  **Starting Node:** The DFS traversal depends on the starting node. Changing the starting node will produce a different traversal order.  
5.  **Space Optimization:**  In certain scenarios, the `visited` array could be represented using a `bitset` if the number of vertices is large and space optimization is crucial.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/number-of-islands/>Number of Islands</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.

An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves iterating through each cell of the grid. If a cell contains '1' (land), increment the island count and then perform a Depth-First Search (DFS) or Breadth-First Search (BFS) to mark all connected land cells as visited. This prevents recounting the same island.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int row, int col) {
        int rows = grid.size();
        int cols = grid[0].size();

        if (row &lt 0 || row &gt= rows || col &lt 0 || col &gt= cols || grid[row][col] == '0') {
            return;
        }

        grid[row][col] = '0'; // Mark as visited

        // Explore adjacent cells
        dfs(grid, row + 1, col);
        dfs(grid, row - 1, col);
        dfs(grid, row, col + 1);
        dfs(grid, row, col - 1);
    }

    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
        int rows = grid.size();
        if (rows == 0) return 0;
        int cols = grid[0].size();
        int numIslands = 0;

        for (int i = 0; i &lt rows; i++) {
            for (int j = 0; j &lt cols; j++) {
                if (grid[i][j] == '1') {
                    numIslands++;
                    dfs(grid, i, j);
                }
            }
        }
        return numIslands;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(M * N) where M and N are the dimensions of the grid.  In the worst case, we visit every cell in the grid. | <b>Space Complexity:</b> O(M * N) in the worst case due to the recursive call stack of DFS. In the average case, it would be less since it depends on the size of the islands.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized (DFS)</h5>
  <p>The optimized approach uses Depth-First Search (DFS) to traverse the grid. For each '1' encountered, DFS is used to explore and mark all connected land cells as visited, effectively counting one island. The algorithm then proceeds to the next unvisited cell.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int row, int col) {
        int rows = grid.size();
        int cols = grid[0].size();

        if (row &lt 0 || row &gt= rows || col &lt 0 || col &gt= cols || grid[row][col] == '0') {
            return;
        }

        grid[row][col] = '0'; // Mark as visited

        // Explore adjacent cells
        dfs(grid, row + 1, col);
        dfs(grid, row - 1, col);
        dfs(grid, row, col + 1);
        dfs(grid, row, col - 1);
    }

    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
        int rows = grid.size();
        if (rows == 0) return 0;
        int cols = grid[0].size();
        int numIslands = 0;

        for (int i = 0; i &lt rows; i++) {
            for (int j = 0; j &lt cols; j++) {
                if (grid[i][j] == '1') {
                    numIslands++;
                    dfs(grid, i, j);
                }
            }
        }
        return numIslands;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(M * N) where M and N are the dimensions of the grid.  We visit each cell at most once. | <b>Space Complexity:</b> O(M * N) in the worst case due to the recursion call stack for DFS.  In the average case, this is typically less, depending on the island sizes.</p>
  <h5>‚û§ Optimized (BFS)</h5>
  <p>Similar to DFS, but uses Breadth-First Search (BFS).  For each '1', a BFS is performed to mark connected land as visited. The algorithm uses a queue to manage the cells to explore.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
        int rows = grid.size();
        if (rows == 0) return 0;
        int cols = grid[0].size();
        int numIslands = 0;

        for (int i = 0; i &lt rows; i++) {
            for (int j = 0; j &lt cols; j++) {
                if (grid[i][j] == '1') {
                    numIslands++;
                    // BFS to mark the island
                    queue&lt;pair&lt;int, int&gt;&gt; q;
                    q.push({i, j});
                    grid[i][j] = '0'; // Mark as visited

                    while (!q.empty()) {
                        int row = q.front().first;
                        int col = q.front().second;
                        q.pop();

                        // Explore adjacent cells
                        int dr[] = {0, 0, 1, -1};
                        int dc[] = {1, -1, 0, 0};

                        for (int k = 0; k &lt 4; k++) {
                            int newRow = row + dr[k];
                            int newCol = col + dc[k];

                            if (newRow &gt= 0 &amp;&amp; newRow &lt rows &amp;&amp; newCol &gt= 0 &amp;&amp; newCol &lt cols &amp;&amp; grid[newRow][newCol] == '1') {
                                grid[newRow][newCol] = '0';
                                q.push({newRow, newCol});
                            }
                        }
                    }
                }
            }
        }
        return numIslands;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(M * N) where M and N are the dimensions of the grid. | <b>Space Complexity:</b> O(M * N) in the worst case for the queue used in BFS (e.g., if the entire grid is an island).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The grid contains only one island.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The grid contains three islands.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[["0"]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The grid contains no islands.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases to consider include empty grids, grids with all '0's, and grids where islands are connected horizontally and vertically.  The main idea is to efficiently traverse the grid and mark visited land cells so they are not counted again.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/flood-fill/>Flood Fill</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given a 2D integer array `image` representing the pixel values of a picture, and integers `sr` and `sc` representing the starting row and column respectively, and `color` representing the new color value.  A flood fill is performed on the image starting from the pixel `image[sr][sc]`.  A flood fill will change the color of all pixels connected to the starting pixel with the same color as the starting pixel to the new `color`.  Return the modified image after the flood fill.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves using Depth-First Search (DFS) or Breadth-First Search (BFS) to traverse the image and change the color of the connected components of the starting pixel's color.  The algorithm checks the four neighbors (up, down, left, right) of the current pixel and recursively (DFS) or iteratively (BFS) explores those neighbors that have the same initial color, changing their color to the target color.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int color) {
        int rows = image.size();
        int cols = image[0].size();
        int initialColor = image[sr][sc];

        if (initialColor == color) {
            return image;
        }

        dfs(image, sr, sc, initialColor, color, rows, cols);
        return image;
    }

private:
    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; image, int row, int col, int initialColor, int color, int rows, int cols) {
        if (row &lt 0 || row &gt= rows || col &lt 0 || col &gt= cols || image[row][col] != initialColor) {
            return;
        }

        image[row][col] = color;

        dfs(image, row + 1, col, initialColor, color, rows, cols); // Down
        dfs(image, row - 1, col, initialColor, color, rows, cols); // Up
        dfs(image, row, col + 1, initialColor, color, rows, cols); // Right
        dfs(image, row, col - 1, initialColor, color, rows, cols); // Left
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of pixels in the image. In the worst case, we might visit all the pixels. | <b>Space Complexity:</b> O(N) in worst case due to recursion stack (DFS) or the queue (BFS), where N is the number of pixels in the image.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Depth-First Search (DFS)</h5>
  <p>Use DFS to traverse and change the color.  This is essentially the same as the brute force but described as optimal due to its common use and efficiency for this problem.  It's considered efficient because it avoids redundant calculations or memory overhead as much as possible for the given problem.  The function recursively calls itself to visit the neighbors, changing the colors accordingly.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int color) {
        int rows = image.size();
        int cols = image[0].size();
        int initialColor = image[sr][sc];

        if (initialColor == color) {
            return image;
        }

        dfs(image, sr, sc, initialColor, color, rows, cols);
        return image;
    }

private:
    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; image, int row, int col, int initialColor, int color, int rows, int cols) {
        if (row &lt 0 || row &gt= rows || col &lt 0 || col &gt= cols || image[row][col] != initialColor) {
            return;
        }

        image[row][col] = color;

        dfs(image, row + 1, col, initialColor, color, rows, cols); // Down
        dfs(image, row - 1, col, initialColor, color, rows, cols); // Up
        dfs(image, row, col + 1, initialColor, color, rows, cols); // Right
        dfs(image, row, col - 1, initialColor, color, rows, cols); // Left
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of pixels in the image. | <b>Space Complexity:</b> O(N) in worst case due to the recursion stack.</p>
  <h5>‚û§ Breadth-First Search (BFS)</h5>
  <p>Use BFS to traverse and change the color.  BFS uses a queue to keep track of the pixels to visit. It visits the pixels level by level. This approach offers a slightly different perspective but has similar complexity characteristics to the DFS approach for this specific problem.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int color) {
        int rows = image.size();
        int cols = image[0].size();
        int initialColor = image[sr][sc];

        if (initialColor == color) {
            return image;
        }

        queue&lt;pair&lt;int, int&gt;&gt; q;
        q.push({sr, sc});
        image[sr][sc] = color;

        while (!q.empty()) {
            pair&lt;int, int&gt; curr = q.front();
            q.pop();
            int r = curr.first;
            int c = curr.second;

            // Check neighbors
            int dr[] = {0, 0, 1, -1};
            int dc[] = {1, -1, 0, 0};

            for (int i = 0; i &lt 4; ++i) {
                int nr = r + dr[i];
                int nc = c + dc[i];

                if (nr &gt= 0 &amp;&amp; nr &lt rows &amp;&amp; nc &gt= 0 &amp;&amp; nc &lt cols &amp;&amp; image[nr][nc] == initialColor) {
                    image[nr][nc] = color;
                    q.push({nr, nc});
                }
            }
        }

        return image;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of pixels in the image. | <b>Space Complexity:</b> O(N) in worst case due to the queue.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[2,2,2],[2,2,0],[2,0,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The starting pixel is at (1, 1). It has the value 1. The connected component of value 1 is colored to value 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0,0,0],[0,0,0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The starting pixel is at (0, 0). It has the value 0. The connected component of value 0 is colored to value 0. The image is unchanged because the new color is the same as the starting color.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  **Edge Case:** If the initial color is the same as the new color, there's no need to change the image and can return the image directly.
2.  The `dfs` or `bfs` function needs to check the boundary conditions before processing any pixel to prevent out-of-bounds errors.
3. The image is modified in place. 
4. Both DFS and BFS have similar time complexity. Choice between DFS and BFS depends on specific requirements or preferences. DFS might be slightly more memory-efficient in some scenarios, but the difference is usually negligible for this problem.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/rat-in-a-maze-problem/1>Rat in a Maze Problem - I</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given a maze (a 2D matrix) where each cell can either be a blocked cell (represented by 0) or a path cell (represented by 1), find all possible paths for a rat to reach the destination cell (bottom-right cell) from the starting cell (top-left cell). The rat can only move right or down. The solution should be a matrix of the same size as the maze, where 1 represents the path and 0 represents the blocked cells or cells not in the path. If no path exists, return an empty vector.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves trying all possible combinations of right and down movements recursively. It explores every possible path until it either finds the destination or exhausts all possibilities. It keeps track of the current path and marks the cells in the path. Backtracking is used to revert the path when a dead end is reached or an invalid move is attempted.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool isSafe(int x, int y, int n, vector&lt;vector&lt;int&gt;&gt;&amp; maze, vector&lt;vector&lt;int&gt;&gt;&amp; sol) {
    return (x &gt= 0 &amp;&amp; x &lt n &amp;&amp; y &gt= 0 &amp;&amp; y &lt n &amp;&amp; maze[x][y] == 1 &amp;&amp; sol[x][y] == 0);
}

void solveMazeUtil(int x, int y, int n, vector&lt;vector&lt;int&gt;&gt;&amp; maze, vector&lt;vector&lt;int&gt;&gt;&amp; sol, vector&lt;string&gt;&amp; ans) {
    if (x == n - 1 &amp;&amp; y == n - 1) {
        string path = "";
        for (int i = 0; i &lt n; i++) {
            for (int j = 0; j &lt n; j++) {
                if (sol[i][j] == 1) {
                    path += "(" + to_string(i) + "," + to_string(j) + ") ";
                }
            }
        }
        ans.push_back(path);
        return;
    }

    if (isSafe(x, y, n, maze, sol)) {
        sol[x][y] = 1;

        // Move Right
        solveMazeUtil(x, y + 1, n, maze, sol, ans);

        // Move Down
        solveMazeUtil(x + 1, y, n, maze, sol, ans);

        sol[x][y] = 0; // Backtrack
    }
}

vector&lt;string&gt; findPath(vector&lt;vector&lt;int&gt;&gt;&amp; maze, int n) {
    vector&lt;string&gt; ans;
    vector&lt;vector&lt;int&gt;&gt; sol(n, vector&lt;int&gt;(n, 0));
    solveMazeUtil(0, 0, n, maze, sol, ans);
    sort(ans.begin(), ans.end()); // To match GFG output format
    return ans;
}
</code></pre>
  <p><b>Time Complexity:</b> O(2^(N*N)), where N is the size of the maze. In the worst-case scenario, the algorithm explores all possible paths, which grows exponentially with the size of the maze. | <b>Space Complexity:</b> O(N*N) due to the recursion stack and the solution matrix.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Backtracking with Optimization</h5>
  <p>This is similar to the brute-force approach but optimized by using boolean matrix and avoid redundant checks. The key optimization is to efficiently track visited cells using the `sol` matrix, so we don't revisit a cell already explored. It uses recursion to explore potential paths, backtracking when a dead end is reached. We maintain a boolean matrix 'sol' to mark the path.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool isSafe(int x, int y, int n, vector&lt;vector&lt;int&gt;&gt;&amp; maze, vector&lt;vector&lt;int&gt;&gt;&amp; sol) {
    return (x &gt= 0 &amp;&amp; x &lt n &amp;&amp; y &gt= 0 &amp;&amp; y &lt n &amp;&amp; maze[x][y] == 1 &amp;&amp; sol[x][y] == 0);
}

void solveMazeUtil(int x, int y, int n, vector&lt;vector&lt;int&gt;&gt;&amp; maze, vector&lt;vector&lt;int&gt;&gt;&amp; sol, vector&lt;string&gt;&amp; ans, string path) {
    if (x == n - 1 &amp;&amp; y == n - 1) {
        ans.push_back(path);
        return;
    }

    if (isSafe(x, y, n, maze, sol)) {
        sol[x][y] = 1;

        // Move Down
        solveMazeUtil(x + 1, y, n, maze, sol, ans, path + "D");

        // Move Right
        solveMazeUtil(x, y + 1, n, maze, sol, ans, path + "R");

        // Move Left
        solveMazeUtil(x, y - 1, n, maze, sol, ans, path + "L");

        // Move Up
        solveMazeUtil(x - 1, y, n, maze, sol, ans, path + "U");

        sol[x][y] = 0; // Backtrack
    }
}

vector&lt;string&gt; findPath(vector&lt;vector&lt;int&gt;&gt;&amp; maze, int n) {
    vector&lt;string&gt; ans;
    vector&lt;vector&lt;int&gt;&gt; sol(n, vector&lt;int&gt;(n, 0));
    string path = "";
    solveMazeUtil(0, 0, n, maze, sol, ans, path);
    sort(ans.begin(), ans.end());
    return ans;
}
</code></pre>
  <p><b>Time Complexity:</b> O(4^(N*N)), where N is the size of the maze. In the worst-case, each cell can be visited in four directions (D, R, U, L). | <b>Space Complexity:</b> O(N*N) due to the recursion stack and the solution matrix.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1, 0, 0, 0],
 [1, 1, 0, 1],
 [1, 1, 0, 0],
 [0, 1, 1, 1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">DDRDRR DRDDRR</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The rat can move from (0, 0) to (3, 3) via two possible paths: DDRDRR and DRDDRR.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1, 0],
 [1, 0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;"></td>
        <td style="border: 1px solid #ccc; padding: 6px;">No path exists from (0, 0) to (1, 1) as the cell (0,1) is blocked.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. The rat can only move down or right. 2. The maze can have multiple paths. 3. If no path exists, return an empty vector or a list of paths.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/detect-cycle-in-an-undirected-graph/1>Detect cycle in an undirected graph</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given an undirected graph with V vertices and E edges, check whether it contains a cycle or not.  A cycle is a path that starts and ends at the same vertex.

Input: The first line of input contains the number of test cases T. For each test case, the first line contains two integers V and E. The next line contains E space separated pairs u v denoting an edge from u to v.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute force approach involves checking for cycles using Depth First Search (DFS) or Breadth First Search (BFS) without any optimizations. For each unvisited node, start a DFS/BFS and track the visited nodes. If during the traversal, we encounter a node that has already been visited and is not the parent of the current node, it indicates a cycle.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool isCycleUtil(int v, vector&lt;bool&gt;&amp; visited, vector&lt;int&gt; adj[], int parent) {
    visited[v] = true;
    for (int i = 0; i &lt; adj[v].size(); i++) {
        int u = adj[v][i];
        if (!visited[u]) {
            if (isCycleUtil(u, visited, adj, v))
                return true;
        } else if (u != parent)
            return true;
    }
    return false;
}

bool isCycle(int V, vector&lt;int&gt; adj[]) {
    vector&lt;bool&gt; visited(V, false);
    for (int i = 0; i &lt; V; i++)
        if (!visited[i])
            if (isCycleUtil(i, visited, adj, -1))
                return true;
    return false;
}

int main() {
    int T;
    cin &gt;&gt; T;
    while (T--) {
        int V, E;
        cin &gt;&gt; V &gt;&gt; E;
        vector&lt;int&gt; adj[V];
        for (int i = 0; i &lt; E; i++) {
            int u, v;
            cin &gt;&gt; u &gt;&gt; v;
            adj[u].push_back(v);
            adj[v].push_back(u);
        }
        if (isCycle(V, adj))
            cout &lt;&lt; "1" &lt;&lt; endl;
        else
            cout &lt;&lt; "0" &lt;&lt; endl;
    }
    return 0;
}</code></pre>
  <p><b>Time Complexity:</b> O(V + E) in the worst case (where V is the number of vertices and E is the number of edges) because we visit each node and edge once. | <b>Space Complexity:</b> O(V) for the visited array, and O(V) in the worst-case recursion depth (due to DFS) or O(V) for the queue in BFS, and also O(E) for the adjacency list. Thus O(V+E) overall.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ DFS with Parent Tracking (Optimized)</h5>
  <p>We perform Depth First Search (DFS) on the graph. During the traversal, we keep track of the parent of each node. If we encounter a node that has already been visited and is not the parent of the current node, it indicates a cycle. This avoids redundant checks and efficiently detects cycles.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool isCycleUtil(int v, vector&lt;bool&gt;&amp; visited, vector&lt;int&gt; adj[], int parent) {
    visited[v] = true;
    for (int neighbor : adj[v]) {
        if (!visited[neighbor]) {
            if (isCycleUtil(neighbor, visited, adj, v))
                return true;
        }
         else if (neighbor != parent) {
            return true;
        }
    }
    return false;
}

bool isCycle(int V, vector&lt;int&gt; adj[]) {
    vector&lt;bool&gt; visited(V, false);
    for (int i = 0; i &lt; V; i++) {
        if (!visited[i]) {
            if (isCycleUtil(i, visited, adj, -1))
                return true;
        }
    }
    return false;
}

int main() {
    int T;
    cin &gt;&gt; T;
    while (T--) {
        int V, E;
        cin &gt;&gt; V &gt;&gt; E;
        vector&lt;int&gt; adj[V];
        for (int i = 0; i &lt; E; i++) {
            int u, v;
            cin &gt;&gt; u &gt;&gt; v;
            adj[u].push_back(v);
            adj[v].push_back(u);
        }
        if (isCycle(V, adj))
            cout &lt;&lt; "1" &lt;&lt; endl;
        else
            cout &lt;&lt; "0" &lt;&lt; endl;
    }
    return 0;
}</code></pre>
  <p><b>Time Complexity:</b> O(V + E) in the worst case, where V is the number of vertices and E is the number of edges. We visit each node and edge once. | <b>Space Complexity:</b> O(V) for the visited array, and O(V) in the worst-case recursion depth for the DFS (due to the call stack), and also O(E) for the adjacency list. Thus O(V+E) overall.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1
3 3
0 1
1 2
2 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The graph has a cycle: 0 -> 1 -> 2 -> 0</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1
4 2
0 1
2 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The graph has no cycle.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1
4 3
0 1
1 2
2 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The graph contains a cycle 0 -> 1 -> 2 -> 0</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  **Undirected Graph:** The problem specifies an undirected graph, so edges go both ways. Make sure to handle this when creating the adjacency list.
2.  **Disconnected Graph:** The graph might be disconnected, so you have to run DFS/BFS on all unvisited nodes.
3.  **Self-loops and Multiple Edges:** The problem doesn't explicitly mention handling self-loops or multiple edges between the same nodes, but the general cycle detection logic should work correctly if these are present (a self loop will immediately trigger cycle detection).
4.  **Input Format:** The input is formatted to indicate the number of test cases, vertices and edges, and edge pairs.  Make sure to parse the input correctly.
5. **Parent tracking**: The most crucial thing is to avoid going back immediately to the immediate parent when exploring neighbours, this can be tracked by an extra parameter `parent` to the recursive helper function.
</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/detect-cycle-in-a-graph/>Detect cycle in a directed graph</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given a directed graph, determine if it contains a cycle. A cycle is a path in the graph that starts and ends at the same node. Return true if a cycle exists, and false otherwise.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Depth-First Search (DFS) with cycle detection. For each node, perform DFS. While traversing, keep track of visited nodes and nodes currently in the recursion stack (the path being explored). If a node is encountered that's already in the recursion stack, a cycle is found.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

bool isCyclicUtil(int v, vector&lt;vector&lt;int&gt;&gt;&amp; adj, vector&lt;bool&gt;&amp; visited, vector&lt;bool&gt;&amp; recStack) {
    visited[v] = true;
    recStack[v] = true;

    for (int neighbor : adj[v]) {
        if (!visited[neighbor]) {
            if (isCyclicUtil(neighbor, adj, visited, recStack))
                return true;
        } else if (recStack[neighbor]) {
            return true;
        }
    }

    recStack[v] = false;
    return false;
}

bool isCyclic(int V, vector&lt;vector&lt;int&gt;&gt;&amp; adj) {
    vector&lt;bool&gt; visited(V, false);
    vector&lt;bool&gt; recStack(V, false);

    for (int i = 0; i &lt V; i++) {
        if (!visited[i]) {
            if (isCyclicUtil(i, adj, visited, recStack))
                return true;
        }
    }
    return false;
}

// Function to add an edge to the graph
void addEdge(vector&lt;vector&lt;int&gt;&gt;&amp; adj, int u, int v) {
    adj[u].push_back(v);
}

int main() {
    int V = 4;
    vector&lt;vector&lt;int&gt;&gt; adj(V);
    addEdge(adj, 0, 1);
    addEdge(adj, 0, 2);
    addEdge(adj, 1, 2);
    addEdge(adj, 2, 0);

    if (isCyclic(V, adj))
        cout &lt&lt "Graph contains cycle\n";
    else
        cout &lt&lt "Graph doesn't contain cycle\n";

    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(V + E), where V is the number of vertices and E is the number of edges. In the worst case, we visit all vertices and edges. | <b>Space Complexity:</b> O(V) due to the visited and recStack arrays, and the recursion stack in the worst-case scenario (a long path).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ DFS with cycle detection (Optimized)</h5>
  <p>Depth-First Search (DFS) with cycle detection using colors: Unvisited (0), Visiting (1 - currently in the stack), and Visited (2). If a node is currently being visited (color is 1) when encountered during DFS, a cycle is detected.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

bool isCyclicUtil(int v, vector&lt;vector&lt;int&gt;&gt;&amp; adj, vector&lt;int&gt;&amp; color) {
    color[v] = 1; // Mark as currently in the recursion stack

    for (int neighbor : adj[v]) {
        if (color[neighbor] == 0) {
            if (isCyclicUtil(neighbor, adj, color))
                return true;
        } else if (color[neighbor] == 1) {
            return true; // Cycle found
        }
    }

    color[v] = 2; // Mark as visited
    return false;
}

bool isCyclic(int V, vector&lt;vector&lt;int&gt;&gt;&amp; adj) {
    vector&lt;int&gt; color(V, 0); // 0: unvisited, 1: visiting, 2: visited

    for (int i = 0; i &lt V; i++) {
        if (color[i] == 0) {
            if (isCyclicUtil(i, adj, color))
                return true;
        }
    }
    return false;
}

// Function to add an edge to the graph
void addEdge(vector&lt;vector&lt;int&gt;&gt;&amp; adj, int u, int v) {
    adj[u].push_back(v);
}

int main() {
    int V = 4;
    vector&lt;vector&lt;int&gt;&gt; adj(V);
    addEdge(adj, 0, 1);
    addEdge(adj, 0, 2);
    addEdge(adj, 1, 2);
    addEdge(adj, 2, 0);

    if (isCyclic(V, adj))
        cout &lt&lt "Graph contains cycle\n";
    else
        cout &lt&lt "Graph doesn't contain cycle\n";

    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(V + E), where V is the number of vertices and E is the number of edges. | <b>Space Complexity:</b> O(V) for the color array and the recursion stack in worst case.</p>
  <h5>‚û§ Topological Sort using Kahn's Algorithm (Cycle Detection)</h5>
  <p>If a topological sort of a directed graph is possible, then the graph has no cycles.  If topological sort is not possible, it indicates the presence of a cycle. Kahn's algorithm uses in-degrees and a queue to perform topological sort. If the number of visited nodes equals the number of nodes in the graph, then there's no cycle. Otherwise, a cycle exists.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

bool isCyclic(int V, vector&lt;vector&lt;int&gt;&gt;&amp; adj) {
    vector&lt;int&gt; inDegree(V, 0);

    // Calculate in-degrees
    for (int i = 0; i &lt V; i++) {
        for (int neighbor : adj[i]) {
            inDegree[neighbor]++;
        }
    }

    queue&lt;int&gt; q;
    for (int i = 0; i &lt V; i++) {
        if (inDegree[i] == 0)
            q.push(i);
    }

    int count = 0;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        count++;

        for (int neighbor : adj[u]) {
            inDegree[neighbor]--;
            if (inDegree[neighbor] == 0)
                q.push(neighbor);
        }
    }

    return count != V; // If count != V, a cycle exists
}

// Function to add an edge to the graph
void addEdge(vector&lt;vector&lt;int&gt;&gt;&amp; adj, int u, int v) {
    adj[u].push_back(v);
}

int main() {
    int V = 4;
    vector&lt;vector&lt;int&gt;&gt; adj(V);
    addEdge(adj, 0, 1);
    addEdge(adj, 0, 2);
    addEdge(adj, 1, 2);
    addEdge(adj, 2, 0);

    if (isCyclic(V, adj))
        cout &lt&lt "Graph contains cycle\n";
    else
        cout &lt&lt "Graph doesn't contain cycle\n";

    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(V + E), where V is the number of vertices and E is the number of edges. | <b>Space Complexity:</b> O(V) for the inDegree array and the queue.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">V = 3, edges = [[0,1],[1,2],[2,0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The edges form a cycle: 0 -> 1 -> 2 -> 0</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">V = 3, edges = [[0,1],[1,2]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No cycle exists.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">V = 4, edges = [[0,1],[2,3],[3,0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Cycle exists 0->1 and 3->0 also 3->0</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  A directed graph is cyclic if there's a path from a node back to itself.
2.  DFS is a common and relatively straightforward approach. The color-based DFS is a more efficient and less verbose way to implement cycle detection in DFS.
3. Kahn's Algorithm (Topological Sort) can also be used. If topological sort is possible for all nodes, no cycle exists. If not all nodes can be visited in the topological sort, then there is a cycle.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/steps-by-knight5927/1>Steps by Knight</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a chessboard of size N x N, a knight is initially at the position (KnightPos) and wants to reach the position (TargetPos). Find the minimum number of steps required for the knight to reach the target position. The knight can move in an 'L' shape (two squares in one direction and one square in a perpendicular direction).</p>

  <h4>üß† Brute Force Approach</h4>
  <p>This approach uses Breadth-First Search (BFS) to explore all possible knight moves. It starts at the Knight's initial position and explores all reachable positions level by level, keeping track of the steps taken. This is essentially a graph traversal problem where each cell on the chessboard is a node, and the knight's possible moves are the edges.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;climits&gt; // Required for INT_MAX

using namespace std;

struct Cell {
    int x, y, dist;
};

int knightMovesBruteForce(int N, int KnightPos[], int TargetPos[]) {
    // Convert 1-based indexing to 0-based indexing
    int knightX = KnightPos[0] - 1, knightY = KnightPos[1] - 1;
    int targetX = TargetPos[0] - 1, targetY = TargetPos[1] - 1;

    // Create a queue for BFS
    queue&lt;Cell&gt; q;
    q.push({knightX, knightY, 0});

    // Create a visited array to track visited cells
    vector&lt;vector&lt;bool&gt;&gt; visited(N, vector&lt;bool&gt;(N, false));
    visited[knightX][knightY] = true;

    // Possible knight moves
    int dx[] = {-2, -2, -1, -1, 1, 1, 2, 2};
    int dy[] = {-1, 1, -2, 2, -2, 2, -1, 1};

    while (!q.empty()) {
        Cell curr = q.front();
        q.pop();

        // If the target is reached, return the distance
        if (curr.x == targetX &amp;&amp; curr.y == targetY) {
            return curr.dist;
        }

        // Explore all possible knight moves
        for (int i = 0; i &lt; 8; i++) {
            int nextX = curr.x + dx[i];
            int nextY = curr.y + dy[i];

            // Check if the move is valid and not visited
            if (nextX &gt;= 0 &amp;&amp; nextX &lt; N &amp;&amp; nextY &gt;= 0 &amp;&amp; nextY &lt; N &amp;&amp; !visited[nextX][nextY]) {
                visited[nextX][nextY] = true;
                q.push({nextX, nextY, curr.dist + 1});
            }
        }
    }
    return -1; // Target cannot be reached
}

</code></pre>
  <p><b>Time Complexity:</b> O(N^2) in the worst case, where N is the size of the chessboard.  This is because in the worst case, we might need to visit all cells. | <b>Space Complexity:</b> O(N^2).  The `visited` array uses O(N^2) space.  The queue can also store at most O(N^2) cells in the worst case.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized BFS</h5>
  <p>This is the same approach as the brute-force, but with minor optimization by using a queue and a visited array to keep track of cells.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;

using namespace std;

struct Cell {
    int x, y, dist;
};

int knightMovesOptimized(int N, int KnightPos[], int TargetPos[]) {
    // Convert 1-based indexing to 0-based indexing
    int knightX = KnightPos[0] - 1, knightY = KnightPos[1] - 1;
    int targetX = TargetPos[0] - 1, targetY = TargetPos[1] - 1;

    // Create a queue for BFS
    queue&lt;Cell&gt; q;
    q.push({knightX, knightY, 0});

    // Create a visited array to track visited cells
    vector&lt;vector&lt;bool&gt;&gt; visited(N, vector&lt;bool&gt;(N, false));
    visited[knightX][knightY] = true;

    // Possible knight moves
    int dx[] = {-2, -2, -1, -1, 1, 1, 2, 2};
    int dy[] = {-1, 1, -2, 2, -2, 2, -1, 1};

    while (!q.empty()) {
        Cell curr = q.front();
        q.pop();

        // If the target is reached, return the distance
        if (curr.x == targetX &amp;&amp; curr.y == targetY) {
            return curr.dist;
        }

        // Explore all possible knight moves
        for (int i = 0; i &lt; 8; i++) {
            int nextX = curr.x + dx[i];
            int nextY = curr.y + dy[i];

            // Check if the move is valid and not visited
            if (nextX &gt;= 0 &amp;&amp; nextX &lt; N &amp;&amp; nextY &gt;= 0 &amp;&amp; nextY &lt; N &amp;&amp; !visited[nextX][nextY]) {
                visited[nextX][nextY] = true;
                q.push({nextX, nextY, curr.dist + 1});
            }
        }
    }
    return -1; // Target cannot be reached
}
</code></pre>
  <p><b>Time Complexity:</b> O(N^2). In the worst-case scenario, the algorithm needs to explore all the cells on the chessboard. | <b>Space Complexity:</b> O(N^2). The `visited` array will use O(N^2) space. The queue can store at most O(N^2) cells.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">N = 8, KnightPos = {1, 1}, TargetPos = {8, 8}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The knight can reach (8, 8) from (1, 1) in 6 moves.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">N = 8, KnightPos = {1, 1}, TargetPos = {2, 3}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The knight can reach (2, 3) from (1, 1) in 1 move.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">N = 3, KnightPos = {1,1}, TargetPos = {2,2}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The knight requires two moves to reach from (1,1) to (2,2)</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to solving this problem is using Breadth-First Search (BFS). BFS guarantees that the shortest path is found because it explores all possible paths level by level.  Consider the edge case where the target is unreachable. Also important to handle the 1-based indexing provided in the problem description correctly, converting it to 0-based for array access.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/decode-string/>Decode String</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an encoded string, return its decoded string.

The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is repeated exactly k times. Note that k is guaranteed to be a positive integer.

You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc.

Furthermore, the original data does not contain any numbers except for those that describe the number of repeatitions, k. For example, there will not be input like '3a' or '2[4[aa]2[b]]'.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>This approach involves using recursion to decode the string.  The function will iterate through the string. If it encounters a digit, it will calculate the repetition count. Then, it will recursively decode the substring within the brackets and repeat the result based on the count. The base case is when no more brackets or digits are found.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string decodeString(string s) {
    string result = "";
    int i = 0;
    while (i &lt s.length()) {
        if (isdigit(s[i])) {
            int count = 0;
            while (isdigit(s[i])) {
                count = count * 10 + (s[i] - '0');
                i++;
            }
            i++; // Skip '['
            int j = i, bracket_count = 0;
            while (i &lt s.length()) {
                if (s[i] == '[') bracket_count++;
                else if (s[i] == ']') {
                    if (bracket_count == 0) break;
                    bracket_count--;
                }
                i++;
            }
            string sub = decodeString(s.substr(j, i - j));
            for (int k = 0; k &lt count; k++) {
                result += sub;
            }
            i++; // Skip ']'
        }
        else {
            result += s[i];
            i++;
        }
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N * M) where N is the length of the string and M is the maximum level of nested brackets.  In worst case (e.g., nested brackets and large repetition counts), the substring operation and string concatenation can be expensive. | <b>Space Complexity:</b> O(N * M) due to recursive call stack and the size of the resultant string. M is the maximum nesting depth.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Stack-based Approach</h5>
  <p>This approach uses two stacks: one for the repetition counts (integers) and another for the characters/strings. Iterate through the string.

1.  If it's a digit: calculate the count and push it onto the count stack.
2.  If it's an opening bracket '[': push the current result string onto the string stack and reset the result string.
3.  If it's a closing bracket ']': Pop the previous string from the string stack, pop the count from the count stack, and append the current result string repeated count times to the previous string. Update the result with this combined string.
4.  If it's a character, just append it to the result string.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string decodeString(string s) {
    stack&lt;int&gt; counts;
    stack&lt;string&gt; results;
    string result = "";
    int i = 0;
    while (i &lt s.length()) {
        if (isdigit(s[i])) {
            int count = 0;
            while (isdigit(s[i])) {
                count = count * 10 + (s[i] - '0');
                i++;
            }
            counts.push(count);
        }
        else if (s[i] == '[') {
            results.push(result);
            result = "";
            i++;
        }
        else if (s[i] == ']') {
            string prevResult = results.top();
            results.pop();
            int count = counts.top();
            counts.pop();
            for (int j = 0; j &lt count; j++) {
                prevResult += result;
            }
            result = prevResult;
            i++;
        }
        else {
            result += s[i];
            i++;
        }
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N) where N is the length of the string, since each character is visited at most a constant number of times. | <b>Space Complexity:</b> O(N) in the worst case, due to the stacks potentially holding all characters or counts in nested scenarios.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">3[a]2[bc]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">aaabcbc</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3[a] is 'aaa', 2[bc] is 'bcbc'. Concatenating gives aaabcbc.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">3[z]2[2[y]pq]ef</td>
        <td style="border: 1px solid #ccc; padding: 6px;">zzzypqypqef</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2[2[y]pq] becomes 'ypqypq', then 3[z] and the preceding string is joined, gives zzzypqypqef.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">abc3[cd]xyz</td>
        <td style="border: 1px solid #ccc; padding: 6px;">abccdcdcdxyz</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Simple example demonstrating string concatenation and repetition.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The stack-based approach is generally preferred because it is more efficient (O(N) time complexity) than the recursive approach in terms of time and space complexity. Handle the edge cases where there are no brackets or digits carefully. Pay close attention to the order of operations when dealing with nested brackets. The validity of the input string is guaranteed, so there is no need to handle invalid inputs such as missing closing brackets or non-numeric characters where a count is expected, and other invalid characters.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/shortest-bridge/>Shortest Bridge</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>You are given an n x n binary matrix grid where 1 represents land and 0 represents water. A bridge is a path of 1's that connects two islands (islands are connected sets of 1's). You can only move in four directions (up, down, left, and right).  Find the shortest bridge, which is the smallest number of 0's you must flip to connect two islands.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>This approach involves exploring all possible pairs of cells from different islands and calculating the distance between them.  First, identify the two islands using DFS or BFS. Then, for each cell in the first island, compute the distance to every cell in the second island. The minimum of these distances, minus 1 (since we want the number of 0s flipped), gives the shortest bridge.  This is inefficient as it considers all pairs of cells.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

class Solution {
public:
    int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int n = grid.size();
        vector&lt;pair&lt;int, int&gt;&gt; island1, island2;
        vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(n, false));

        // Find the first island and mark it in island1 and visited
        bool found = false;
        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (grid[i][j] == 1) {
                    dfs(grid, i, j, visited, island1);
                    found = true;
                    break;
                }
            }
            if (found) break;
        }

        // Find the second island, not the first one
        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (grid[i][j] == 1 &amp;&amp; !visited[i][j]) {
                    dfs(grid, i, j, visited, island2);
                    break;
                }
            }
        }

        int min_dist = INT_MAX;
        for (const auto&amp; cell1 : island1) {
            for (const auto&amp; cell2 : island2) {
                min_dist = min(min_dist, abs(cell1.first - cell2.first) + abs(cell1.second - cell2.second) - 1);
            }
        }

        return min_dist;
    }

    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int r, int c, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, vector&lt;pair&lt;int, int&gt;&gt;&amp; island) {
        int n = grid.size();
        if (r &lt; 0 || r &gt;= n || c &lt; 0 || c &gt;= n || grid[r][c] == 0 || visited[r][c]) {
            return;
        }

        visited[r][c] = true;
        island.push_back({r, c});

        dfs(grid, r + 1, c, visited, island);
        dfs(grid, r - 1, c, visited, island);
        dfs(grid, r, c + 1, visited, island);
        dfs(grid, r, c - 1, visited, island);
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n^4), where n is the size of the grid.  The DFS to find each island is O(n^2).  Then, for each cell in island1, it iterates through all cells in island2, leading to O(n^4) in the worst case (if the islands are large). | <b>Space Complexity:</b> O(n^2) for the visited matrix and potentially O(n^2) for storing island cells (island1 and island2).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ BFS from one island</h5>
  <p>1.  **Identify one island using DFS:** Use Depth-First Search to find one island and mark its cells as visited. During the DFS, add the cells of the first island into a queue.
2.  **BFS to find the shortest bridge:** Start a Breadth-First Search from the cells of the first island (using the queue). Expand the search level by level. The moment the BFS hits the second island, the current level represents the shortest bridge distance.  This involves tracking the distance from each cell to the nearest island.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

class Solution {
public:
    int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int n = grid.size();
        vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(n, false));
        queue&lt;pair&lt;int, int&gt;&gt; q;
        bool found = false;

        // Find the first island and mark it as visited, add cells to queue
        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (grid[i][j] == 1) {
                    dfs(grid, i, j, visited, q);
                    found = true;
                    break;
                }
            }
            if (found) break;
        }

        // BFS to expand from the first island
        int level = 0;
        int dr[] = {0, 0, 1, -1};
        int dc[] = {1, -1, 0, 0};

        while (!q.empty()) {
            int size = q.size();
            for (int i = 0; i &lt; size; ++i) {
                auto curr = q.front();
                q.pop();
                int r = curr.first, c = curr.second;

                for (int k = 0; k &lt; 4; ++k) {
                    int nr = r + dr[k], nc = c + dc[k];
                    if (nr &gt;= 0 &amp;&amp; nr &lt; n &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; n &amp;&amp; !visited[nr][nc]) {
                        if (grid[nr][nc] == 1) {
                            return level;  // Found the second island!
                        }
                        q.push({nr, nc});
                        visited[nr][nc] = true;
                    }
                }
            }
            level++;
        }

        return -1; // Should not reach here as there are always two islands
    }

    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int r, int c, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, queue&lt;pair&lt;int, int&gt;&gt;&amp; q) {
        int n = grid.size();
        if (r &lt; 0 || r &gt;= n || c &lt; 0 || c &gt;= n || grid[r][c] == 0 || visited[r][c]) {
            return;
        }

        visited[r][c] = true;
        q.push({r, c});

        dfs(grid, r + 1, c, visited, q);
        dfs(grid, r - 1, c, visited, q);
        dfs(grid, r, c + 1, visited, q);
        dfs(grid, r, c - 1, visited, q);
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n^2), where n is the size of the grid. The DFS takes O(n^2) in the worst case, and the BFS also visits each cell at most once (O(n^2)). | <b>Space Complexity:</b> O(n^2) for the visited matrix and the queue (in the worst case, the queue might contain all cells of the grid).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0,1,0],[0,0,0],[0,0,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The shortest bridge is from the top-right 1 to the bottom-right 1, flipping two 0s.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The shortest bridge is from one island to the other, flipping one 0.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,0,0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Illustrative case with a smaller grid.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The grid is guaranteed to have exactly two islands.  
2.  The problem can be seen as a shortest path problem.  The BFS from one island is an efficient approach for finding the shortest path.
3. The problem statement implicitly requires calculating distance as the number of 0s to flip, thus the shortest path can be found using BFS level by level</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/number-of-operations-to-make-network-connected/>Number of Operations to Make Network Connected</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>You are given an array of connections where connections[i] = [u, v] represents a pair of nodes u and v that are connected. The network is represented as a graph. Return the minimum number of operations so that all the computers in the network are connected. An operation is defined as removing a connection and connecting it to another computer. If it is not possible to connect all computers, return -1.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute force approach involves trying all possible combinations of removing and re-connecting edges. We can generate all possible subsets of edges to remove, and then attempt to reconnect them to different nodes. This approach is highly inefficient because it involves checking all possible combinations, which leads to exponential time complexity. This is generally not a feasible solution for the problem.</p>
  <pre><code class="language-python">// Brute Force approach is highly inefficient and not practical for this problem.
// It is computationally expensive because of checking all possible combinations.

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

// This is a placeholder, since the brute force approach is impractical
int minOperationsBruteForce(int n, vector&lt;vector&lt;int&gt;&gt;&amp; connections) {
    return -1; // Indicates an invalid state or a very inefficient approach
}
</code></pre>
  <p><b>Time Complexity:</b> O(2^E * (E + V)), where E is the number of edges and V is the number of vertices. This is exponential due to checking all subsets of edges to remove and reconnect. | <b>Space Complexity:</b> O(E + V) to store graph and intermediate data structures for checking connectivity in each configuration.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Union-Find (Disjoint Set)</h5>
  <p>The optimal approach uses the Union-Find (Disjoint Set) data structure. First, we iterate through the connections and use union-find to merge the connected components. Then, we count the number of connected components. If the number of connections is less than n-1, where n is the number of nodes, then it is impossible to connect all nodes and we return -1. We then calculate the number of operations needed, which is the number of connected components minus 1. This assumes that we have enough redundant edges to connect the remaining unconnected components.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

// Helper function to find the parent of a node (with path compression)
int find(vector&lt;int&gt;&amp; parent, int i) {
    if (parent[i] == i) {
        return i;
    }
    return parent[i] = find(parent, parent[i]); // Path compression
}

// Helper function to perform union of two sets
void unite(vector&lt;int&gt;&amp; parent, vector&lt;int&gt;&amp; rank, int x, int y) {
    int rootX = find(parent, x);
    int rootY = find(parent, y);
    if (rootX != rootY) {
        if (rank[rootX] &lt; rank[rootY]) {
            parent[rootX] = rootY;
        } else if (rank[rootX] &gt; rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
    }
}

int makeConnected(int n, vector&lt;vector&lt;int&gt;&gt;&amp; connections) {
    int numConnections = connections.size();
    if (numConnections &lt; n - 1) {
        return -1; // Not enough connections to connect all computers
    }

    // Initialize parent and rank for Union-Find
    vector&lt;int&gt; parent(n);
    vector&lt;int&gt; rank(n, 0);
    for (int i = 0; i &lt; n; ++i) {
        parent[i] = i;
    }

    // Perform Union-Find on connections
    for (const auto&amp; connection : connections) {
        unite(parent, rank, connection[0], connection[1]);
    }

    // Count connected components
    int components = 0;
    for (int i = 0; i &lt; n; ++i) {
        if (parent[i] == i) {
            components++;
        }
    }

    return components - 1;
}
</code></pre>
  <p><b>Time Complexity:</b> O(E * alpha(V)), where E is the number of edges, V is the number of vertices, and alpha(V) is the inverse Ackermann function, which grows extremely slowly and can be considered as almost constant for practical purposes. | <b>Space Complexity:</b> O(V) for storing the parent and rank arrays in the Union-Find data structure.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 4, connections = [[0,1],[0,2],[1,2]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Remove edge [1, 2] and connect it to computer 3.  We are left with [0,1], [0,2] and [3]. There are 3 connected components. The minimum number of moves is 3 - 1 = 1.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Remove edge [0,1] and connect it to computer 4 and computer 5. We are left with [0,2], [0,3], [1,2], [1,3] and [4,5]. There are 3 connected components. The minimum number of moves is 3 - 1 = 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Remove edge [0,1] and connect it to computer 4. There are 2 connected components: [0,2,3] and [1,4]. The minimum number of moves is 2 - 1 = 1.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 6, connections = [[0,1],[0,2],[3,4],[2,3]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Remove edge [0,1] and connect to 5. 2 connected components. The minimum number of moves is 2 - 1 = 1.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 5, connections = [[0,1],[0,2],[3,4],[2,3]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Removing any edge will not connect every node. 0 operations are necessary.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Key points to consider include the case where there aren't enough connections to connect all computers (return -1). Another edge case to consider is the scenario where the network is already connected and the minimum number of moves is 0. The problem can be effectively solved with Union-Find which efficiently finds the connected components.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/find-eventual-safe-states/>Find Eventual Safe States</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a directed graph, return a list of all eventual safe states. A node is a safe state if every possible path starting from that node leads to a terminal node (i.e., a node with no outgoing edges). The graph is represented by an adjacency list where graph[i] is a list of all the nodes you can visit from node i.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through each node. For each node, perform a Depth-First Search (DFS) to check if it leads to a cycle. If a DFS from a node doesn't find a cycle, then the node is safe.  This is highly inefficient as we recompute for the same nodes multiple times.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    bool isSafe(int node, vector&lt;vector&lt;int&gt;&gt;&amp; graph, vector&lt;int&gt;&amp; visited, vector&lt;int&gt;&amp; path) {
        if (path[node]) {
            return false; // Cycle detected
        }
        if (visited[node]) {
            return true; // Already visited and safe
        }

        visited[node] = 1;
        path[node] = 1;

        for (int neighbor : graph[node]) {
            if (!isSafe(neighbor, graph, visited, path)) {
                return false;
            }
        }

        path[node] = 0; // Backtrack: remove node from path
        return true;
    }

    vector&lt;int&gt; eventualSafeNodes(vector&lt;vector&lt;int&gt;&gt;&amp; graph) {
        int n = graph.size();
        vector&lt;int&gt; safeNodes;
        vector&lt;int&gt; visited(n, 0);
        vector&lt;int&gt; path(n, 0);

        for (int i = 0; i &lt; n; ++i) {
            if (isSafe(i, graph, visited, path)) {
                safeNodes.push_back(i);
            }
        }
        return safeNodes;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N * (N + E)), where N is the number of nodes and E is the number of edges.  For each node, we might visit all other nodes in worst case. | <b>Space Complexity:</b> O(N) due to the visited and path vectors, also the call stack for DFS.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Using Cycle Detection with DFS and colors (Optimized)</h5>
  <p>Use DFS to detect cycles and color the nodes.  Maintain a `color` array to track the state of each node during the DFS traversal. A node can have one of the following states:

*   `0` (unvisited): The node hasn't been visited yet.
*   `1` (visiting): The node is currently in the recursion stack (part of the current path). This indicates a potential cycle.
*   `2` (safe): The node is safe (no cycles found starting from it).
*   `3` (unsafe): The node is part of a cycle and therefore is not safe.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    bool dfs(int node, vector&lt;vector&lt;int&gt;&gt;&amp; graph, vector&lt;int&gt;&amp; color) {
        if (color[node] != 0) {
            return color[node] == 2; // safe
        }

        color[node] = 1; // Mark as visiting

        for (int neighbor : graph[node]) {
            if (!dfs(neighbor, graph, color)) {
                color[node] = 3; // Mark as unsafe
                return false;
            }
        }

        color[node] = 2; // Mark as safe
        return true;
    }

    vector&lt;int&gt; eventualSafeNodes(vector&lt;vector&lt;int&gt;&gt;&amp; graph) {
        int n = graph.size();
        vector&lt;int&gt; color(n, 0);  // 0: unvisited, 1: visiting, 2: safe, 3: unsafe
        vector&lt;int&gt; safeNodes;

        for (int i = 0; i &lt; n; ++i) {
            if (dfs(i, graph, color)) {
                safeNodes.push_back(i);
            }
        }
        return safeNodes;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N + E), where N is the number of nodes and E is the number of edges.  Each node and edge is visited at most once. | <b>Space Complexity:</b> O(N) due to the color array and the recursion stack in worst case.</p>
  <h5>‚û§ Using Topological Sort</h5>
  <p>Utilize topological sort to determine safe nodes. Reverse the graph and perform topological sort. Nodes which are part of the sorted order from the reversed graph are safe.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    vector&lt;int&gt; eventualSafeNodes(vector&lt;vector&lt;int&gt;&gt;&amp; graph) {
        int n = graph.size();
        vector&lt;vector&lt;int&gt;&gt; reversedGraph(n);
        vector&lt;int&gt; inDegree(n, 0);

        // Reverse the graph and calculate in-degrees
        for (int i = 0; i &lt; n; ++i) {
            for (int neighbor : graph[i]) {
                reversedGraph[neighbor].push_back(i);
                inDegree[i]++;
            }
        }

        queue&lt;int&gt; q;
        for (int i = 0; i &lt; n; ++i) {
            if (inDegree[i] == 0) {
                q.push(i);
            }
        }

        vector&lt;int&gt; safeNodes;
        while (!q.empty()) {
            int node = q.front();
            q.pop();
            safeNodes.push_back(node);
            for (int neighbor : reversedGraph[node]) {
                inDegree[neighbor]--;
                if (inDegree[neighbor] == 0) {
                    q.push(neighbor);
                }
            }
        }

        sort(safeNodes.begin(), safeNodes.end());
        return safeNodes;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N + E), where N is the number of nodes and E is the number of edges.  We iterate through each node and edge once. | <b>Space Complexity:</b> O(N + E)  due to the reversed graph, inDegree array and the queue.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">graph = [[1,2],[2,3],[5],[0],[5],[],[]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[2,4,5,6]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Nodes 2, 4, 5, and 6 are safe.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Only node 4 is safe.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">graph = [[0],[2],[1],[0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[0,1,2,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">All nodes are safe.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases include empty graphs, graphs with self-loops, and graphs with cycles. Consider the direction of the edges carefully.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/strongly-connected-components-kosarajus-algo/1>Strongly Connected Components (Kosaraju's Algo)</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a directed graph, find the number of strongly connected components (SCCs) in the graph. A strongly connected component is a subgraph in which there is a path between every pair of vertices. The Kosaraju's algorithm is a standard algorithm to solve this problem.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach is not efficient for this problem. Finding SCCs through brute force would involve checking all possible paths between all pairs of nodes, which results in exponential time complexity. Hence, a naive approach is not suitable.</p>
  <pre><code class="language-python">// Brute force approach is not efficient for this problem.
// Consider using Kosaraju's algorithm for better performance.
</code></pre>
  <p><b>Time Complexity:</b> O(V! * (V + E)) where V is number of vertices and E is number of edges. Not practical. | <b>Space Complexity:</b> O(V + E)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Kosaraju's Algorithm</h5>
  <p>Kosaraju's algorithm is a two-pass algorithm that efficiently finds the strongly connected components (SCCs) in a directed graph. It uses Depth First Search (DFS) twice.  

1.  **First DFS (Topological Sort):** Perform DFS on the original graph and store the nodes in a stack based on their finishing times (i.e., after visiting all descendants).
2.  **Reverse the Graph:** Create a new graph by reversing the direction of all edges in the original graph.
3.  **Second DFS (on the reversed graph):** Perform DFS on the reversed graph. Iterate through the nodes in the order they were pushed onto the stack from the first DFS. For each node, if it hasn't been visited, perform DFS starting from that node. Each DFS call on the reversed graph identifies a single SCC.
4.  **Count SCCs:** The number of DFS calls in the second pass is equal to the number of SCCs.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

void dfs1(int node, vector&lt;int&gt; adj[], vector&lt;bool&gt;& visited, stack&lt;int&gt;& st)
{
    visited[node] = true;
    for (int neighbor : adj[node]) {
        if (!visited[neighbor]) {
            dfs1(neighbor, adj, visited, st);
        }
    }
    st.push(node);
}

void dfs2(int node, vector&lt;int&gt; adj[], vector&lt;bool&gt;& visited)
{
    visited[node] = true;
    for (int neighbor : adj[node]) {
        if (!visited[neighbor]) {
            dfs2(neighbor, adj, visited);
        }
    }
}

int kosaraju(int V, vector&lt;int&gt; adj[])
{
    vector&lt;bool&gt; visited(V, false);
    stack&lt;int&gt; st;

    // Step 1: Topological sort
    for (int i = 0; i &lt; V; i++) {
        if (!visited[i]) {
            dfs1(i, adj, visited, st);
        }
    }

    // Step 2: Reverse the graph
    vector&lt;int&gt; adj_rev[V];
    for (int i = 0; i &lt; V; i++) {
        for (int neighbor : adj[i]) {
            adj_rev[neighbor].push_back(i);
        }
    }

    // Step 3: DFS on reversed graph
    for (int i = 0; i &lt; V; i++) {
        visited[i] = false;
    }
    int count = 0;
    while (!st.empty()) {
        int node = st.top();
        st.pop();
        if (!visited[node]) {
            dfs2(node, adj_rev, visited);
            count++;
        }
    }
    return count;
}

int main()
{
    int V, E;
    cin &gt;&gt; V &gt;&gt; E;

    vector&lt;int&gt; adj[V];
    for (int i = 0; i &lt; E; i++) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        adj[u].push_back(v);
    }

    cout &lt;&lt; kosaraju(V, adj) &lt;&lt; endl;
    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(V + E), where V is the number of vertices and E is the number of edges. | <b>Space Complexity:</b> O(V + E) due to the adjacency list representation and the stack used for topological sorting.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">5 5
0 1
1 2
2 0
1 3
3 4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The graph has three strongly connected components: {0, 1, 2}, {3}, and {4}.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">3 3
0 1
1 2
2 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The entire graph forms a single SCC: {0, 1, 2}.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">4 2
0 1
2 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Each node is a separate SCC: {0}, {1}, {2}, {3}.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Key points:

*   The time complexity is linear with respect to the size of the graph.
*   The algorithm requires reversing the edges which is an important step.
*   Edge cases: Empty graph (0 vertices), graph with no edges, a graph where every node is isolated (no edges). A graph can have one or multiple SCCs.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/time-needed-to-inform-all-employees/>Time Needed to Inform All Employees</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>You are given an integer n, which represents the number of employees in a company. Each employee has an unique ID from 0 to n - 1. The head of the company is the employee with id 0. You are given a 0-indexed integer array managers where managers[i] represents the manager for the employee with id i. If managers[i] == -1, then employee i is the head of the company. You are also given a 0-indexed integer array informTime where informTime[i] is the time it takes for employee i to inform all of their direct subordinates (i.e., all employees managed by employee i). Return the time it takes for the head of the company to inform all of the employees. 

In essence, you need to find the longest path from the head (employee 0) to any other employee in the company, considering the time it takes for each employee to inform their subordinates.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>This approach uses Depth-First Search (DFS) to traverse the employee hierarchy. For each employee, it recursively calculates the time it takes to inform all subordinates. It starts from the head of the company (employee 0).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int numOfEmployees(int n, vector&lt;int&gt;&amp; managers, vector&lt;int&gt;&amp; informTime, int employee, vector&lt;vector&lt;int&gt;&gt;&amp; adj) {
    int maxTime = 0;
    for (int subordinate : adj[employee]) {
        maxTime = max(maxTime, numOfEmployees(n, managers, informTime, subordinate, adj));
    }
    return informTime[employee] + maxTime;
}

int timeToInform(int n, vector&lt;int&gt;&amp; managers, vector&lt;int&gt;&amp; informTime) {
    vector&lt;vector&lt;int&gt;&gt; adj(n);
    for (int i = 0; i &lt; n; ++i) {
        if (managers[i] != -1) {
            adj[managers[i]].push_back(i);
        }
    }
    return numOfEmployees(n, managers, informTime, 0, adj);
}
</code></pre>
  <p><b>Time Complexity:</b> O(N^2) in the worst case, where N is the number of employees. In the worst case, the hierarchy could be a skewed tree, leading to potentially quadratic complexity. | <b>Space Complexity:</b> O(N) for the adjacency list and the recursion stack in the worst case.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized DFS</h5>
  <p>This is also a DFS approach, but it avoids redundant calculations by memoizing the time it takes to inform subordinates. This significantly improves the efficiency compared to brute force.</p>
  <pre><code class="language-python">#include &lt;bits/stdc++.h&gt;
using namespace std;

int dfs(int employee, vector&lt;vector&lt;int&gt;&gt;&amp; adj, vector&lt;int&gt;&amp; informTime, vector&lt;int&gt;&amp; dp) {
    if (dp[employee] != -1) {
        return dp[employee];
    }
    int maxTime = 0;
    for (int subordinate : adj[employee]) {
        maxTime = max(maxTime, dfs(subordinate, adj, informTime, dp));
    }
    dp[employee] = informTime[employee] + maxTime;
    return dp[employee];
}

int timeToInform(int n, vector&lt;int&gt;&amp; managers, vector&lt;int&gt;&amp; informTime) {
    vector&lt;vector&lt;int&gt;&gt; adj(n);
    for (int i = 0; i &lt; n; ++i) {
        if (managers[i] != -1) {
            adj[managers[i]].push_back(i);
        }
    }
    vector&lt;int&gt; dp(n, -1);
    return dfs(0, adj, informTime, dp);
}
</code></pre>
  <p><b>Time Complexity:</b> O(N) where N is the number of employees.  Each employee's subtree is visited only once due to memoization. | <b>Space Complexity:</b> O(N) for the adjacency list and the dp array.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 6, managers = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The head is employee 2. The time it takes to inform all employees is 1.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 1, managers = [-1], informTime = [0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The head is employee 0. The time to inform all employees is 0.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 7, managers = [0,0,1,1,2,2,2], informTime = [1,2,2,1,1,1,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Employee 0 informs employees 1 and 2 in 1 unit of time. Employee 1 informs employees 3 and 4 in 2 units of time.  Employee 2 informs employees 5,6 in 2 units of time.  The longest path is 0 -> 1 -> 3 (or 4), so the maximum inform time is 1 + 2 + 1 = 4.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The critical element is to correctly construct the adjacency list representing the reporting structure. The problem can be visualized as finding the longest path from the root (head employee) to any leaf node in the employee hierarchy tree. Edge cases to consider are when there is only one employee, or when the company structure is a straight chain. Memory optimization using memoization (DP) is crucial to prevent Time Limit Exceeded errors, especially on larger test cases.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/graph-coloring-applications/#:~:text=Graph%20coloring%20problem%20is%20to,are%20colored%20using%20same%20color.>Graph Coloring</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>The graph coloring problem is a classic combinatorial optimization problem where the goal is to assign colors to the vertices (nodes) of a graph such that no two adjacent vertices share the same color. The objective is typically to use the minimum number of colors possible. This problem has many applications in scheduling, resource allocation, and other areas.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves trying all possible color assignments for each vertex. For a graph with 'V' vertices and 'K' available colors, this would involve a search space of K^V possibilities.  For each potential coloring, we check if it is valid (no adjacent vertices have the same color).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

// Function to check if the current coloring is safe
bool isSafe(int v, int color[], vector&ltvector&ltint&gt&gt;&amp; graph, int c)
{
    for (int i = 0; i &lt graph.size(); i++)
        if (graph[v][i] &amp;&amp; c == color[i])
            return false;
    return true;
}

// Recursive function to solve the graph coloring problem using brute force
bool graphColoringUtil(int m, int v, int color[], vector&ltvector&ltint&gt&gt;&amp; graph)
{
    if (v == graph.size())
        return true;

    for (int c = 1; c &lt= m; c++)
    {
        if (isSafe(v, color, graph, c))
        {
            color[v] = c;

            if (graphColoringUtil(m, v + 1, color, graph))
                return true;

            // If assigning color c doesn't lead to a solution, backtrack
            color[v] = 0; // Backtrack
        }
    }
    return false;
}

// Function to solve the graph coloring problem using brute force
bool graphColoring(int m, vector&ltvector&ltint&gt&gt;&amp; graph)
{
    int *color = new int[graph.size()];
    for (int i = 0; i &lt graph.size(); i++)
        color[i] = 0;

    if (!graphColoringUtil(m, 0, color, graph))
    {
        delete[] color;
        return false;
    }
    delete[] color;
    return true;
}

// Main function to test the code
int main()
{
    vector&ltvector&ltint&gt&gt; graph = {
        {0, 1, 1, 1},
        {1, 0, 1, 0},
        {1, 1, 0, 1},
        {1, 0, 1, 0}
    };
    int m = 3; // Number of colors
    if (graphColoring(m, graph))
        cout &lt&lt "Solution exists";
    else
        cout &lt&lt "Solution doesn't exist";
    cout &lt&lt endl;
    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(K^V * (V + E)), where V is the number of vertices, E is the number of edges, and K is the number of colors.  The K^V comes from trying every possible color combination. The (V+E) is for checking if current coloring is safe (adjecency check). | <b>Space Complexity:</b> O(V), for storing the color assignments of each vertex.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Backtracking with Optimization</h5>
  <p>This optimized approach uses backtracking, similar to brute force, but it prunes the search space by immediately returning from a recursive call when a partial coloring violates the constraints. The key idea is to try each color for a vertex and recursively check if it leads to a valid coloring. If not, it backtracks to try another color. The optimization involves checking the color validity (isSafe function) before making a recursive call and using the minimum number of colors.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

// Function to check if the current coloring is safe
bool isSafe(int v, int color[], vector&ltvector&ltint&gt&gt;&amp; graph, int c)
{
    for (int i = 0; i &lt graph.size(); i++)
        if (graph[v][i] &amp;&amp; c == color[i])
            return false;
    return true;
}

// Recursive function to solve the graph coloring problem using backtracking
bool graphColoringUtil(int m, int v, int color[], vector&ltvector&ltint&gt&gt;&amp; graph)
{
    if (v == graph.size())
        return true;

    for (int c = 1; c &lt= m; c++)
    {
        if (isSafe(v, color, graph, c))
        {
            color[v] = c;

            if (graphColoringUtil(m, v + 1, color, graph))
                return true;

            // If assigning color c doesn't lead to a solution, backtrack
            color[v] = 0; // Backtrack
        }
    }
    return false;
}

// Function to solve the graph coloring problem using backtracking
bool graphColoring(int m, vector&ltvector&ltint&gt&gt;&amp; graph)
{
    int *color = new int[graph.size()];
    for (int i = 0; i &lt graph.size(); i++)
        color[i] = 0;

    if (!graphColoringUtil(m, 0, color, graph))
    {
        delete[] color;
        return false;
    }
    delete[] color;
    return true;
}

// Main function to test the code
int main()
{
    vector&ltvector&ltint&gt&gt; graph = {
        {0, 1, 1, 1},
        {1, 0, 1, 0},
        {1, 1, 0, 1},
        {1, 0, 1, 0}
    };
    int m = 3; // Number of colors
    if (graphColoring(m, graph))
        cout &lt&lt "Solution exists";
    else
        cout &lt&lt "Solution doesn't exist";
    cout &lt&lt endl;
    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> In the worst case, it's still exponential, but pruning reduces the average time. O(M^V) in the worst case where V is the number of vertices and M is the number of colors. In practice, it's often much faster due to backtracking. | <b>Space Complexity:</b> O(V), for the color array and recursion call stack.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">Graph represented by adjacency matrix:
0 1 1 1
1 0 1 0
1 1 0 1
1 0 1 0
Number of colors (m) = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Solution exists</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The graph can be colored with 3 colors.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">Graph represented by adjacency matrix:
0 1 1 1
1 0 1 0
1 1 0 1
1 0 1 0
Number of colors (m) = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Solution doesn't exist</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The graph cannot be colored with only 2 colors.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">Graph represented by adjacency matrix:
0 1 0 0
1 0 1 0
0 1 0 1
0 0 1 0
Number of colors (m) = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Solution exists</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The graph can be colored with 2 colors.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The graph can be represented using an adjacency matrix or an adjacency list.
2.  If a solution exists for 'm' colors, it will also exist for any m' > m.
3.  Chromatic number is the minimum number of colors required to color a graph.
4.  NP-complete problem. No known polynomial-time solution exists for the general case.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/>Most Stones Removed with Same Row or Column</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an array of stones where stones[i] = [xi, yi] represent the location of the ith stone.  Remove a stone if it shares either the same row or the same column as another stone. Return the maximum number of stones that can be removed.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all pairs of stones and check if they share a row or column.  If they do, and haven't already been removed, remove one. Repeat this until no more stones can be removed. This approach is inefficient due to repeated checks and removals.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int removeStones_brute(vector&lt;vector&lt;int&gt;&gt;& stones) {
    int n = stones.size();
    vector&lt;bool&gt; removed(n, false);
    int removed_count = 0;

    for (int i = 0; i &lt; n; ++i) {
        if (removed[i]) continue;
        for (int j = i + 1; j &lt; n; ++j) {
            if (removed[j]) continue;
            if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {
                removed[j] = true; // Remove stone j
                removed_count++;
                break; // Optimization: only remove one stone at a time per stone i
            }
        }
    }
    return removed_count;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N^3) in the worst case, due to repeated iterations in the nested loops. In the worst case, we might have to iterate multiple times through pairs of stones. | <b>Space Complexity:</b> O(N) due to the `removed` vector</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Union-Find (Disjoint Set)</h5>
  <p>Use the Union-Find (Disjoint Set) data structure to efficiently determine connected components.  Each stone can be viewed as a node in a graph.  If two stones share the same row or column, they are connected.  The number of stones that can be removed is the total number of stones minus the number of connected components (number of islands).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class UnionFind {
public:
    UnionFind(int n) : parent(n), rank(n, 0) {
        for (int i = 0; i &lt; n; ++i) {
            parent[i] = i;
        }
    }

    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // Path compression
        }
        return parent[x];
    }

    void unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            if (rank[rootX] &lt rank[rootY]) {
                parent[rootX] = rootY;
            } else if (rank[rootX] &gt rank[rootY]) {
                parent[rootY] = rootX;
            } else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
        }
    }

private:
    vector&lt;int&gt; parent;
    vector&lt;int&gt; rank;
};

int removeStones(vector&lt;vector&lt;int&gt;&gt;& stones) {
    int n = stones.size();
    UnionFind uf(n);

    for (int i = 0; i &lt; n; ++i) {
        for (int j = i + 1; j &lt; n; ++j) {
            if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {
                uf.unite(i, j);
            }
        }
    }

    int components = 0;
    vector&lt;bool&gt; visited(n, false);
    for (int i = 0; i &lt; n; ++i) {
        int root = uf.find(i);
        if (!visited[root]) {
            components++;
            visited[root] = true;
        }
    }

    return n - components;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N^2 * Œ±(N)), where N is the number of stones, and Œ±(N) is the inverse Ackermann function, which grows very slowly and can be considered almost constant.  The dominant part is the nested loop for comparing stone pairs, leading to O(N^2).  Union-find operations are close to O(1) due to path compression and union by rank. | <b>Space Complexity:</b> O(N) to store the Union-Find data structure (parent and rank arrays).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0,0],[0,1],[1,0],[1,2],[2,2]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">We can remove the stones at [0,1], [1,0], and [1,2].  The stones at [0,0] and [2,2] remain.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0,0],[0,2],[1,1],[2,0],[2,2]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">We can remove the stones at [0,2], [2,0], and [2,2].  The stones at [0,0] and [1,1] remain.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0,0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There is only one stone, so we cannot remove it.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. The Union-Find approach is more efficient because it avoids redundant checks by grouping connected stones into sets.
2. The crucial insight is to realize that the problem can be rephrased as finding connected components.
3. Path compression and union by rank are key optimizations for the Union-Find data structure to reduce its time complexity. 
4. An alternative approach could involve building a graph and then performing Depth-First Search (DFS) or Breadth-First Search (BFS) to find connected components. However, the Union-Find solution provides more efficient complexity for this case.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/as-far-from-land-as-possible/>As Far from Land as Possible</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an &lt;code&gt;n x n&lt;/code&gt; grid where each cell is either land (represented by &lt;code&gt;1&lt;/code&gt;) or water (represented by &lt;code&gt;0&lt;/code&gt;), find the maximum distance from a water cell to the nearest land cell.  The distance between two cells is the Manhattan distance: &lt;code&gt;|row1 - row2| + |col1 - col2|&lt;/code&gt;.  If there is no land or no water, return &lt;code&gt;-1&lt;/code&gt;.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through every water cell. For each water cell, iterate through all land cells and calculate the Manhattan distance.  Find the minimum distance from the water cell to any land cell. Finally, find the maximum of these minimum distances across all water cells.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;
#include &lt;algorithm&gt;

using namespace std;

int maxDistanceBruteForce(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
    int n = grid.size();
    bool hasLand = false, hasWater = false;

    for (int i = 0; i &lt; n; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            if (grid[i][j] == 1) {
                hasLand = true;
            } else {
                hasWater = true;
            }
        }
    }

    if (!hasLand || !hasWater) {
        return -1;
    }

    int maxDist = -1;

    for (int r = 0; r &lt; n; ++r) {
        for (int c = 0; c &lt; n; ++c) {
            if (grid[r][c] == 0) {
                int minDist = INT_MAX;
                for (int r2 = 0; r2 &lt; n; ++r2) {
                    for (int c2 = 0; c2 &lt; n; ++c2) {
                        if (grid[r2][c2] == 1) {
                            minDist = min(minDist, abs(r - r2) + abs(c - c2));
                        }
                    }
                }
                maxDist = max(maxDist, minDist);
            }
        }
    }

    return maxDist;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^4) - where n is the size of the grid.  Nested loops for water cells, then nested loops for land cells within each water cell. | <b>Space Complexity:</b> O(1) - constant extra space</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Breadth-First Search (BFS)</h5>
  <p>Use BFS to expand from land cells.  Each level in the BFS represents a distance from land. The maximum distance will be the last level explored. Start BFS from all land cells simultaneously. Use a queue to store cells to visit. Mark visited cells. The maximum distance is obtained by the largest level visited.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;climits&gt;
#include &lt;algorithm&gt;

using namespace std;

int maxDistanceBFS(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
    int n = grid.size();
    queue&lt;pair&lt;int, int&gt;&gt; q;
    vector&lt;vector&lt;int&gt;&gt; dist(n, vector&lt;int&gt;(n, -1));
    int landCount = 0;

    for (int i = 0; i &lt; n; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            if (grid[i][j] == 1) {
                q.push({i, j});
                dist[i][j] = 0;
                landCount++;
            }
        }
    }

    if (landCount == 0 || landCount == n * n) {
        return -1;
    }

    int maxDist = -1;
    int dx[] = {0, 0, 1, -1};
    int dy[] = {1, -1, 0, 0};

    while (!q.empty()) {
        pair&lt;int, int&gt; curr = q.front();
        q.pop();
        int r = curr.first;
        int c = curr.second;

        for (int i = 0; i &lt; 4; ++i) {
            int nr = r + dx[i];
            int nc = c + dy[i];

            if (nr &gt;= 0 &amp;&amp; nr &lt; n &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; n &amp;&amp; dist[nr][nc] == -1) {
                dist[nr][nc] = dist[r][c] + 1;
                q.push({nr, nc});
                maxDist = max(maxDist, dist[nr][nc]);
            }
        }
    }

    return maxDist;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) - where n is the size of the grid.  Each cell is visited at most once. | <b>Space Complexity:</b> O(n^2) - in the worst-case, the queue and the distance matrix can store all the cells</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,0,1],[0,0,0],[1,0,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The water cell at (1, 1) is 2 units away from the nearest land cell.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,0,0],[0,0,0],[0,0,0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The water cell at (2, 2) is 4 units away from the land cell.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0,0,0],[0,0,0],[0,0,0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No land cell is present</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,1,1],[1,1,1],[1,1,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No water cell is present</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The BFS approach is significantly more efficient than the brute-force approach. The edge cases to consider are when the grid contains only land or only water, or no land or water cells at all. The Manhattan distance is the key distance metric here.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/>Find the City With the Smallest Number of Neighbors at a Threshold Distance</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a graph with n cities and an array of edges where edges[i] = [ui, vi, weight_i] represents a bidirectional edge between city ui and city vi with weight weight_i.  Also given a threshold distance.  The task is to find the city with the smallest number of reachable cities within the given threshold distance. Return the city with the smallest city number if there are ties.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves calculating the shortest distances between all pairs of cities using an algorithm like Floyd-Warshall.  Then, for each city, count the number of cities within the threshold distance.  Finally, return the city with the smallest count.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

int findTheCity(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int distanceThreshold) {
    vector&lt;vector&lt;int&gt;&gt; dist(n, vector&lt;int&gt;(n, INT_MAX));

    // Initialize distances
    for (int i = 0; i &lt; n; ++i) {
        dist[i][i] = 0;
    }

    for (const auto&amp; edge : edges) {
        int u = edge[0];
        int v = edge[1];
        int weight = edge[2];
        dist[u][v] = weight;
        dist[v][u] = weight;
    }

    // Floyd-Warshall
    for (int k = 0; k &lt; n; ++k) {
        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (dist[i][k] != INT_MAX &amp;&amp; dist[k][j] != INT_MAX &amp;&amp; dist[i][k] + dist[k][j] &lt; dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }

    int minReachableCities = n + 1; // Initialize with a value greater than the maximum possible reachable cities
    int city = -1;

    for (int i = 0; i &lt; n; ++i) {
        int reachableCities = 0;
        for (int j = 0; j &lt; n; ++j) {
            if (i != j &amp;&amp; dist[i][j] &lt;= distanceThreshold) {
                reachableCities++;
            }
        }

        if (reachableCities &lt;= minReachableCities) {
            minReachableCities = reachableCities;
            city = i;
        }
    }

    return city;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^3 + E) where n is the number of cities and E is the number of edges. Floyd-Warshall is O(n^3), and initializing edges can be done in O(E). The final nested loop is also O(n^2). | <b>Space Complexity:</b> O(n^2) for the distance matrix.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Floyd-Warshall with Optimization</h5>
  <p>Use Floyd-Warshall algorithm to calculate all-pairs shortest paths. After calculating shortest paths, iterate through each city and count the number of reachable cities within the distance threshold. Return the city with the smallest number of reachable cities.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

int findTheCity(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int distanceThreshold) {
    vector&lt;vector&lt;int&gt;&gt; dist(n, vector&lt;int&gt;(n, INT_MAX));

    for (int i = 0; i &lt; n; ++i) {
        dist[i][i] = 0;
    }

    for (const auto&amp; edge : edges) {
        dist[edge[0]][edge[1]] = edge[2];
        dist[edge[1]][edge[0]] = edge[2];
    }

    for (int k = 0; k &lt; n; ++k) {
        for (int i = 0; i &lt; n; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (dist[i][k] != INT_MAX &amp;&amp; dist[k][j] != INT_MAX &amp;&amp; dist[i][k] + dist[k][j] &lt; dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }

    int minReachableCities = n;
    int city = -1;
    for (int i = 0; i &lt; n; ++i) {
        int reachableCities = 0;
        for (int j = 0; j &lt; n; ++j) {
            if (dist[i][j] &lt;= distanceThreshold) {
                reachableCities++;
            }
        }
        if (reachableCities &lt;= minReachableCities) {
            minReachableCities = reachableCities;
            city = i;
        }
    }
    return city;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^3) due to Floyd-Warshall. Initialization and counting reachable cities are O(E) and O(n^2) respectively, but they are dominated by O(n^3) | <b>Space Complexity:</b> O(n^2) for the distance matrix.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">City 0 has 3 neighbors: 1, 2, and 3.
City 1 has 3 neighbors: 0, 2, and 3.
City 2 has 2 neighbors: 1 and 3.
City 3 has 2 neighbors: 1 and 2.
So city 2 and 3 have the smallest number of neighbors which is 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">City 0 has 1 neighbor.
City 1 has 3 neighbors.
City 2 has 4 neighbors.
City 3 has 4 neighbors.
City 4 has 4 neighbors.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key is to efficiently calculate all-pairs shortest paths. Floyd-Warshall is suitable for this. Consider the edge case where there are no edges or the graph is disconnected. In the case of ties, return the city with the smallest index. The initialization of the distance matrix must handle cases with self-loops (distance to itself is 0) and disconnected nodes (distance is infinity). DistanceThreshold can be any non-negative value.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/find-whether-it-is-possible-to-finish-all-tasks-or-not-from-given-dependencies/>Find whether it is possible to finish all tasks or not from given dependencies</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a set of tasks and their dependencies, determine if it's possible to complete all tasks. Dependencies are represented as pairs (u, v), meaning task 'u' must be completed before task 'v'. If a cycle exists in the dependency graph, it's not possible to complete all tasks.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves checking all possible task orderings. For each ordering, verify if it satisfies all dependencies. This is highly inefficient.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) {
    vector&lt;int&gt; indegree(numCourses, 0);
    vector&lt;vector&lt;int&gt;&gt; adj(numCourses);
    for (auto&amp; pre : prerequisites) {
        adj[pre[1]].push_back(pre[0]);
        indegree[pre[0]]++;
    }
    queue&lt;int&gt; q;
    for (int i = 0; i &lt; numCourses; i++) {
        if (indegree[i] == 0) {
            q.push(i);
        }
    }
    int count = 0;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        count++;
        for (int v : adj[u]) {
            indegree[v]--;
            if (indegree[v] == 0) {
                q.push(v);
            }
        }
    }
    return count == numCourses;
}

// This brute-force approach is not practically viable for larger inputs. It explores all permutations.
// The provided code is a more efficient optimized solution that utilizes topological sort.

</code></pre>
  <p><b>Time Complexity:</b> O(n! * m), where n is the number of tasks and m is the number of dependencies.  This accounts for generating all permutations and checking dependencies for each. | <b>Space Complexity:</b> O(n + m), primarily due to storing the graph's adjacency list and potentially intermediate data structures during permutation generation.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Topological Sort (Kahn's Algorithm)</h5>
  <p>The optimized approach utilizes topological sorting.  Represent the dependencies as a directed graph. Calculate the in-degree (number of incoming edges) for each task. Use a queue to store tasks with an in-degree of 0 (tasks with no dependencies).  Iteratively process the queue: dequeue a task, decrement the in-degree of its dependent tasks. If a dependent task's in-degree becomes 0, enqueue it. If, after processing, the number of completed tasks equals the total number of tasks, then all tasks can be completed; otherwise, a cycle exists.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) {
    vector&lt;int&gt; indegree(numCourses, 0);
    vector&lt;vector&lt;int&gt;&gt; adj(numCourses);
    for (auto&amp; pre : prerequisites) {
        adj[pre[1]].push_back(pre[0]);
        indegree[pre[0]]++;
    }
    queue&lt;int&gt; q;
    for (int i = 0; i &lt; numCourses; i++) {
        if (indegree[i] == 0) {
            q.push(i);
        }
    }
    int count = 0;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        count++;
        for (int v : adj[u]) {
            indegree[v]--;
            if (indegree[v] == 0) {
                q.push(v);
            }
        }
    }
    return count == numCourses;
}
</code></pre>
  <p><b>Time Complexity:</b> O(V + E), where V is the number of vertices (tasks) and E is the number of edges (dependencies). | <b>Space Complexity:</b> O(V + E), primarily due to storing the adjacency list and the in-degree array.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">numCourses = 2, prerequisites = [[1,0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There are 2 courses, and course 1 depends on course 0. This is possible.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">numCourses = 2, prerequisites = [[1,0],[0,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There are 2 courses, and course 1 depends on course 0, and course 0 depends on course 1. This is a cycle, so it's not possible.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">numCourses = 3, prerequisites = [[0,1],[0,2],[1,2]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Course 2 depends on 0 and 1, 1 depends on 0. Possible.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">numCourses = 3, prerequisites = [[0,1],[1,2],[2,0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Cycle is present, so it is not possible to finish all tasks</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The core concept here is cycle detection in a directed graph. Topological sort is an efficient way to detect cycles.  If a topological sort is possible (i.e., all nodes are visited), no cycles exist.  Edge cases include empty dependency lists, and self-dependencies. Also, ensure that the course numbers are within valid range (0 to numCourses - 1).</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/>Prim's Minimum Spanning Tree (MST)</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a weighted, undirected graph, find the Minimum Spanning Tree (MST). An MST is a subset of the edges of the graph that connects all the vertices together, with the minimum total edge weight. Prim's algorithm is a greedy algorithm that finds the MST.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach would involve generating all possible spanning trees and calculating their total weights. Then, selecting the tree with the minimum weight. This is highly inefficient.</p>
  <pre><code class="language-python">// This approach is not practical due to its exponential time complexity and is thus not implemented.
// It involves generating all possible spanning trees, computing their weights, and selecting the one with the minimum weight.</code></pre>
  <p><b>Time Complexity:</b> O(V^(V-2)) where V is the number of vertices. This is because the number of possible spanning trees grows exponentially. | <b>Space Complexity:</b> O(V+E), where V is the number of vertices and E is the number of edges. This is required to store the graph's edges and vertices, and the spanning trees generated.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Prim's Algorithm (using adjacency list and priority queue)</h5>
  <p>1.  Initialize an MST set (mstSet) to keep track of vertices already included in MST.
2.  Initialize a key array (key[]) to store the minimum weight of edges connecting vertices to the MST. Initially, all keys are set to infinity, except for the starting vertex, which is 0.
3.  Initialize a parent array (parent[]) to store the parent of each vertex in the MST.  
4.  Iterate V times (where V is the number of vertices):
    a.  Find the vertex with the minimum key value that is not yet included in MST (using a min-priority queue for efficiency).
    b.  Add this vertex to mstSet.
    c.  For all adjacent vertices of the selected vertex:
        -   If the edge weight is less than the current key value of the adjacent vertex and the adjacent vertex is not yet in MST, update the key value and set the parent of the adjacent vertex to the selected vertex.
5.  The parent array will contain the MST, allowing us to calculate the total weight or perform other operations.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

// Structure to represent an edge in the graph
struct Edge {
    int to;
    int weight;
};

int primMST(int V, vector&lt;vector&lt;Edge&gt;&gt;& adj) {
    // key values used to pick minimum weight edge in cut
    vector&lt;int&gt; key(V, INT_MAX);
    // To represent set of vertices not yet included in MST
    vector&lt;bool&gt; mstSet(V, false);
    // Parent array to store constructed MST
    vector&lt;int&gt; parent(V, -1);

    // Start with the first vertex
    key[0] = 0;

    for (int count = 0; count &lt V - 1; count++) {
        int u = -1;  // Initialize with an invalid value
        // Find the vertex with the minimum key value that is not yet in mstSet.
        for (int v = 0; v &lt V; v++) {
            if (!mstSet[v] &amp;&amp; (u == -1 || key[v] &lt key[u])) {
                u = v;
            }
        }

        // Add the picked vertex to the MST set
        mstSet[u] = true;

        // Update key value and parent of the adjacent vertices of the picked vertex.
        for (const Edge& edge : adj[u]) {
            int v = edge.to;
            int weight = edge.weight;
            if (!mstSet[v] &amp;&amp; weight &lt key[v]) {
                parent[v] = u;
                key[v] = weight;
            }
        }
    }

    // Calculate the total weight of the MST
    int mstWeight = 0;
    for (int i = 0; i &lt V; i++) {
        if (parent[i] != -1) {
            for(const Edge& edge: adj[i]) {
                if(edge.to == parent[i]) {
                    mstWeight += edge.weight;
                    break;
                }
            }
        }
    }
    return mstWeight;
}


// Function to add edge to the graph (undirected)
void addEdge(vector&lt;vector&lt;Edge&gt;&gt;& adj, int u, int v, int weight) {
    adj[u].push_back({v, weight});
    adj[v].push_back({u, weight});
}

int main() {
    int V = 5; // Number of vertices
    vector&lt;vector&lt;Edge&gt;&gt; adj(V);

    // Example graph (as given in the problem)
    addEdge(adj, 0, 1, 2);
    addEdge(adj, 0, 3, 6);
    addEdge(adj, 1, 2, 3);
    addEdge(adj, 1, 3, 8);
    addEdge(adj, 1, 4, 5);
    addEdge(adj, 2, 4, 7);
    addEdge(adj, 3, 4, 9);

    int mstWeight = primMST(V, adj);
    cout &lt&lt "Weight of MST: " &lt&lt mstWeight &lt&lt endl;

    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(V^2 + E) where V is the number of vertices and E is the number of edges. The outer loop runs V times.  Finding the minimum key value vertex takes O(V) in each iteration. Updating the key values takes O(E) in total.  The overall complexity is dominated by the V^2 for finding the minimum. | <b>Space Complexity:</b> O(V + E) where V is the number of vertices and E is the number of edges.  We use auxiliary arrays key[], mstSet[], and parent[] each of size V. Also, we store the graph itself in adjacency list which takes O(E) space.</p>
  <h5>‚û§ Prim's Algorithm (using adjacency list and priority queue - optimized)</h5>
  <p>This approach uses a min-priority queue (e.g., a min-heap) to efficiently find the vertex with the minimum key value in each iteration.  The steps are similar to the previous approach but with a priority queue to speed up the finding of the minimum key.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

// Structure to represent an edge in the graph
struct Edge {
    int to;
    int weight;
};

int primMSTOptimized(int V, vector&lt;vector&lt;Edge&gt;&gt;& adj) {
    // key values used to pick minimum weight edge in cut
    vector&lt;int&gt; key(V, INT_MAX);
    // To represent set of vertices not yet included in MST
    vector&lt;bool&gt; mstSet(V, false);
    // Parent array to store constructed MST
    vector&lt;int&gt; parent(V, -1);

    // Min-priority queue: {weight, vertex}
    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;

    // Start with the first vertex
    key[0] = 0;
    pq.push({0, 0}); // {weight, vertex}

    for (int count = 0; count &lt V; count++) {
        // Find the vertex with the minimum key value that is not yet in mstSet.
        int u = -1;
        while (!pq.empty()) {
            int v = pq.top().second;
            pq.pop();
            if (!mstSet[v]) {
                u = v;
                break;
            }
        }

        if (u == -1) break; // handle disconnected graphs

        // Add the picked vertex to the MST set
        mstSet[u] = true;

        // Update key value and parent of the adjacent vertices of the picked vertex.
        for (const Edge& edge : adj[u]) {
            int v = edge.to;
            int weight = edge.weight;
            if (!mstSet[v] &amp;&amp; weight &lt key[v]) {
                parent[v] = u;
                key[v] = weight;
                pq.push({key[v], v});
            }
        }
    }

    // Calculate the total weight of the MST
    int mstWeight = 0;
    for (int i = 0; i &lt V; i++) {
        if (parent[i] != -1) {
            for(const Edge& edge: adj[i]) {
                if(edge.to == parent[i]) {
                    mstWeight += edge.weight;
                    break;
                }
            }
        }
    }
    return mstWeight;
}


// Function to add edge to the graph (undirected)
void addEdge(vector&lt;vector&lt;Edge&gt;&gt;& adj, int u, int v, int weight) {
    adj[u].push_back({v, weight});
    adj[v].push_back({u, weight});
}

int main() {
    int V = 5; // Number of vertices
    vector&lt;vector&lt;Edge&gt;&gt; adj(V);

    // Example graph (as given in the problem)
    addEdge(adj, 0, 1, 2);
    addEdge(adj, 0, 3, 6);
    addEdge(adj, 1, 2, 3);
    addEdge(adj, 1, 3, 8);
    addEdge(adj, 1, 4, 5);
    addEdge(adj, 2, 4, 7);
    addEdge(adj, 3, 4, 9);

    int mstWeight = primMSTOptimized(V, adj);
    cout &lt&lt "Weight of MST: " &lt&lt mstWeight &lt&lt endl;

    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(E log V) where V is the number of vertices and E is the number of edges.  Using a priority queue, finding the minimum element takes O(log V) time, and this happens at most E times. Initialization and other operations are performed in O(V + E). | <b>Space Complexity:</b> O(V + E) where V is the number of vertices and E is the number of edges. Primarily due to the adjacency list representation of the graph and the priority queue. The priority queue can hold, at most, E elements (in the worst case, all edges could be candidates for the MST). Auxiliary arrays like key[], mstSet[] and parent[] take O(V) space each.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">V = 5, Edges: [(0, 1, 2), (0, 3, 6), (1, 2, 3), (1, 3, 8), (1, 4, 5), (2, 4, 7), (3, 4, 9)]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Weight of MST: 16</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The edges (0, 1, 2), (1, 2, 3), (1, 4, 5), and (0, 3, 6) form the MST with a total weight of 2 + 3 + 5 + 6 = 16.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">V = 4, Edges: [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Weight of MST: 19</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The edges (0, 3, 5), (2, 3, 4), (0, 2, 6) form the MST with a total weight of 5 + 4 + 10 = 19.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  **Disconnected Graphs:** If the graph is disconnected, Prim's algorithm, as implemented, will only find the MST of the connected component containing the starting vertex. To find the MST of a disconnected graph, the algorithm needs to be run multiple times, once for each connected component.
2.  **Negative Edge Weights:** Prim's algorithm works correctly with negative edge weights.
3.  **Efficiency:** The optimized version using a priority queue significantly improves the time complexity, especially for sparse graphs.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/implementing-floyd-warshall2042/1>Implementing Floyd Warshall</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a graph represented as an adjacency matrix where matrix[i][j] represents the weight of the edge from node i to node j. If there is no edge between node i and node j, matrix[i][j] will be INF (a large value, typically representing infinity). Implement the Floyd-Warshall algorithm to find the shortest distances between all pairs of vertices in the graph. The diagonal elements (matrix[i][i]) should be 0.

The Floyd-Warshall algorithm considers all possible intermediate vertices for each pair of vertices. For each vertex k, it checks if using vertex k as an intermediate vertex results in a shorter path between vertices i and j.  If so, it updates the distance matrix.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach would involve exploring all possible paths between every pair of nodes.  However, this is essentially what Floyd-Warshall does.  There isn't a significantly worse brute-force method in this case. The key idea is checking all possible paths, where we iterate through all possible intermediate nodes `k`. The core of the Floyd-Warshall algorithm is based on the principle of dynamic programming, building solutions from smaller subproblems to find the shortest paths.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

void floydWarshall(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
    int n = matrix.size();

    // Iterate through all possible intermediate nodes
    for (int k = 0; k &lt; n; ++k) {
        // Iterate through all possible source nodes
        for (int i = 0; i &lt; n; ++i) {
            // Iterate through all possible destination nodes
            for (int j = 0; j &lt; n; ++j) {
                // If vertex k is on the shortest path from i to j, update the distance
                if (matrix[i][k] != 1e9 &amp;&amp; matrix[k][j] != 1e9 &amp;&amp; matrix[i][k] + matrix[k][j] &lt; matrix[i][j]) {
                    matrix[i][j] = matrix[i][k] + matrix[k][j];
                }
            }
        }
    }

    // Handle negative cycles: If matrix[i][i] &lt; 0, there's a negative cycle
    for (int i = 0; i &lt; n; ++i) {
        if (matrix[i][i] &lt; 0) {
            cout &lt;&lt; "Negative Cycle Found" &lt;&lt; endl;
            return; // Or handle it as per the problem requirements
        }
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(V^3), where V is the number of vertices.  The algorithm has three nested loops. | <b>Space Complexity:</b> O(1). The algorithm modifies the input matrix in-place, using constant extra space.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Floyd-Warshall Algorithm</h5>
  <p>The Floyd-Warshall algorithm is a dynamic programming algorithm that solves the all-pairs shortest path problem. It systematically considers all possible intermediate vertices and updates the distance matrix accordingly. The algorithm is quite straightforward to implement once the core logic is understood.</p>
  <pre><code class="language-python">#include &lt;bits/stdc++.h&gt;
using namespace std;

void floydWarshall(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
    int n = matrix.size();

    // Iterate through all possible intermediate nodes
    for (int k = 0; k &lt; n; ++k) {
        // Iterate through all possible source nodes
        for (int i = 0; i &lt; n; ++i) {
            // Iterate through all possible destination nodes
            for (int j = 0; j &lt; n; ++j) {
                // If vertex k is on the shortest path from i to j, update the distance
                if (matrix[i][k] != 1e9 &amp;&amp; matrix[k][j] != 1e9 &amp;&amp; matrix[i][k] + matrix[k][j] &lt; matrix[i][j]) {
                    matrix[i][j] = matrix[i][k] + matrix[k][j];
                }
            }
        }
    }

    // Handle negative cycles: If matrix[i][i] &lt; 0, there's a negative cycle
    for (int i = 0; i &lt; n; ++i) {
        if (matrix[i][i] &lt; 0) {
            //  cout &lt;&lt; "Negative Cycle Found" &lt;&lt; endl; //Problem did not mention what to do in case of negative cycle.
            for(int x = 0; x &lt; n; x++) {
                for(int y = 0; y &lt; n; y++) {
                    matrix[x][y] = -1; // Mark all distances as -1 in case of a negative cycle.
                }
            }
        return; 
        }
    }

}
</code></pre>
  <p><b>Time Complexity:</b> O(V^3), where V is the number of vertices. | <b>Space Complexity:</b> O(1). The algorithm modifies the input matrix in-place.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0, 1, 43], [1, 0, 6], [1, 6, 0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0, 1, 43], [1, 0, 6], [1, 6, 0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The input is a 3x3 matrix, representing a graph with 3 nodes. The matrix initially represents direct edge weights.  The Floyd-Warshall algorithm will update the matrix to reflect the shortest paths between all pairs of nodes. Since the nodes are very small and the edges provided, Floyd-Warshall algorithm does not make significant changes in this graph.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0, 1, 4], [1, 0, 2], [4, 2, 0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0, 1, 3], [1, 0, 2], [3, 2, 0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Illustrates a case where the algorithm finds shorter paths. Initially, the path from node 0 to node 2 has a weight of 4. However, using node 1 as an intermediate node provides a path from 0 to 1 (weight 1) and from 1 to 2 (weight 2), thus creating a path from 0 to 2 with weight 3. Similarly, node 2 to node 0 is updated.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Shows a complete graph where Floyd-Warshall doesn't update anything because there is already a direct edge between every pair of nodes, and all edge weights are 1 (except for self loops which are 0). The algorithm finds the shortest paths. Since the input is a complete graph, it will not modify the values. This test case helps to understand how FW will behave in such cases.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The problem specifically mentions that matrix[i][i] should be 0, representing the distance from a node to itself.
2.  The matrix initially uses INF to represent the absence of a direct edge. The choice of INF is crucial; it must be a value that is greater than any possible path weight, but avoids overflow when adding edge weights together.
3.  A common way to detect negative cycles is to check if matrix[i][i] becomes negative after running the algorithm. If matrix[i][i] is negative, it means there's a negative cycle reachable from node i. The code now accounts for negative cycles.  The prompt does not tell what to do when negative cycles exist but I am handling the same.
4. Floyd-Warshall works well for dense graphs where the number of edges is close to the maximum possible (V^2). For sparse graphs, other algorithms, such as Dijkstra's, may be more efficient.  However, Floyd-Warshall is simpler to implement for the all-pairs shortest paths problem.
5. The algorithm modifies the input matrix directly (in-place), so make a copy if you need to preserve the original graph's structure.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/evaluate-division/>Evaluate Division</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>You are given an array of equations `equations` where `equations[i] = [Ai, Bi]` represents the ratio `Ai / Bi = values[i]` where `Ai` and `Bi` are strings representing variables, and `values[i]` is a real number. You are also given an array of queries `queries` where `queries[j] = [Cj, Dj]` represents a query to calculate the ratio `Cj / Dj`. Return the answers to the queries. If the ratio cannot be calculated, return -1.0.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves iterating through all possible paths between the variables in the equations. For each query, we try to find a path from the numerator variable to the denominator variable using the given equations. If a path exists, we calculate the product of the values along that path. This involves depth-first search (DFS) to explore different paths.</p>
  <pre><code class="language-python">#include &ltiostream&gt
#include &ltvector&gt
#include &ltstring&gt
#include &ltunordered_map&gt

using namespace std;

class Solution {
public:
    double dfs(string start, string end, unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt;& graph, unordered_set&lt;string&gt;& visited) {
        if (visited.count(start))
            return -1.0;
        
        if (!graph.count(start))
            return -1.0;
        
        if (start == end)
            return 1.0;
        
        visited.insert(start);
        
        for (auto& neighbor : graph[start]) {
            double result = dfs(neighbor.first, end, graph, visited);
            if (result != -1.0) {
                return result * neighbor.second;
            }
        }
        
        return -1.0;
    }

    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;& equations, vector&lt;double&gt;& values, vector&lt;vector&lt;string&gt;&gt;& queries) {
        unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt; graph;
        
        for (int i = 0; i &lt equations.size(); i++) {
            string a = equations[i][0];
            string b = equations[i][1];
            double val = values[i];
            graph[a][b] = val;
            graph[b][a] = 1.0 / val;
        }
        
        vector&lt;double&gt; results;
        for (auto& query : queries) {
            string start = query[0];
            string end = query[1];
            unordered_set&lt;string&gt; visited;
            double result = dfs(start, end, graph, visited);
            results.push_back(result);
        }
        
        return results;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(Q * (V + E)) where Q is number of queries, V is number of variables, and E is number of equations.  DFS is performed for each query.  In worst case, it might have to traverse all vertices and edges. | <b>Space Complexity:</b> O(V + E) for the graph and visited set, where V is the number of variables and E is the number of equations.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Graph + DFS (Optimized)</h5>
  <p>Build a graph where nodes are variables and edges represent the division ratios.  Use Depth-First Search (DFS) to traverse the graph to find a path from numerator to denominator. Optimize the DFS process by using a `visited` set to avoid cycles and redundant exploration. The graph can be preprocessed using a HashMap to store the neighbors and the division values. </p>
  <pre><code class="language-python">#include &ltiostream&gt
#include &ltvector&gt
#include &ltstring&gt
#include &ltunordered_map&gt
#include &ltunordered_set&gt

using namespace std;

class Solution {
public:
    double dfs(string start, string end, unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt;& graph, unordered_set&lt;string&gt;& visited) {
        if (!graph.count(start) || visited.count(start)) {
            return -1.0;
        }
        if (start == end) {
            return 1.0;
        }
        
        visited.insert(start);
        
        for (auto& neighbor : graph[start]) {
            double result = dfs(neighbor.first, end, graph, visited);
            if (result != -1.0) {
                return result * neighbor.second;
            }
        }
        
        return -1.0;
    }

    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;& equations, vector&lt;double&gt;& values, vector&lt;vector&lt;string&gt;&gt;& queries) {
        unordered_map&lt;string, unordered_map&lt;string, double&gt;&gt; graph;

        // Build the graph
        for (int i = 0; i &lt equations.size(); ++i) {
            string u = equations[i][0];
            string v = equations[i][1];
            double val = values[i];
            graph[u][v] = val;
            graph[v][u] = 1.0 / val; // Adding inverse for bidirectional graph
        }

        vector&lt;double&gt; results;
        for (const auto& query : queries) {
            string start = query[0];
            string end = query[1];
            unordered_set&lt;string&gt; visited;
            double result = dfs(start, end, graph, visited);
            results.push_back(result);
        }
        
        return results;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(Q * (V + E)).  DFS takes O(V+E) in the worst case for each query.  Building the graph takes O(E) where E is the number of equations. Q is number of queries and V is number of variables. | <b>Space Complexity:</b> O(V + E) to store the graph and visited set. Where V is number of variables and E is the number of edges(equations).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[6.00000,0.50000,-1.00000,1.00000,-1.00000]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Build graph using the given equations, representing each as a node with division values as edge weights. Then perform DFS search for each query.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[3.75000,0.40000,5.00000,0.20000]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Similar to the first example, Build graph then perform DFS.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">equations = [["a","b"]], values = [0.5], queries = [["a","b"],["b","a"],["a","c"],["x","y"]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[0.50000,2.00000,-1.00000,-1.00000]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Demonstrates handling of missing variables and inverse ratios.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The graph can have cycles since the relationship between variables is bidirectional.
2.  The edge weights in the graph must include the inverse of the given values to represent the reciprocal relationship.
3.  Handle cases where a variable is not present in the equations or the path doesn't exist(return -1.0).
4.  Optimize DFS by using visited set to avoid infinite loops.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/snakes-and-ladders/>Snakes and Ladders</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>You are given an n x n integer board.  You are initially at the top-left square (0, 0).  In each move, you can take a die roll of [1, 2, 3, 4, 5, 6], and move that many squares forward.  If you land on a square with a snake or ladder, you must move to the destination of that snake or ladder. Return the least number of moves required to reach the last square (n - 1, n - 1). If you can't reach the last square, return -1.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach would involve exploring all possible paths using Breadth-First Search (BFS).  We simulate each die roll (1 to 6) and, for each roll, explore the possible moves. We keep track of visited squares to avoid cycles and use a queue to manage the exploration. This approach explores all possible move sequences until the destination is reached. This approach would lead to TLE.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

int snakesAndLaddersBruteForce(vector&lt;vector&lt;int&gt;&gt;&amp; board) {
    int n = board.size();
    vector&lt;int&gt; visited(n * n + 1, 0);
    queue&lt;pair&lt;int, int&gt;&gt; q;
    q.push({1, 0}); // {square, moves}
    visited[1] = 1;

    while (!q.empty()) {
        int square = q.front().first;
        int moves = q.front().second;
        q.pop();

        if (square == n * n) {
            return moves;
        }

        for (int i = 1; i &lt;= 6; ++i) {
            int nextSquare = square + i;
            if (nextSquare &lt;= n * n) {
                int row = (nextSquare - 1) / n;
                int col = (nextSquare - 1) % n;
                if (row % 2 == 1) {
                    col = n - 1 - col;
                }
                if (board[row][col] != -1) {
                    nextSquare = board[row][col];
                }

                if (!visited[nextSquare]) {
                    visited[nextSquare] = 1;
                    q.push({nextSquare, moves + 1});
                }
            }
        }
    }

    return -1;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2 * 6^n), where n is the board size. In the worst-case scenario, we might explore all possible paths, which can be exponential due to the die rolls. | <b>Space Complexity:</b> O(n^2) in the worst case due to the visited array and queue to store visited nodes. In the worst case the queue can hold all the nodes, or a large subset of nodes.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ BFS with Optimizations</h5>
  <p>This approach uses Breadth-First Search (BFS) to find the shortest path. We map each square on the board to a linear index (1 to n*n). We use a queue to manage the exploration and a `visited` array to avoid cycles. For each square, we simulate a die roll (1-6) and move to the next square. If the next square has a snake or ladder, we move to the destination of that snake or ladder. The level of the BFS represents the number of moves. This solution reduces redundant computations by efficiently exploring the board and utilizing the linear indexing to navigate, also handles snakes and ladders accurately.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

int snakesAndLaddersOptimized(vector&lt;vector&lt;int&gt;&gt;&amp; board) {
    int n = board.size();
    vector&lt;int&gt; visited(n * n + 1, 0);
    queue&lt;pair&lt;int, int&gt;&gt; q;
    q.push({1, 0}); // {square, moves}
    visited[1] = 1;

    while (!q.empty()) {
        int square = q.front().first;
        int moves = q.front().second;
        q.pop();

        if (square == n * n) {
            return moves;
        }

        for (int i = 1; i &lt;= 6; ++i) {
            int nextSquare = square + i;
            if (nextSquare &lt;= n * n) {
                int row = (nextSquare - 1) / n;
                int col = (nextSquare - 1) % n;
                if (row % 2 == 1) {
                    col = n - 1 - col;
                }
                if (board[row][col] != -1) {
                    nextSquare = board[row][col];
                }

                if (!visited[nextSquare]) {
                    visited[nextSquare] = 1;
                    q.push({nextSquare, moves + 1});
                }
            }
        }
    }

    return -1;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2), where n is the board size. Each cell on the board is visited at most once. | <b>Space Complexity:</b> O(n^2) in the worst case due to the `visited` array and the queue. The queue, in the worst-case scenario, can potentially store all the reachable squares on the board.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The shortest path to the last square is 4 moves.  1 -> 15 -> 15 -> 15 -> 15 (roll 5) -> 15 -> 35 -> 35 -> 35 -> 35(roll 6) -> 40 -> 40 -> 40 -> 40(roll 1) -> 40(roll 1) -> 40(roll 6) -> 46 -> 46 -> 46 -> 46 (roll 5) -> 51 -> 51 -> 51 -> 51 (roll 6) -> 57 -> 57 -> 57 -> 57(roll 5) -> 62(roll 6) -> 62 -> 62 -> 62 (roll 6) -> 68 -> 68 -> 68 -> 68 (roll 2) -> 70(roll 1) -> 70 (roll 1) -> 70 (roll 1) -> 70(roll 3) -> 73(roll 3) -> 76 -> 76 -> 76 -> 76 (roll 1) -> 77(roll 6) -> 83(roll 6) -> 89(roll 2) -> 91 -> 91 -> 91 -> 91 (roll 5) -> 96 -> 96 -> 96 -> 96 (roll 6) -> 102 -> 102 -> 102 -> 102 (roll 2) -> 104 -> 104 -> 104 -> 104(roll 6) -> 110 -> 110 -> 110 -> 110 (roll 1) -> 111(roll 6) -> 117(roll 1) -> 118 -> 118 -> 118 -> 118(roll 1) -> 119(roll 1) -> 120 -> 120 -> 120 -> 120(roll 1) -> 121 (roll 6) -> 127(roll 1) -> 128(roll 1) -> 129 -> 129 -> 129 -> 129(roll 5) -> 134 -> 134 -> 134 -> 134(roll 2) -> 136 -> 136 -> 136 -> 136 (roll 2) -> 138 -> 138 -> 138 -> 138(roll 6) -> 144 -> 144 -> 144 -> 144(roll 6) -> 150 -> 150 -> 150 -> 150(roll 4) -> 154 -> 154 -> 154 -> 154(roll 1) -> 155(roll 6) -> 161 -> 161 -> 161 -> 161(roll 5) -> 166(roll 6) -> 172(roll 6) -> 178(roll 2) -> 180(roll 6) -> 186(roll 2) -> 188(roll 6) -> 194 -> 194 -> 194 -> 194(roll 5) -> 199 -> 199 -> 199 -> 199 (roll 1) -> 200(roll 6) -> 206(roll 5) -> 211(roll 6) -> 217(roll 1) -> 218(roll 6) -> 224 -> 224 -> 224 -> 224 (roll 3) -> 227(roll 6) -> 233(roll 2) -> 235(roll 2) -> 237(roll 1) -> 238(roll 6) -> 244 -> 244 -> 244 -> 244(roll 4) -> 248(roll 6) -> 254(roll 6) -> 260(roll 3) -> 263(roll 2) -> 265(roll 3) -> 268(roll 6) -> 274(roll 6) -> 280(roll 2) -> 282(roll 6) -> 288(roll 4) -> 292(roll 6) -> 298(roll 6) -> 304(roll 3) -> 307(roll 5) -> 312(roll 6) -> 318(roll 6) -> 324(roll 4) -> 328(roll 6) -> 334(roll 6) -> 340(roll 1) -> 341(roll 6) -> 347(roll 2) -> 349(roll 6) -> 355(roll 6) -> 361(roll 2) -> 363(roll 6) -> 369(roll 6) -> 375(roll 6) -> 381(roll 6) -> 387(roll 5) -> 392(roll 6) -> 398(roll 1) -> 399 -> 399 -> 399 (roll 1) -> 400

</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">board = [[-1, -1, -1], [-1, 9, 8], [-1, 8, 9]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Start at square 1, roll 1 to go to square 2. Land at the ladder and go to square 9. Then, roll 1 and go to square 10 which is the end.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">board = [[-1,4,-1],[6,1,6],[-1,3,-1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 -> 2 (ladder to 6) -> 3 -> 9(ladder to 3)</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The board is indexed from 1 to n*n. The board may contain snakes and ladders, represented by positive integers where the number is the destination. The board is traversed in a specific pattern (snake-like). The rows are filled from right to left, then the next row is from left to right. The key to this problem is to use BFS as it can efficiently find the shortest path. Also, it's important to consider the case where a square may not have snakes or ladders.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/topological-sort/1>Topological Sort</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a directed acyclic graph (DAG) with V vertices and E edges, print a topological sort of the graph. Topological sorting is the ordering of vertices such that for every directed edge (u, v), vertex u comes before vertex v in the ordering.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach can involve trying all possible permutations of vertices and checking if each permutation is a valid topological sort. This is highly inefficient.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    // Brute force approach: (Inefficient and not recommended)
    vector&lt;int&gt; topoSort(int V, vector&lt;int&gt; adj[]) {
        vector&lt;int&gt; result;
        vector&lt;int&gt; vertices(V);
        for (int i = 0; i &lt; V; ++i) {
            vertices[i] = i;
        }

        do {
            bool valid = true;
            for (int u = 0; u &lt; V; ++u) {
                for (int v : adj[u]) {
                    int u_index = -1, v_index = -1;
                    for (int i = 0; i &lt; V; ++i) {
                        if (vertices[i] == u) u_index = i;
                        if (vertices[i] == v) v_index = i;
                    }
                    if (u_index &gt; v_index) {
                        valid = false;
                        break;
                    }
                }
                if (!valid) break;
            }
            if (valid) {
                result = vertices;
                break;
            }
        } while (next_permutation(vertices.begin(), vertices.end()));

        return result;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(V! * (V + E)) - factorial due to permutation generation and V + E for checking the validity of the permutation | <b>Space Complexity:</b> O(V) - for storing the permutation</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ DFS-based Topological Sort</h5>
  <p>Perform Depth-First Search (DFS) on the graph. Maintain a visited array and a stack.  When a node is finished processing (all its descendants are visited), push it onto the stack. The stack will contain the topological order in reverse. Then, reverse the stack to get the final topological sort.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    void dfs(int node, vector&lt;int&gt; adj[], vector&lt;bool&gt;& visited, stack&lt;int&gt;& st) {
        visited[node] = true;
        for (int neighbor : adj[node]) {
            if (!visited[neighbor]) {
                dfs(neighbor, adj, visited, st);
            }
        }
        st.push(node);
    }

    vector&lt;int&gt; topoSort(int V, vector&lt;int&gt; adj[]) {
        vector&lt;bool&gt; visited(V, false);
        stack&lt;int&gt; st;
        for (int i = 0; i &lt; V; i++) {
            if (!visited[i]) {
                dfs(i, adj, visited, st);
            }
        }
        vector&lt;int&gt; result;
        while (!st.empty()) {
            result.push_back(st.top());
            st.pop();
        }
        return result;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(V + E) - where V is the number of vertices and E is the number of edges (DFS Traversal) | <b>Space Complexity:</b> O(V) - for the visited array and the stack, in the worst-case scenario when the graph is a linear chain</p>
  <h5>‚û§ Kahn's Algorithm (BFS-based)</h5>
  <p>Use a queue and an in-degree array. Calculate the in-degree of each node (number of incoming edges). Add all nodes with an in-degree of 0 to the queue. While the queue is not empty, dequeue a node, add it to the topological order, and decrement the in-degree of its neighbors. If a neighbor's in-degree becomes 0, enqueue it.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    vector&lt;int&gt; topoSort(int V, vector&lt;int&gt; adj[]) {
        vector&lt;int&gt; inDegree(V, 0);
        for (int i = 0; i &lt; V; i++) {
            for (int neighbor : adj[i]) {
                inDegree[neighbor]++;
            }
        }

        queue&lt;int&gt; q;
        for (int i = 0; i &lt; V; i++) {
            if (inDegree[i] == 0) {
                q.push(i);
            }
        }

        vector&lt;int&gt; result;
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            result.push_back(u);
            for (int v : adj[u]) {
                inDegree[v]--;
                if (inDegree[v] == 0) {
                    q.push(v);
                }
            }
        }
        return result;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(V + E) - where V is the number of vertices and E is the number of edges (BFS Traversal) | <b>Space Complexity:</b> O(V) - for inDegree array and the queue</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">V = 6, edges = [[5, 2], [5, 0], [4, 0], [4, 1], [2, 3], [3, 1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5 4 2 3 1 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">One possible topological sort. Other valid sorts may exist.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">V = 2, edges = [[1, 0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Vertex 1 must come before vertex 0.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  A graph has a topological sort if and only if it is a Directed Acyclic Graph (DAG).
2.  If the graph contains cycles, neither DFS nor Kahn's algorithm will produce a complete topological sort, though they may still process some nodes.  In a real-world scenario, you'd usually want to detect the cycle first.
3.  Multiple valid topological sorts may exist for a given graph.
4.  The provided code assumes the graph is represented using an adjacency list.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/cheapest-flights-within-k-stops/description/>Cheapest Flights Within K Stops</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an undirected graph representing a network of flights, and the source, destination, and a maximum number of stops (K), find the cheapest price to travel from the source to the destination. If there is no path with at most K stops, return -1.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Explore all possible paths from source to destination, keeping track of the cost and the number of stops. Discard paths that exceed K stops. For each path, calculate the total cost and find the minimum cost.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;climits&gt;
#include &lt;bits/stdc++.h&gt;

using namespace std;

// Function to find the cheapest price using brute force (DFS)
int findCheapestPriceBruteForce(int n, vector&lt;vector&lt;int&gt;&gt;& flights, int src, int dst, int k) {
    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj(n);
    for (auto& flight : flights) {
        adj[flight[0]].push_back({flight[1], flight[2]});
    }

    int minCost = INT_MAX;

    function&lt;void(int, int, int)&gt; dfs = [&](int u, int cost, int stops) {
        if (stops &gt; k) {
            return;
        }

        if (u == dst) {
            minCost = min(minCost, cost);
            return;
        }

        for (auto& neighbor : adj[u]) {
            int v = neighbor.first;
            int price = neighbor.second;
            dfs(v, cost + price, stops + 1);
        }
    };

    dfs(src, 0, -1); // Start with -1 stops as we consider stops between flights.
    return minCost == INT_MAX ? -1 : minCost;
}

</code></pre>
  <p><b>Time Complexity:</b> O(V * (E^K)), where V is the number of vertices (cities), E is the number of edges (flights), and K is the maximum number of stops. In the worst-case scenario, we might explore all possible paths up to K stops, which could lead to exponential time complexity. | <b>Space Complexity:</b> O(V + E) due to the adjacency list representation and the recursion stack in worst case.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Bellman-Ford with Limited Stops</h5>
  <p>Apply the Bellman-Ford algorithm with a key modification: limit the number of iterations to K+1. This constraint ensures that we consider paths with at most K stops.  We use a distance array to store the minimum cost from the source to all other nodes, updating it iteratively based on the flight costs. The number of iterations of Bellman Ford are K+1.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;climits&gt;
#include &lt;bits/stdc++.h&gt;

using namespace std;

int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;& flights, int src, int dst, int k) {
    vector&lt;int&gt; dist(n, INT_MAX);
    dist[src] = 0;

    for (int i = 0; i &lt;= k; ++i) {
        vector&lt;int&gt; tempDist = dist;
        for (const auto& flight : flights) {
            int u = flight[0];
            int v = flight[1];
            int w = flight[2];
            if (dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; tempDist[v]) {
                tempDist[v] = dist[u] + w;
            }
        }
        dist = tempDist;
    }

    return dist[dst] == INT_MAX ? -1 : dist[dst];
}
</code></pre>
  <p><b>Time Complexity:</b> O(K * E), where E is the number of flights (edges). The outer loop runs K+1 times and the inner loop iterates through all the flights. | <b>Space Complexity:</b> O(V), where V is the number of cities (vertices). This space is used for the dist array.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">200</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The optimal path is 0 -&gt; 1 -&gt; 2 with a cost of 100 + 100 = 200.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">500</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The optimal path is 0 -&gt; 2 with a cost of 500.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">200</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The optimal path is 0 -&gt; 1 -&gt; 2 with a cost of 100 + 100 = 200.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 4, flights = [[0,1,1],[0,2,5],[1,2,1],[2,3,1]], src = 0, dst = 3, k = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The optimal path is 0 -> 2 -> 3 with a cost of 5 + 1 = 6</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 5, flights = [[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]], src = 0, dst = 2, k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">7</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The optimal path is 0 -> 3 -> 1 -> 2</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The constraint on the number of stops is crucial. It guides the search. 
2.  Bellman-Ford works because it relaxes the edges repeatedly. Each iteration finds the cheapest path using at most one more edge/stop.
3.  Initialization is key. Initialize all distances to infinity, except the source node, which is 0.
4. If we have a graph which contain negative cycles Bellman Ford algorithm doesn't provide optimal solution, but the given problem constraints doesn't include negative weight cycle.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/detect-negative-cycle-graph-bellman-ford/>Detect negative cycle in a graph</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a directed graph with V vertices and E edges, where each edge has a weight, detect if the graph contains a negative cycle. A negative cycle is a cycle in the graph such that the sum of the edge weights in the cycle is negative. If a negative cycle is present, return 1, otherwise return 0.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves checking all possible cycles in the graph and calculating their total weight. If any cycle has a negative weight, then a negative cycle exists. This can be done by generating all possible cycles, which is computationally expensive.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Edge {
    int u, v, weight;
};

int detectNegativeCycleBruteForce(int V, vector&lt;Edge&gt;&amp; edges) {
    // Brute-force approach: Not feasible for larger graphs due to cycle generation.
    // This is just a conceptual outline as the complexity of generating all cycles is too high.
    return 0; // This would require an extremely inefficient cycle detection algorithm.
}
</code></pre>
  <p><b>Time Complexity:</b> O(V * (V+E) * (potentially exponential for cycle generation, making it highly impractical for real graphs)) | <b>Space Complexity:</b> O(1) (ignoring the space required for storing the graph as edges, as the problem provides that)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Bellman-Ford Algorithm</h5>
  <p>The Bellman-Ford algorithm is a single-source shortest path algorithm that can detect negative cycles in a graph. It works by repeatedly relaxing the edges of the graph. If, after V-1 iterations, we can still relax an edge, it means there is a negative cycle.  Relaxing an edge (u, v) means updating the distance to v (dist[v]) if going through u is shorter than the current distance. The algorithm iterates V-1 times to find the shortest paths from the source to all other nodes.  If we can still relax an edge on the Vth iteration, it means there's a negative cycle.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Edge {
    int u, v, weight;
};

int detectNegativeCycle(int V, vector&lt;Edge&gt;&amp; edges) {
    vector&lt;int&gt; dist(V, INT_MAX);
    dist[0] = 0; // Assuming source node is 0.

    // Relax edges V-1 times
    for (int i = 0; i &lt; V - 1; ++i) {
        for (const auto&amp; edge : edges) {
            int u = edge.u;
            int v = edge.v;
            int weight = edge.weight;
            if (dist[u] != INT_MAX &amp;&amp; dist[u] + weight &lt; dist[v]) {
                dist[v] = dist[u] + weight;
            }
        }
    }

    // Check for negative cycles
    for (const auto&amp; edge : edges) {
        int u = edge.u;
        int v = edge.v;
        int weight = edge.weight;
        if (dist[u] != INT_MAX &amp;&amp; dist[u] + weight &lt; dist[v]) {
            return 1; // Negative cycle detected
        }
    }

    return 0; // No negative cycle found
}
</code></pre>
  <p><b>Time Complexity:</b> O(V * E), where V is the number of vertices and E is the number of edges. | <b>Space Complexity:</b> O(V) for the distance array.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">V = 4, edges = {{0, 1, -1}, {0, 2, 4}, {1, 2, 3}, {1, 3, 2}, {3, 2, 5}}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No negative cycle is present. The algorithm will execute and find the shortest paths without any issues.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">V = 3, edges = {{0, 1, -1}, {1, 2, -2}, {2, 0, -3}}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">A negative cycle (0 -> 1 -> 2 -> 0) is present, as the sum of weights is -1 + -2 + -3 = -6. The algorithm will detect this.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">V = 3, edges = {{0, 1, 5}, {1, 2, -3}, {2, 0, -1}}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">A negative cycle (2 -> 0 -> 1 -> 2) is present, as the sum of weights is -1. The algorithm will detect this.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. The Bellman-Ford algorithm works for graphs with negative edge weights, unlike Dijkstra's algorithm. 
2. The algorithm assumes a source node. The problem can be adapted to handle multiple source nodes, but that is not covered in this problem description.
3.  Initialization of the distance array is very important.  Make sure the source node's distance is set to zero and other nodes are at infinity (INT_MAX or a large value that will not cause overflow issues).  Also, it's important to check `dist[u] != INT_MAX` before adding weight to prevent overflows.
4. The check for negative cycles should be done after V-1 iterations of edge relaxation. If, after V-1 iterations, we can still relax an edge, it implies a negative cycle.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/bipartite-graph/>Bipartite Graph</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an undirected graph, determine if it is bipartite. A bipartite graph is a graph whose vertices can be divided into two disjoint sets U and V such that every edge connects a vertex in U to one in V. In other words, there are no edges within the sets U or V.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves trying all possible colorings of the graph. For each vertex, we can either color it with color 0 or color 1. We recursively explore all possible colorings and check if any of them result in a valid bipartite graph.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool isBipartiteUtil(int src, int color[], vector&lt;int&gt; adj[], int c) {
    color[src] = c;
    for (int neighbor : adj[src]) {
        if (color[neighbor] == -1) {
            if (!isBipartiteUtil(neighbor, color, adj, 1 - c))
                return false;
        } else if (color[neighbor] == c)
            return false;
    }
    return true;
}

bool isBipartite(int V, vector&lt;int&gt; adj[]) {
    int color[V];
    for (int i = 0; i &lt; V; i++)
        color[i] = -1;

    for (int i = 0; i &lt; V; i++) {
        if (color[i] == -1) {
            if (!isBipartiteUtil(i, color, adj, 0))
                return false;
        }
    }
    return true;
}

</code></pre>
  <p><b>Time Complexity:</b> O(2^V * (V+E)), where V is the number of vertices and E is the number of edges.  We explore 2^V colorings in worst case, and for each coloring we traverse the graph. | <b>Space Complexity:</b> O(V), for the color array and the recursion stack in the worst case.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ BFS (Breadth-First Search)</h5>
  <p>We can use Breadth-First Search (BFS) to determine if a graph is bipartite. We start with an arbitrary node and color it with color 0. Then, we color all its neighbors with color 1.  We continue this process, coloring the neighbors of the neighbors with alternating colors. If we ever encounter a conflict (a neighbor has the same color as its parent), the graph is not bipartite.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool isBipartiteBFS(int V, vector&lt;int&gt; adj[]) {
    int color[V];
    for (int i = 0; i &lt; V; i++)
        color[i] = -1; // Initialize all vertices with no color

    for (int startNode = 0; startNode &lt; V; startNode++) {
        if (color[startNode] == -1) { // If not yet colored, start BFS
            queue&lt;int&gt; q;
            q.push(startNode);
            color[startNode] = 0; // Assign an initial color

            while (!q.empty()) {
                int u = q.front();
                q.pop();

                for (int v : adj[u]) {
                    if (color[v] == -1) {
                        // If not colored, color with the opposite color of the parent
                        color[v] = 1 - color[u];
                        q.push(v);
                    } else if (color[v] == color[u]) {
                        // If same color, not bipartite
                        return false;
                    }
                }
            }
        }
    }
    return true;
}
</code></pre>
  <p><b>Time Complexity:</b> O(V + E), where V is the number of vertices and E is the number of edges. | <b>Space Complexity:</b> O(V), for the color array and the queue in the worst case.</p>
  <h5>‚û§ DFS (Depth-First Search)</h5>
  <p>We can use Depth-First Search (DFS) to determine if a graph is bipartite. We start with an arbitrary node and color it with color 0.  Then, we recursively color all its neighbors with the opposite color.  During the recursion, if we find a neighbor with the same color, the graph is not bipartite.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool isBipartiteUtilDFS(int u, int color[], vector&lt;int&gt; adj[], int c) {
    color[u] = c;
    for (int v : adj[u]) {
        if (color[v] == -1) {
            if (!isBipartiteUtilDFS(v, color, adj, 1 - c))
                return false;
        } else if (color[v] == c) {
            return false;
        }
    }
    return true;
}

bool isBipartiteDFS(int V, vector&lt;int&gt; adj[]) {
    int color[V];
    for (int i = 0; i &lt; V; i++)
        color[i] = -1;

    for (int i = 0; i &lt; V; i++) {
        if (color[i] == -1) {
            if (!isBipartiteUtilDFS(i, color, adj, 0))
                return false;
        }
    }
    return true;
}
</code></pre>
  <p><b>Time Complexity:</b> O(V + E), where V is the number of vertices and E is the number of edges. | <b>Space Complexity:</b> O(V), for the color array and the recursion stack in the worst case.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">V = 4, E = 4, adj = { {1, 2, 3}, {0, 2}, {0, 1, 3}, {0, 2} }</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Nodes 0 and 3 are connected and nodes 1 and 2 are connected, meaning the graph is not bipartite.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">V = 4, E = 2, adj = { {1}, {0}, {3}, {2} }</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The graph can be colored with color 0 and 1, such that no adjacent node has the same color, therefore it's bipartite.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The graph can be disconnected.
2.  Self-loops on nodes automatically mean the graph is not bipartite.
3. The provided adjacency list format is assumed.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/longest-increasing-path-in-a-matrix/>Longest Increasing Path in a Matrix</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given an m x n integers matrix, return the length of the longest increasing path in matrix.

From each cell, you can either move to four directions: left, right, up or down. You can not move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).
</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves exploring all possible paths starting from each cell in the matrix. For each cell, recursively explore its neighbors (up, down, left, right) and keep track of the longest increasing path found so far. This involves checking all possible paths and would be highly inefficient.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int row, int col, int prevValue, int rows, int cols) {
    if (row &lt 0 || row &gt= rows || col &lt 0 || col &gt= cols || matrix[row][col] &lt= prevValue) {
        return 0;
    }

    int up = dfs(matrix, row - 1, col, matrix[row][col], rows, cols);
    int down = dfs(matrix, row + 1, col, matrix[row][col], rows, cols);
    int left = dfs(matrix, row, col - 1, matrix[row][col], rows, cols);
    int right = dfs(matrix, row, col + 1, matrix[row][col], rows, cols);

    return 1 + max({up, down, left, right});
}

int longestIncreasingPathBruteForce(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
    if (matrix.empty() || matrix[0].empty()) {
        return 0;
    }

    int rows = matrix.size();
    int cols = matrix[0].size();
    int maxLen = 0;

    for (int i = 0; i &lt rows; ++i) {
        for (int j = 0; j &lt cols; ++j) {
            maxLen = max(maxLen, dfs(matrix, i, j, -1, rows, cols));
        }
    }

    return maxLen;
}

//int main() {
//    vector&lt;vector&lt;int&gt;&gt; matrix = {
//            {9, 9, 4},
//            {6, 6, 8},
//            {2, 1, 1}
//    };
//    cout &lt;&lt; longestIncreasingPathBruteForce(matrix) &lt;&lt; endl;
//    return 0;
//}
</code></pre>
  <p><b>Time Complexity:</b> O(m * n * 4^(m*n)), where m is the number of rows and n is the number of columns. In the worst case, the algorithm explores all possible paths from each cell. | <b>Space Complexity:</b> O(m * n) due to the recursion call stack in the worst case.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming with Memoization (Top-Down)</h5>
  <p>This approach uses dynamic programming with memoization to optimize the brute-force solution.  We use a `dp` table to store the length of the longest increasing path starting from each cell. The `dfs` function explores the neighbors of a cell, but before exploring a neighbor, it checks if the longest increasing path from that neighbor has already been computed (memoized). This avoids redundant computations.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, vector&lt;vector&lt;int&gt;&gt;&amp; dp, int row, int col, int prevValue, int rows, int cols) {
    if (row &lt 0 || row &gt= rows || col &lt 0 || col &gt= cols || matrix[row][col] &lt= prevValue) {
        return 0;
    }

    if (dp[row][col] != 0) {
        return dp[row][col];
    }

    int up = dfs(matrix, dp, row - 1, col, matrix[row][col], rows, cols);
    int down = dfs(matrix, dp, row + 1, col, matrix[row][col], rows, cols);
    int left = dfs(matrix, dp, row, col - 1, matrix[row][col], rows, cols);
    int right = dfs(matrix, dp, row, col + 1, matrix[row][col], rows, cols);

    dp[row][col] = 1 + max({up, down, left, right});
    return dp[row][col];
}

int longestIncreasingPathOptimized(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
    if (matrix.empty() || matrix[0].empty()) {
        return 0;
    }

    int rows = matrix.size();
    int cols = matrix[0].size();
    vector&lt;vector&lt;int&gt;&gt; dp(rows, vector&lt;int&gt;(cols, 0));
    int maxLen = 0;

    for (int i = 0; i &lt rows; ++i) {
        for (int j = 0; j &lt cols; ++j) {
            maxLen = max(maxLen, dfs(matrix, dp, i, j, -1, rows, cols));
        }
    }

    return maxLen;
}

//int main() {
//    vector&lt;vector&lt;int&gt;&gt; matrix = {
//            {9, 9, 4},
//            {6, 6, 8},
//            {2, 1, 1}
//    };
//    cout &lt;&lt; longestIncreasingPathOptimized(matrix) &lt;&lt; endl;
//    return 0;
//}
</code></pre>
  <p><b>Time Complexity:</b> O(m * n), where m is the number of rows and n is the number of columns. Each cell is visited at most once. | <b>Space Complexity:</b> O(m * n) for the dp table. O(m*n) in worst case, for recursive call stack</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">matrix = [[9,9,4],[6,6,8],[2,1,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The longest increasing path is [1, 2, 6, 9].</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">matrix = [[3,4,5],[3,2,6],[2,2,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The longest increasing path is [2, 3, 4, 5].</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">matrix = [[1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The longest increasing path is [1].</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  **Edge Cases:** Handle empty matrices or matrices with only one element.
2.  **Memoization is key:** Using a DP table to store calculated longest path lengths significantly improves efficiency by avoiding redundant computations.
3.  **Neighbor exploration:** The core of the solution involves checking neighbors (up, down, left, right) to find increasing paths.
4.  **Starting point:** Iterate through each cell as a starting point to discover possible longest paths, using memoization to make it efficient.
5.  **Direction**: Four directions are allowed, including up, down, left and right.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/making-a-large-island/>Making A Large Island</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>You are given an n x n binary matrix grid. You can change at most one 0 to be 1. Return the size of the largest island in the grid after applying this operation. An island is a 4-directionally connected group of 1s.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through each 0 in the grid. For each 0, temporarily change it to 1. Then, perform a Depth-First Search (DFS) or Breadth-First Search (BFS) to calculate the size of the island formed by this change. Keep track of the maximum island size found. After each attempt to change a 0 to 1, revert it back to 0.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int r, int c, vector&lt;vector&lt;bool&gt;&gt;&amp; visited) {
    int n = grid.size();
    if (r &lt 0 || r &gt= n || c &lt 0 || c &gt= n || visited[r][c] || grid[r][c] == 0) {
        return 0;
    }
    visited[r][c] = true;
    int count = 1;
    count += dfs(grid, r + 1, c, visited);
    count += dfs(grid, r - 1, c, visited);
    count += dfs(grid, r, c + 1, visited);
    count += dfs(grid, r, c - 1, visited);
    return count;
}

int largestIslandBruteForce(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
    int n = grid.size();
    int max_area = 0;

    for (int r = 0; r &lt n; ++r) {
        for (int c = 0; c &lt n; ++c) {
            if (grid[r][c] == 0) {
                grid[r][c] = 1;
                vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(n, false));
                for (int i = 0; i &lt n; ++i) {
                    for (int j = 0; j &lt n; ++j) {
                        if (grid[i][j] == 1 &amp;&amp; !visited[i][j]) {
                            max_area = max(max_area, dfs(grid, i, j, visited));
                        }
                    }
                }
                grid[r][c] = 0;
            }
        }
    }
    
    // If no 0, find the complete area
    if (max_area == 0) {
        vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(n, false));
        for (int i = 0; i &lt n; ++i) {
            for (int j = 0; j &lt n; ++j) {
                if (grid[i][j] == 1 &amp;&amp; !visited[i][j]) {
                    max_area = max(max_area, dfs(grid, i, j, visited));
                }
            }
        }
    }
    
    if (max_area == 0) return n * n; //handle all 0's grid
    return max_area;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^4), where n is the size of the grid.  For each zero, we potentially perform a DFS/BFS which takes O(n^2) time.  We iterate over the grid (n^2) times for 0's. | <b>Space Complexity:</b> O(n^2) due to the visited array in DFS/BFS calls.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized with Island Coloring and Union Find (Implicit)</h5>
  <p>First, perform a DFS or BFS to identify all islands and assign each island a unique color (ID). Store the area of each island in a hash map (island ID -> area). Then, iterate through all 0s. For each 0, check its adjacent cells. If any of the adjacent cells belong to different islands, calculate the total area of those islands plus 1 (for the 0 we changed). Keep track of the largest possible area.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int r, int c, int color, vector&lt;vector&lt;int&gt;&gt;&amp; colored_grid) {
    int n = grid.size();
    if (r &lt 0 || r &gt= n || c &lt 0 || c &gt= n || grid[r][c] == 0 || colored_grid[r][c] != 0) {
        return 0;
    }
    colored_grid[r][c] = color;
    int count = 1;
    count += dfs(grid, r + 1, c, color, colored_grid);
    count += dfs(grid, r - 1, c, color, colored_grid);
    count += dfs(grid, r, c + 1, color, colored_grid);
    count += dfs(grid, r, c - 1, color, colored_grid);
    return count;
}

int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
    int n = grid.size();
    vector&lt;vector&lt;int&gt;&gt; colored_grid(n, vector&lt;int&gt;(n, 0));
    unordered_map&lt;int, int&gt; island_areas;
    int color = 2; // Start color from 2, 0 is uncolored, 1 is land.

    for (int i = 0; i &lt n; ++i) {
        for (int j = 0; j &lt n; ++j) {
            if (grid[i][j] == 1 &amp;&amp; colored_grid[i][j] == 0) {
                int area = dfs(grid, i, j, color, colored_grid);
                island_areas[color] = area;
                color++;
            }
        }
    }

    int max_area = 0;

    for (int i = 0; i &lt n; ++i) {
        for (int j = 0; j &lt n; ++j) {
            if (grid[i][j] == 0) {
                unordered_set&lt;int&gt; adjacent_islands;
                if (i &gt 0 &amp;&amp; colored_grid[i - 1][j] != 0) {
                    adjacent_islands.insert(colored_grid[i - 1][j]);
                }
                if (i &lt n - 1 &amp;&amp; colored_grid[i + 1][j] != 0) {
                    adjacent_islands.insert(colored_grid[i + 1][j]);
                }
                if (j &gt 0 &amp;&amp; colored_grid[i][j - 1] != 0) {
                    adjacent_islands.insert(colored_grid[i][j - 1]);
                }
                if (j &lt n - 1 &amp;&amp; colored_grid[i][j + 1] != 0) {
                    adjacent_islands.insert(colored_grid[i][j + 1]);
                }

                int current_area = 1;
                for (int island_id : adjacent_islands) {
                    current_area += island_areas[island_id];
                }
                max_area = max(max_area, current_area);
            }
        }
    }

    // Handle the case where no 0 exists initially
    if (max_area == 0) {
        int total_area = 0;
        for(auto const& [key, val] : island_areas){
            total_area = max(total_area,val);
        }
        return total_area == 0 ? n*n : total_area;
    }

    return max_area;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) to perform DFS/BFS for island identification and O(n^2) to iterate through the grid for potential flips, so the overall time complexity is O(n^2). | <b>Space Complexity:</b> O(n^2) to store the colored grid and potentially O(n^2) in the worst case for the island_areas map (if all cells are part of different islands).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,1,1,0],[1,0,0,1],[1,0,0,1],[0,1,1,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">7</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Changing the zero at grid[1][1] will give the largest island with area 7</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,0,0,0],[0,0,0,0],[0,0,0,1],[0,0,0,0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Changing a 0 between the existing islands gives an island with area 4</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,1],[1,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No changes are needed as all cells are connected.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0,0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Changing any 0 makes the island size 1.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to solving this problem efficiently is to avoid redundant calculations by identifying and pre-calculating island areas. The use of DFS/BFS to color and label the islands, and a hash map to store island sizes, significantly reduces the time complexity.  The edge case of the input grid containing all 1s or all 0s needs to be handled carefully.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/remove-boxes/>Remove Boxes</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>You are given several boxes with different colors represented by different positive numbers. You may experience several rounds to remove boxes until all the boxes are removed. In each round, you can choose some continuous boxes with the same color (i.e., compose a group) and remove them. The score you get from this round is equal to the square of the number of boxes you remove. Return the maximum score you can get. 

For example:
Input: boxes = [1,3,2,2,2,3,4,3,1]
Output: 23
Explanation: 
[1, 3, 2, 2, 2, 3, 4, 3, 1] 
--&gt; [1, 3, 3, 4, 3, 1] (3*3=9) 
--&gt; [1, 3, 3, 1] (1*1=1) 
--&gt; [1, 1] (3*3=9) 
--&gt; [] (2*2=4) 
So the maximum score is 9 + 1 + 9 + 4 = 23.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves trying all possible combinations of removing boxes. For each possible grouping of boxes with the same color, we calculate the score and recursively call the function for the remaining boxes. This approach is highly inefficient due to the exponential number of possibilities.</p>
  <pre><code class="language-python">#include &lt;bits/stdc++.h&gt;
using namespace std;

int removeBoxes_brute_force(vector&lt;int&gt;&amp; boxes) {
    int n = boxes.size();
    if (n == 0) {
        return 0;
    }

    int max_score = 0;
    for (int i = 0; i &lt; n; ++i) {
        for (int j = i; j &lt; n; ++j) {
            if (boxes[i] == boxes[j]) {
                int count = j - i + 1;
                vector&lt;int&gt; next_boxes;
                for (int k = 0; k &lt; i; ++k) {
                    next_boxes.push_back(boxes[k]);
                }
                for (int k = j + 1; k &lt; n; ++k) {
                    next_boxes.push_back(boxes[k]);
                }
                max_score = max(max_score, count * count + removeBoxes_brute_force(next_boxes));
            }
        }
    }
    return max_score;
}
</code></pre>
  <p><b>Time Complexity:</b> O(2^n * n), where n is the number of boxes.  The exponential factor comes from trying all possible combinations of removals. The n factor comes from potentially creating copies of vectors. | <b>Space Complexity:</b> O(n) in the worst case due to recursion depth and creating new vectors.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming with Memoization</h5>
  <p>This approach uses dynamic programming with memoization to avoid redundant calculations.  We define a 3D DP array dp[l][r][k], where dp[l][r][k] represents the maximum score we can obtain from the boxes from index l to r, with k boxes of the same color as boxes[r] to the right of it.  We then iterate through all possible combinations of removing boxes and use memoization to store the results.</p>
  <pre><code class="language-python">#include &lt;bits/stdc++.h&gt;
using namespace std;

int removeBoxes_optimized(vector&lt;int&gt;&amp; boxes) {
    int n = boxes.size();
    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n, vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n, 0)));

    function&lt;int(int, int, int)&gt; solve = [&](int l, int r, int k) {
        if (l &gt; r) {
            return 0;
        }
        if (dp[l][r][k] &gt; 0) {
            return dp[l][r][k];
        }

        int score = (k + 1) * (k + 1);
        dp[l][r][k] = solve(l, r - 1, 0) + score;

        for (int i = l; i &lt; r; ++i) {
            if (boxes[i] == boxes[r]) {
                dp[l][r][k] = max(dp[l][r][k], solve(l, i, k + 1) + solve(i + 1, r - 1, 0));
            }
        }
        return dp[l][r][k];
    };
    return solve(0, n - 1, 0);
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^4). The dp array has dimensions n x n x n. In the worst case, for each state, we iterate through a nested loop with complexity O(n). | <b>Space Complexity:</b> O(n^3) due to the DP table.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">boxes = [1,3,2,2,2,3,4,3,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">23</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The optimal solution involves removing consecutive groups of the same color boxes to maximize the score. This example highlights different possible removals leading to the optimal result.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">boxes = [1,1,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">9</td>
        <td style="border: 1px solid #ccc; padding: 6px;">All boxes are of the same color. Removing them together gives the maximum score of 3*3=9</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">boxes = [1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There is only one box and hence score will be 1*1=1.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">boxes = [1,2,3,4,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No consecutive boxes of same colors are there, So max score is 1+1+1+1+1=5</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The dynamic programming solution significantly improves efficiency compared to brute force. The critical part is the state definition and the transitions.  Edge cases include empty input arrays and arrays where all elements are different.  The memoization helps drastically improve performance.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/critical-connections-in-a-network/>Critical Connections in a Network</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given an undirected connected graph with n nodes labeled from 0 to n - 1 and a list of connections (edges) where connections[i] = [ui, vi] represents a bidirectional edge between nodes ui and vi. Find all critical connections in the graph (i.e., the edges that, if removed, would disconnect the graph). Return the critical connections as a list of lists.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves iterating through each edge in the input 'connections'. For each edge, temporarily remove it from the graph and check if the graph remains connected using either Depth First Search (DFS) or Breadth First Search (BFS). If removing the edge disconnects the graph, then it is a critical connection. This approach involves checking connectivity for each edge, resulting in significant computational overhead.</p>
  <pre><code class="language-python">#include &ltiostream&gt
#include &ltvector&gt
#include &ltalgorithm&gt

using namespace std;

// Helper function to perform DFS and check connectivity
bool isConnected(int n, const vector&ltvector&ltint&gt;&gt;&amp; adj, int u, int v, const vector&ltpair&ltint, int&gt;&gt;&amp; removed_edge) {
    vector&ltbool&gt; visited(n, false);
    vector&ltint&gt; stack;
    stack.push_back(0);
    visited[0] = true;

    while (!stack.empty()) {
        int curr = stack.back();
        stack.pop_back();

        for (int neighbor : adj[curr]) {
            // Skip the removed edge if it's encountered during DFS
            if ((curr == u &amp;&amp; neighbor == v) || (curr == v &amp;&amp; neighbor == u)) {
                continue;
            }

            if (!visited[neighbor]) {
                visited[neighbor] = true;
                stack.push_back(neighbor);
            }
        }
    }
    
    for(int i = 0; i &lt n; ++i){
        if(!visited[i]) return false;
    }
    return true;
}

vector&ltvector&ltint&gt;&gt; criticalConnectionsBruteForce(int n, vector&ltvector&ltint&gt;&gt;&amp; connections) {
    vector&ltvector&ltint&gt;&gt; criticalConnections;

    for (int i = 0; i &lt connections.size(); ++i) {
        int u = connections[i][0];
        int v = connections[i][1];

        // Build the adjacency list
        vector&ltvector&ltint&gt;&gt; adj(n);
        for (int j = 0; j &lt connections.size(); ++j) {
            if (i != j) {
                adj[connections[j][0]].push_back(connections[j][1]);
                adj[connections[j][1]].push_back(connections[j][0]);
            }
        }

        // Check if removing the edge disconnects the graph
       if (!isConnected(n, adj, u, v, { {u, v} })) {
            criticalConnections.push_back({u, v});
        }
    }
    return criticalConnections;
}
</code></pre>
  <p><b>Time Complexity:</b> O(E * (V + E)), where E is the number of edges and V is the number of vertices.  We iterate through each edge (E) and, for each edge, perform a DFS/BFS on a graph with (V+E) operations in worst-case. | <b>Space Complexity:</b> O(V + E), primarily due to the adjacency list and the space used during DFS/BFS.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Tarjan's Algorithm (Bridge Finding)</h5>
  <p>Tarjan's algorithm efficiently finds bridges (critical connections) in a graph using Depth First Search (DFS). It assigns discovery times (ids) to each node and calculates the lowest reachable node (low) from each node. An edge (u, v) is a bridge if the low value of v is greater than the discovery time of u. This means that there's no back edge from the subtree rooted at v to any of u's ancestors, therefore, removing the edge (u, v) will disconnect the graph.</p>
  <pre><code class="language-python">#include &ltiostream&gt
#include &ltvector&gt
#include &ltalgorithm&gt

using namespace std;

void dfs(int u, int parent, int& time, vector&ltint&gt;&amp; disc, vector&ltint&gt;&amp; low, vector&ltvector&ltint&gt;&gt;&amp; adj, vector&ltvector&ltint&gt;&gt;&amp; &criticalConnections, vector&ltpair&ltint, int&gt;&gt;&amp; edges) {
    disc[u] = low[u] = ++time;
    for (int v : adj[u]) {
        if (v == parent) continue;

        if (disc[v] == -1) {
            dfs(v, u, time, disc, low, adj, criticalConnections, edges);
            low[u] = min(low[u], low[v]);

            if (low[v] &gt disc[u]) {
                criticalConnections.push_back({u, v});
            }
        } else {
            low[u] = min(low[u], disc[v]);
        }
    }
}

vector&ltvector&ltint&gt;&gt; criticalConnectionsOptimized(int n, vector&ltvector&ltint&gt;&gt;&amp; connections) {
    vector&ltvector&ltint&gt;&gt; adj(n);
    for (const auto& connection : connections) {
        adj[connection[0]].push_back(connection[1]);
        adj[connection[1]].push_back(connection[0]);
    }

    vector&ltint&gt; disc(n, -1), low(n, -1);
    vector&ltvector&ltint&gt;&gt; criticalConnections;
    int time = 0;
    vector&ltpair&ltint, int&gt;&gt; edges;

    for (int i = 0; i &lt n; ++i) {
        if (disc[i] == -1) {
            dfs(i, -1, time, disc, low, adj, criticalConnections, edges);
        }
    }
    return criticalConnections;
}
</code></pre>
  <p><b>Time Complexity:</b> O(V + E), where V is the number of vertices and E is the number of edges. This is because we visit each vertex and edge once during the DFS traversal. | <b>Space Complexity:</b> O(V + E).  The space complexity is primarily due to the adjacency list, the discovery and low arrays (O(V)), and the recursion stack during DFS which, in the worst-case scenario can reach O(V).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,3]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Removing the edge [1,3] will disconnect the graph. The edges [0,1] and [2,0] create a cycle, thus are not critical connections.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 2, connections = [[0,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Removing the edge [0,1] will disconnect the graph, as there is only one edge.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 6, connections = [[0,1],[1,2],[2,0],[1,3],[3,4],[4,5],[5,3]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,3]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The edge (1,3) is a bridge. All other edges form cycles.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The problem deals with undirected graphs. 
2.  Cycles in the graph prevent an edge from being a critical connection.  Edges that are part of cycles are not considered critical.
3.  Tarjan's algorithm efficiently identifies bridges by leveraging the concept of discovery times and low-link values during DFS traversal. 
4.  Consider edge cases such as a graph with only one edge or a graph with no critical connections.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/alien-dictionary/1>Alien Dictionary</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given a sorted dictionary (array of strings) of an alien language, find the order of characters in the alien language.  The alien language's alphabet is a permutation of the English alphabet. The words are sorted lexicographically, and this information helps determine the order of characters.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves comparing each pair of consecutive words in the given dictionary. For each pair, we find the first different character. The order of these characters determines the alien alphabet. We can build a graph where the nodes are characters and an edge represents the order. If inconsistencies or cycles exist, the ordering is not possible. The graph can be built using a hashmap (adjacency list). Then perform topological sort, if any cycle exists we will not be able to find an order.  If there's a case where after comparing all words, some nodes are not included, it can happen because those characters do not participate in ordering of alien language, so include them at the end of topological sort.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string findOrder(vector&lt;string&gt;&amp; words, int k) {
    unordered_map&lt;char, vector&lt;char&gt;&gt; adj;
    unordered_map&lt;char, int&gt; indegree;
    for (string&amp; word : words) {
        for (char c : word) {
            indegree[c] = 0;
        }
    }

    for (int i = 0; i &lt; words.size() - 1; ++i) {
        string&amp; word1 = words[i];
        string&amp; word2 = words[i + 1];
        int len = min(word1.length(), word2.length());
        for (int j = 0; j &lt; len; ++j) {
            if (word1[j] != word2[j]) {
                if (find(adj[word1[j]].begin(), adj[word1[j]].end(), word2[j]) == adj[word1[j]].end()) {
                    adj[word1[j]].push_back(word2[j]);
                    indegree[word2[j]]++;
                }
                break; // Found a difference, move to the next pair of words.
            }
        }
    }

    queue&lt;char&gt; q;
    for (auto&amp; entry : indegree) {
        if (entry.second == 0) {
            q.push(entry.first);
        }
    }

    string result = "";
    while (!q.empty()) {
        char u = q.front();
        q.pop();
        result += u;
        for (char v : adj[u]) {
            indegree[v]--;
            if (indegree[v] == 0) {
                q.push(v);
            }
        }
    }

    if (result.length() != indegree.size()) {
        return ""; // Cycle detected
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N * W + K), where N is the number of words, W is the maximum length of a word, and K is the number of unique characters (which is at most 26). Building the graph is O(N * W), and topological sort is O(V + E) where V is the number of vertices (characters) and E is the number of edges. | <b>Space Complexity:</b> O(K), for storing the graph and indegree. In worst case all the characters are distinct.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach (Topological Sort)</h5>
  <p>The optimized approach is based on topological sorting.  First, we build a graph representing the character dependencies by comparing adjacent words in the input dictionary.  For each pair of consecutive words, we find the first differing character. The order implied by these differing characters forms edges in the graph. We calculate the in-degrees of each node and use Kahn's algorithm (or DFS) to perform topological sort. If a cycle exists, the ordering is invalid. If we are able to successfully complete the topological sort, we'll obtain an ordering of the characters. Topological sort has the same complexity as the Brute force, but is considered better design-wise.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string findOrder(vector&lt;string&gt;&amp; words, int k) {
    unordered_map&lt;char, vector&lt;char&gt;&gt; adj;
    unordered_map&lt;char, int&gt; indegree;
    for (string&amp; word : words) {
        for (char c : word) {
            indegree[c] = 0;  // Initialize indegrees
        }
    }

    // Build the graph and calculate indegrees
    for (int i = 0; i &lt; words.size() - 1; ++i) {
        string&amp; word1 = words[i];
        string&amp; word2 = words[i + 1];
        int len = min(word1.length(), word2.length());
        for (int j = 0; j &lt; len; ++j) {
            if (word1[j] != word2[j]) {
                if (find(adj[word1[j]].begin(), adj[word1[j]].end(), word2[j]) == adj[word1[j]].end()) {
                    adj[word1[j]].push_back(word2[j]);
                    indegree[word2[j]]++;
                }
                break; // Move to the next pair of words.
            }
        }
    }

    queue&lt;char&gt; q;
    for (auto&amp; entry : indegree) {
        if (entry.second == 0) {
            q.push(entry.first);
        }
    }

    string result = "";
    while (!q.empty()) {
        char u = q.front();
        q.pop();
        result += u;
        for (char v : adj[u]) {
            indegree[v]--;
            if (indegree[v] == 0) {
                q.push(v);
            }
        }
    }

    if (result.length() != indegree.size()) {
        return ""; // Cycle detected
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N * W + K) where N is the number of words, W is the maximum length of a word, and K is the number of unique characters (at most 26). | <b>Space Complexity:</b> O(K)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["wrt","wrf","er","ett","rftt"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">wertf</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The character 'w' comes before 'e' because of "wrt" and "er". 'r' comes before 'f' because of "wrf" and "rftt", and so on.  The returned string shows the correct alien alphabet ordering.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["z","x"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">zx</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The word "z" comes before "x", so 'z' should come before 'x' in the alien dictionary.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["z","x","z"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;"></td>
        <td style="border: 1px solid #ccc; padding: 6px;">Inconsistent order. "z" comes before "x", and then "z" appears again, violating the lexicographical order, hence no valid alphabet order can be found. </td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Important considerations include handling cases where the alien dictionary contains contradictory information leading to cycles in the dependency graph.  Also, handle cases where some characters don't appear in the character dependencies (should be added to the result after topological sort). Ensure that the code correctly handles cases where a word is a prefix of another word (e.g., "abc" and "abcd").</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/water-jug-problem-using-bfs/>Water Jug Problem using BFS</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>You are given two jugs with capacities jug1Capacity and jug2Capacity liters, respectively. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly targetCapacity liters of water using these two jugs. 

You are allowed to perform the following operations:

1.  Fill any of the jugs completely.
2.  Empty any of the jugs.
3.  Pour water from one jug to another until the other jug is either full or the first jug is empty.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach explores all possible states reachable from the initial state (0, 0) using Breadth-First Search (BFS). Each state represents the amount of water in jug1 and jug2.  We apply allowed operations (fill, empty, pour) until we either find the target capacity or exhaust all reachable states.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

// Structure to represent the state of the jugs
struct State {
    int jug1, jug2;
    vector&ltint&gt path;
};

bool canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {
    if (targetCapacity &lt= 0) return true;
    if (targetCapacity &gt jug1Capacity + jug2Capacity) return false;

    // Use a queue for BFS
    queue&lt;State&gt q;
    q.push({0, 0, {}});

    // Use a set to keep track of visited states
    unordered_set&lt;string&gt visited;

    while (!q.empty()) {
        State curr = q.front();
        q.pop();

        // Check if target is reached
        if (curr.jug1 == targetCapacity || curr.jug2 == targetCapacity || curr.jug1 + curr.jug2 == targetCapacity) {
            return true;
        }

        // Generate next states
        // Fill jug1
        if (visited.find("fill1_" + to_string(jug1Capacity) + "_" + to_string(curr.jug2)) == visited.end()) {
            q.push({jug1Capacity, curr.jug2, {}});
            visited.insert("fill1_" + to_string(jug1Capacity) + "_" + to_string(curr.jug2));
        }
        // Fill jug2
        if (visited.find("fill2_" + to_string(curr.jug1) + "_" + to_string(jug2Capacity)) == visited.end()) {
            q.push({curr.jug1, jug2Capacity, {}});
            visited.insert("fill2_" + to_string(curr.jug1) + "_" + to_string(jug2Capacity));
        }
        // Empty jug1
        if (visited.find("empty1_0_" + to_string(curr.jug2)) == visited.end()) {
            q.push({0, curr.jug2, {}});
            visited.insert("empty1_0_" + to_string(curr.jug2));
        }
        // Empty jug2
        if (visited.find("empty2_" + to_string(curr.jug1) + "_0") == visited.end()) {
            q.push({curr.jug1, 0, {}});
            visited.insert("empty2_" + to_string(curr.jug1) + "_0");
        }
        // Pour jug1 into jug2
        int pour1to2 = min(curr.jug1, jug2Capacity - curr.jug2);
        if (visited.find("pour1to2_" + to_string(curr.jug1 - pour1to2) + "_" + to_string(curr.jug2 + pour1to2)) == visited.end()) {
            q.push({curr.jug1 - pour1to2, curr.jug2 + pour1to2, {}});
            visited.insert("pour1to2_" + to_string(curr.jug1 - pour1to2) + "_" + to_string(curr.jug2 + pour1to2));
        }
        // Pour jug2 into jug1
        int pour2to1 = min(curr.jug2, jug1Capacity - curr.jug1);
        if (visited.find("pour2to1_" + to_string(curr.jug1 + pour2to1) + "_" + to_string(curr.jug2 - pour2to1)) == visited.end()) {
            q.push({curr.jug1 + pour2to1, curr.jug2 - pour2to1, {}});
            visited.insert("pour2to1_" + to_string(curr.jug1 + pour2to1) + "_" + to_string(curr.jug2 - pour2to1));
        }
    }
    return false;
}
</code></pre>
  <p><b>Time Complexity:</b> O((jug1Capacity + jug2Capacity)^2) in the worst case, as the maximum possible states are (jug1Capacity + 1) * (jug2Capacity + 1) | <b>Space Complexity:</b> O((jug1Capacity + jug2Capacity)^2) in the worst case, to store the visited states and the queue.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized with BFS and GCD</h5>
  <p>This approach utilizes the mathematical properties of the problem.  We know that any amount of water that can be measured must be a multiple of the greatest common divisor (GCD) of the jug capacities. We can check if the target capacity is a multiple of the GCD, which significantly reduces the search space. We still use BFS to check all possible states but incorporate this check for an earlier exit.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

// Function to calculate the greatest common divisor (GCD)
int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}

// Structure to represent the state of the jugs
struct State {
    int jug1, jug2;
    vector&ltint&gt path;
};

bool canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {
    if (targetCapacity &lt= 0) return true;
    if (targetCapacity &gt jug1Capacity + jug2Capacity) return false;

    // If target is directly achievable
    if (targetCapacity == jug1Capacity || targetCapacity == jug2Capacity || targetCapacity == jug1Capacity + jug2Capacity) return true;

    // Check if the target is a multiple of the GCD of the jug capacities
    if (targetCapacity % gcd(jug1Capacity, jug2Capacity) != 0) return false;

    // Use a queue for BFS
    queue&lt;State&gt q;
    q.push({0, 0, {}});

    // Use a set to keep track of visited states
    unordered_set&lt;string&gt visited;

    while (!q.empty()) {
        State curr = q.front();
        q.pop();

        // Check if target is reached
        if (curr.jug1 == targetCapacity || curr.jug2 == targetCapacity || curr.jug1 + curr.jug2 == targetCapacity) {
            return true;
        }

        // Generate next states
        // Fill jug1
        if (visited.find("fill1_" + to_string(jug1Capacity) + "_" + to_string(curr.jug2)) == visited.end()) {
            q.push({jug1Capacity, curr.jug2, {}});
            visited.insert("fill1_" + to_string(jug1Capacity) + "_" + to_string(curr.jug2));
        }
        // Fill jug2
        if (visited.find("fill2_" + to_string(curr.jug1) + "_" + to_string(jug2Capacity)) == visited.end()) {
            q.push({curr.jug1, jug2Capacity, {}});
            visited.insert("fill2_" + to_string(curr.jug1) + "_" + to_string(jug2Capacity));
        }
        // Empty jug1
        if (visited.find("empty1_0_" + to_string(curr.jug2)) == visited.end()) {
            q.push({0, curr.jug2, {}});
            visited.insert("empty1_0_" + to_string(curr.jug2));
        }
        // Empty jug2
        if (visited.find("empty2_" + to_string(curr.jug1) + "_0") == visited.end()) {
            q.push({curr.jug1, 0, {}});
            visited.insert("empty2_" + to_string(curr.jug1) + "_0");
        }
        // Pour jug1 into jug2
        int pour1to2 = min(curr.jug1, jug2Capacity - curr.jug2);
        if (visited.find("pour1to2_" + to_string(curr.jug1 - pour1to2) + "_" + to_string(curr.jug2 + pour1to2)) == visited.end()) {
            q.push({curr.jug1 - pour1to2, curr.jug2 + pour1to2, {}});
            visited.insert("pour1to2_" + to_string(curr.jug1 - pour1to2) + "_" + to_string(curr.jug2 + pour1to2));
        }
        // Pour jug2 into jug1
        int pour2to1 = min(curr.jug2, jug1Capacity - curr.jug1);
        if (visited.find("pour2to1_" + to_string(curr.jug1 + pour2to1) + "_" + to_string(curr.jug2 - pour2to1)) == visited.end()) {
            q.push({curr.jug1 + pour2to1, curr.jug2 - pour2to1, {}});
            visited.insert("pour2to1_" + to_string(curr.jug1 + pour2to1) + "_" + to_string(curr.jug2 - pour2to1));
        }
    }
    return false;
}
</code></pre>
  <p><b>Time Complexity:</b> O(min(jug1Capacity, jug2Capacity) * log(min(jug1Capacity, jug2Capacity))).  The GCD calculation dominates the time complexity, but the number of reachable states is reduced significantly due to the GCD check. | <b>Space Complexity:</b> O(min(jug1Capacity, jug2Capacity)) in the worst case, dominated by the size of the visited set and the queue, however the search space is reduced significantly because the GCD check helps reduce the possible states.</p>
  <h5>‚û§ Optimized: Mathematical Approach</h5>
  <p>This approach relies solely on mathematical principles and the GCD.  The conditions for success are:
1.  targetCapacity &lt= jug1Capacity + jug2Capacity
2.  targetCapacity is a multiple of gcd(jug1Capacity, jug2Capacity)</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}

bool canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {
    if (targetCapacity &gt jug1Capacity + jug2Capacity) return false;
    if (targetCapacity == jug1Capacity || targetCapacity == jug2Capacity || targetCapacity == 0) return true;
    return (targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0);
}
</code></pre>
  <p><b>Time Complexity:</b> O(log(min(jug1Capacity, jug2Capacity))) due to the GCD calculation. | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Pour 3 liters into jug1 and 5 liters into jug2. Pour from jug2 into jug1 until jug1 is full. Now, jug1 has 3 liters and jug2 has 2 liters. Empty jug1. Now, pour the 2 liters from jug2 into jug1. Fill jug2 with 5 liters. Pour from jug2 into jug1 until jug1 is full (3 liters).  Jug2 now has 4 liters.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">It is not possible to measure exactly 5 liters of water using these jugs.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">jug1Capacity = 1, jug2Capacity = 2, targetCapacity = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Fill both jugs</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">jug1Capacity = 1, jug2Capacity = 2, targetCapacity = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Target is 0.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key idea is to recognize that any achievable amount of water must be a multiple of the GCD of the jug capacities. This dramatically simplifies the problem, leading to more efficient solutions. Be mindful of edge cases such as targetCapacity being 0 or larger than the combined jug capacities.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/travelling-salesman-problem-set-1/>Travelling Salesman Problem | Set 1 (Naive and Dynamic Programming)</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given a set of cities and the distances between every pair of cities, the problem is to find the shortest possible route that visits every city exactly once and returns to the origin city.

The problem is a classic optimization problem, and it's NP-hard, meaning there is no known polynomial-time solution for it.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves generating all possible permutations of cities (excluding the starting city, since we can fix it) and calculating the total distance for each permutation. The minimum distance among all permutations is the solution.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int tsp(vector&lt;vector&lt;int&gt;&gt;&amp; graph, vector&lt;int&gt;&amp; path, int start) {
    int n = graph.size();
    int min_cost = INT_MAX;
    
    do {
        int current_cost = 0;
        int u = start;
        bool valid_path = true;
        for (int v : path) {
            if (graph[u][v] == 0) {
                valid_path = false;
                break;
            }
            current_cost += graph[u][v];
            u = v;
        }
        if (valid_path &amp;&amp; graph[u][start] != 0) {
            current_cost += graph[u][start];
            min_cost = min(min_cost, current_cost);
        }
    } while (next_permutation(path.begin(), path.end()));
    
    return min_cost;
}

int main() {
    vector&lt;vector&lt;int&gt;&gt; graph = {
        {0, 10, 15, 20},
        {10, 0, 35, 25},
        {15, 35, 0, 30},
        {20, 25, 30, 0}
    };
    int start = 0;
    int n = graph.size();
    vector&lt;int&gt; path;
    for (int i = 0; i &lt; n; i++) {
        if (i != start) {
            path.push_back(i);
        }
    }
    
    cout &lt;&lt; "Minimum cost: " &lt;&lt; tsp(graph, path, start) &lt;&lt; endl;
    
    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N!), where N is the number of cities. This is because we generate all permutations of the cities. | <b>Space Complexity:</b> O(N), due to the space used to store the permutation and path.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming (Bitmasking)</h5>
  <p>This approach uses dynamic programming with bitmasking to store the visited cities.  A bitmask represents the set of visited cities.  We build a table `dp[mask][u]` where `mask` represents the visited cities (a bit is set if the city is visited) and `u` is the current city.  The value in `dp[mask][u]` represents the minimum cost to visit all cities in `mask` ending at city `u`. The solution is dp[(1 &lt;&lt; N) - 1][0], where 0 is the starting city (or any arbitrary city).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int tsp_dp(vector&lt;vector&lt;int&gt;&gt;&amp; graph) {
    int n = graph.size();
    vector&lt;vector&lt;int&gt;&gt; dp(1 &lt;&lt; n, vector&lt;int&gt;(n, INT_MAX));
    // Base case: cost to reach starting node from itself is 0.
    for (int i = 0; i &lt; n; i++) {
        dp[1 &lt;&lt; i][i] = 0;
    }
    // Iterate through all possible subsets (masks).
    for (int mask = 0; mask &lt; (1 &lt;&lt; n); mask++) {
        for (int u = 0; u &lt; n; u++) {
            // If the city is in the mask and the current cost is not INT_MAX.
            if ((mask &amp; (1 &lt;&lt; u)) &amp;&amp; dp[mask][u] != INT_MAX) {
                for (int v = 0; v &lt; n; v++) {
                    // If the destination city is not in the mask.
                    if (!(mask &amp; (1 &lt;&lt; v)) &amp;&amp; graph[u][v] != 0) {
                        // Calculate the cost to visit the next city.
                        dp[mask | (1 &lt;&lt; v)][v] = min(dp[mask | (1 &lt;&lt; v)][v], dp[mask][u] + graph[u][v]);
                    }
                }
            }
        }
    }
    // Find the minimum cost to return to starting city from other visited nodes.
    int min_cost = INT_MAX;
    for (int u = 0; u &lt; n; u++) {
        if(graph[u][0] != 0 && dp[(1 &lt;&lt; n) - 1][u] != INT_MAX) {
          min_cost = min(min_cost, dp[(1 &lt;&lt; n) - 1][u] + graph[u][0]);
        }
    }
    return min_cost;
}

int main() {
    vector&lt;vector&lt;int&gt;&gt; graph = {
        {0, 10, 15, 20},
        {10, 0, 35, 25},
        {15, 35, 0, 30},
        {20, 25, 30, 0}
    };

    cout &lt;&lt; "Minimum cost: " &lt;&lt; tsp_dp(graph) &lt;&lt; endl;

    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N^2 * 2^N), where N is the number of cities.  We have 2^N possible masks and for each mask, we have N^2 operations in the nested loops. | <b>Space Complexity:</b> O(N * 2^N), for the DP table.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">graph = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">80</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The optimal tour is 0 -> 1 -> 3 -> 2 -> 0 with cost 10 + 25 + 30 + 15 = 80</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">graph = [[0, 2, 9, 10], [1, 0, 6, 4], [15, 7, 0, 8], [6, 3, 12, 0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">21</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The optimal tour is 0 -> 1 -> 3 -> 2 -> 0 with cost 2 + 4 + 12 + 7 = 25. Or 0 -> 3 -> 1 -> 2 -> 0 = 10 + 3 + 7 + 15 = 35. Or many other combinations.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The TSP is NP-hard, and the brute-force approach is only feasible for a small number of cities.  2. The Dynamic Programming approach is significantly better, but it still has exponential time complexity.  3. Ensure the graph is complete, meaning there is a direct edge between every pair of cities (or add a very high cost if there is no path between cities).  4. Consider handling cases where the graph contains cycles with negative weights. In such cases, using dynamic programming (like the Bellman-Ford algorithm) to detect negative cycles before running the TSP would be beneficial.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/total-number-spanning-trees-graph/>Total number of spanning trees in a graph</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given an undirected graph represented by an adjacency matrix or an adjacency list, the task is to find the total number of spanning trees present in the graph. A spanning tree is a subgraph that includes all the vertices of the original graph and is a tree (i.e., it is connected and contains no cycles).</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible subsets of edges. For each subset, check if the subset forms a spanning tree. This involves checking for connectivity and the absence of cycles.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Function to check if a graph is connected using DFS
bool isConnected(const vector&lt;vector&lt;int&gt;&gt;&amp; adj, int n) {
    vector&lt;bool&gt; visited(n, false);
    int count = 0;
    function&lt;void(int)&gt; dfs = [&](int u) {
        visited[u] = true;
        count++;
        for (int v : adj[u]) {
            if (!visited[v]) {
                dfs(v);
            }
        }
    };

    dfs(0);
    return count == n;
}

// Function to check for cycles using DFS
bool hasCycle(const vector&lt;vector&lt;int&gt;&gt;&amp; adj, int n) {
    vector&lt;int&gt; parent(n, -1);
    vector&lt;bool&gt; visited(n, false);
    
    function&lt;bool(int)&gt; dfs = [&](int u) {
        visited[u] = true;
        for (int v : adj[u]) {
            if (!visited[v]) {
                parent[v] = u;
                if (dfs(v))
                    return true;
            } else if (v != parent[u]) {
                return true;  // Cycle found
            }
        }
        return false;
    };

    for (int i = 0; i &lt; n; ++i) {
        if (!visited[i]) {
            if (dfs(i)) {
                return true;
            }
        }
    }

    return false;
}

// Function to find the total number of spanning trees (Brute Force)
int countSpanningTreesBruteForce(int n, const vector&lt;tuple&lt;int, int&gt;&gt;&amp; edges) {
    int edgeCount = edges.size();
    int spanningTrees = 0;

    for (int i = 0; i &lt; (1 &lt;&lt; edgeCount); ++i) {
        vector&lt;vector&lt;int&gt;&gt; adj(n);
        vector&lt;pair&lt;int, int&gt;&gt; selectedEdges;

        for (int j = 0; j &lt; edgeCount; ++j) {
            if ((i &amp; (1 &lt;&lt; j)) != 0) {
                selectedEdges.push_back({get&lt;0&gt;(edges[j]), get&lt;1&gt;(edges[j])});
            }
        }

        // Build the adjacency list for the selected edges
        for (const auto&amp; edge : selectedEdges) {
            adj[edge.first].push_back(edge.second);
            adj[edge.second].push_back(edge.first);
        }

        // Check if the selected edges form a spanning tree
        if (selectedEdges.size() == n - 1 &amp;&amp; isConnected(adj, n) &amp;&amp; !hasCycle(adj, n)) {
            spanningTrees++;
        }
    }

    return spanningTrees;
}

int main() {
    int n = 4; // Number of vertices
    vector&lt;tuple&lt;int, int&gt;&gt; edges = {
        {0, 1}, {0, 2}, {0, 3}, {1, 2}, {2, 3}
    };

    int result = countSpanningTreesBruteForce(n, edges);
    cout &lt;&lt; "Total spanning trees: " &lt;&lt; result &lt;&lt; endl;
    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(2^E * (V + E)), where E is the number of edges and V is the number of vertices. This is because we iterate through all subsets of edges (2^E), and for each subset, we check for connectivity and cycles (O(V + E) for DFS). | <b>Space Complexity:</b> O(V + E) due to the adjacency list and the visited array used in DFS.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Matrix Tree Theorem</h5>
  <p>This approach utilizes the Matrix Tree Theorem.  It involves calculating the Laplacian matrix of the graph and then computing the determinant of a minor of the Laplacian matrix. This determinant gives the number of spanning trees.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Function to calculate the determinant of a matrix
int determinant(const vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
    int n = matrix.size();
    if (n == 1) {
        return matrix[0][0];
    }
    if (n == 2) {
        return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];
    }

    int det = 0;
    for (int i = 0; i &lt; n; ++i) {
        vector&lt;vector&lt;int&gt;&gt; submatrix(n - 1, vector&lt;int&gt;(n - 1));
        for (int j = 1; j &lt; n; ++j) {
            for (int k = 0, l = 0; k &lt; n; ++k) {
                if (k != i) {
                    submatrix[j - 1][l++] = matrix[j][k];
                }
            }
        }
        det += matrix[0][i] * pow(-1, i) * determinant(submatrix);
    }
    return det;
}

// Function to find the total number of spanning trees using Matrix Tree Theorem
int countSpanningTreesMatrixTree(int n, const vector&lt;tuple&lt;int, int&gt;&gt;&amp; edges) {
    // 1. Construct the Laplacian matrix
    vector&lt;vector&lt;int&gt;&gt; laplacian(n, vector&lt;int&gt;(n, 0));

    // Degree matrix (diagonal elements)
    for (int i = 0; i &lt; n; ++i) {
        int degree = 0;
        for (const auto&amp; edge : edges) {
            if (get&lt;0&gt;(edge) == i || get&lt;1&gt;(edge) == i) {
                degree++;
            }
        }
        laplacian[i][i] = degree;
    }

    // Adjacency matrix (off-diagonal elements)
    for (const auto&amp; edge : edges) {
        int u = get&lt;0&gt;(edge);
        int v = get&lt;1&gt;(edge);
        laplacian[u][v] = -1;
        laplacian[v][u] = -1;
    }

    // 2. Calculate the determinant of a minor (e.g., remove the first row and column)
    vector&lt;vector&lt;int&gt;&gt; minor(n - 1, vector&lt;int&gt;(n - 1));
    for (int i = 1; i &lt; n; ++i) {
        for (int j = 1; j &lt; n; ++j) {
            minor[i - 1][j - 1] = laplacian[i][j];
        }
    }

    return determinant(minor);
}

int main() {
    int n = 4; // Number of vertices
    vector&lt;tuple&lt;int, int&gt;&gt; edges = {
        {0, 1}, {0, 2}, {0, 3}, {1, 2}, {2, 3}
    };

    int result = countSpanningTreesMatrixTree(n, edges);
    cout &lt;&lt; "Total spanning trees: " &lt;&lt; result &lt;&lt; endl;
    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(V^3) where V is the number of vertices.  This comes from the determinant calculation, which has a cubic time complexity (using Gaussian elimination or similar methods). | <b>Space Complexity:</b> O(V^2) to store the Laplacian matrix and the minor matrix.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 4, edges = {{0, 1}, {0, 2}, {0, 3}, {1, 2}, {2, 3}}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">16</td>
        <td style="border: 1px solid #ccc; padding: 6px;">For the given graph, there are 16 possible spanning trees.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 3, edges = {{0, 1}, {1, 2}}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">A simple path forms a spanning tree.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 4, edges = {{0, 1}, {1, 2}, {2, 3}}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">A simple path forms a spanning tree.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The Matrix Tree Theorem is significantly more efficient than the brute-force approach for larger graphs. The determinant calculation can be optimized with Gaussian elimination or similar methods.  Edge cases include graphs with no edges (0 spanning trees), disconnected graphs (0 spanning trees), and graphs where edges form loops or multi-edges (can affect Laplacian Matrix construction).</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/word-ladder/>Word Ladder</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given two words, `beginWord` and `endWord`, and a list of words `wordList`, find the length of the shortest transformation sequence from `beginWord` to `endWord`.  Each transformation can only change one letter at a time. Each intermediate word must exist in the `wordList`. If there is no such sequence, return 0. The `beginWord` is not in `wordList`. The `endWord` can be in `wordList`.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Explore all possible paths from the `beginWord` to the `endWord` using Depth-First Search (DFS). For each word, generate all possible one-letter transformations. Check if the transformed word exists in `wordList`. Recursively explore the valid transformations. Keep track of the shortest path found so far.</p>
  <pre><code class="language-python">#include &ltiostream&gt
#include &ltvector&gt
#include &ltstring&gt
#include &ltunordered_set&gt
#include &ltalgorithm&gt

using namespace std;

class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;& wordList) {
        unordered_set&lt;string&gt; wordSet(wordList.begin(), wordList.end());
        if (wordSet.find(endWord) == wordSet.end()) {
            return 0; // endWord not in wordList
        }

        int minLength = INT_MAX;
        dfs(beginWord, endWord, wordSet, 1, minLength);
        return (minLength == INT_MAX) ? 0 : minLength;
    }

private:
    void dfs(string currentWord, string endWord, unordered_set&lt;string&gt;& wordSet, int length, int& minLength) {
        if (currentWord == endWord) {
            minLength = min(minLength, length);
            return;
        }

        if (length &gt;= minLength) {
            return; // Optimization: Prune paths longer than the shortest found so far
        }

        for (int i = 0; i &lt; currentWord.length(); ++i) {
            char originalChar = currentWord[i];
            for (char ch = 'a'; ch &lt;= 'z'; ++ch) {
                currentWord[i] = ch;
                if (wordSet.find(currentWord) != wordSet.end()) {
                    wordSet.erase(currentWord);
                    dfs(currentWord, endWord, wordSet, length + 1, minLength);
                    wordSet.insert(currentWord);
                }
            }
            currentWord[i] = originalChar;
        }
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(M * N * 26^M), where M is the length of each word and N is the number of words in the word list. In the worst case, we explore all possible transformations. Each word has M letters, and each letter can be changed to 26 other letters. In DFS, we will check if each word in `wordList` can be generated by the change. We traverse through all words for each level of recursion. | <b>Space Complexity:</b> O(N), where N is the number of words in the `wordList` (due to the recursion stack and the wordSet).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Breadth-First Search (BFS)</h5>
  <p>Use BFS to find the shortest path. Start from the `beginWord`. At each level, generate all one-letter transformations. If a transformation is in `wordList`, add it to the queue. Remove words from the `wordList` as they are visited to avoid cycles. Keep track of the distance (number of transformations) from the `beginWord`.</p>
  <pre><code class="language-python">#include &ltiostream&gt;
#include &ltvector&gt;
#include &ltstring&gt;
#include &ltunordered_set&gt;
#include &ltqueue&gt;
#include &ltunordered_map&gt;

using namespace std;

class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;& wordList) {
        unordered_set&lt;string&gt; wordSet(wordList.begin(), wordList.end());
        if (wordSet.find(endWord) == wordSet.end()) {
            return 0; // endWord not in wordList
        }

        queue&lt;string&gt; q;
        q.push(beginWord);
        unordered_map&lt;string, int&gt; visited;
        visited[beginWord] = 1;

        while (!q.empty()) {
            string currentWord = q.front();
            q.pop();

            if (currentWord == endWord) {
                return visited[currentWord];
            }

            for (int i = 0; i &lt; currentWord.length(); ++i) {
                char originalChar = currentWord[i];
                for (char ch = 'a'; ch &lt;= 'z'; ++ch) {
                    currentWord[i] = ch;
                    if (wordSet.find(currentWord) != wordSet.end() &amp;&amp; visited.find(currentWord) == visited.end()) {
                        q.push(currentWord);
                        visited[currentWord] = visited[beginWord] + 1;
                        wordSet.erase(currentWord);
                    }
                }
                currentWord[i] = originalChar;
            }
        }
        return 0;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(M^2 * N), where M is the length of each word and N is the number of words in the word list. In the worst case, we explore all possible transformations. Each word has M letters, and each letter can be changed to 26 other letters.  We also go through all the words to see if the transformation is valid. | <b>Space Complexity:</b> O(M * N), where M is the length of each word and N is the number of words in the word list. This is mainly due to the queue and the visited set.</p>
  <h5>‚û§ Bidirectional BFS</h5>
  <p>Optimize BFS by running two BFS searches simultaneously: one from `beginWord` and the other from `endWord`. When the two searches intersect, a shortest path is found. This significantly reduces the search space.</p>
  <pre><code class="language-python">#include &ltiostream&gt;
#include &ltvector&gt;
#include &ltstring&gt;
#include &ltunordered_set&gt;
#include &ltqueue&gt;
#include &ltunordered_map&gt;

using namespace std;

class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;& wordList) {
        unordered_set&lt;string&gt; wordSet(wordList.begin(), wordList.end());
        if (wordSet.find(endWord) == wordSet.end()) {
            return 0; // endWord not in wordList
        }

        if (beginWord == endWord) return 1;

        queue&lt;string&gt; q1, q2;
        q1.push(beginWord);
        q2.push(endWord);
        unordered_map&lt;string, int&gt; visited1, visited2;
        visited1[beginWord] = 1;
        visited2[endWord] = 1;

        while (!q1.empty() &amp;&amp; !q2.empty()) {
            int levelSize1 = q1.size();
            for (int i = 0; i &lt; levelSize1; i++) {
                string currentWord = q1.front();
                q1.pop();

                for (int j = 0; j &lt; currentWord.length(); j++) {
                    char originalChar = currentWord[j];
                    for (char ch = 'a'; ch &lt;= 'z'; ch++) {
                        currentWord[j] = ch;
                        if (visited2.count(currentWord)) {
                            return visited1[currentWord] + visited2[currentWord] - 1;
                        }
                        if (wordSet.count(currentWord) &amp;&amp; !visited1.count(currentWord)) {
                            q1.push(currentWord);
                            visited1[currentWord] = visited1[currentWord] + 1;
                        }
                    }
                    currentWord[j] = originalChar;
                }
            }

            swap(q1, q2);
            swap(visited1, visited2);
        }

        return 0;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(M^2 * N), where M is the length of each word and N is the number of words in the word list. However, in practice, it performs significantly better than single-direction BFS because it explores only half of the search space. | <b>Space Complexity:</b> O(M * N), primarily for the queues and the visited maps.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">hit -> hot -> dot -> dog -> cog (5 transformations)</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No transformation sequence exists.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">beginWord = "qa", endWord = "sq", wordList = ["si","go","se","cm","so","ph","mt","db","cq","am","mo","co","pq","mj","fq","nq","gr","qt","bo","mq","ee","mr","sg","gz","zc","ze","pz","az","rs","gn","sq","qy"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">qa -> sq is found with 5 transformations.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The problem can be solved using Breadth-First Search (BFS) or Bidirectional BFS for optimization.
2.  The `beginWord` itself is not considered part of the word ladder, the length is therefore the number of transformations.
3.  Removing visited words from the `wordList` or marking as visited is crucial to prevent cycles.
4.  Bidirectional BFS can significantly improve performance by searching from both `beginWord` and `endWord` simultaneously.
5. Edge case: `endWord` not in `wordList`, return 0.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/minimize-cash-flow-among-given-set-friends-borrowed-money/>Minimize Cash Flow among a given set of friends who borrowed money</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given a set of friends and the amount they have borrowed from each other, find the minimum number of transactions required to settle all debts. The input is a 2D array representing the amount owed between friends (e.g., `graph[i][j]` represents the amount friend `i` owes friend `j`).</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves generating all possible transaction scenarios and selecting the one with the minimum number of transactions. This is achieved by iterating through all possible combinations of debt settlements.  Since the number of combinations grows exponentially with the number of friends, this approach is highly inefficient.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Function to find the minimum number of transactions (Brute Force - Inefficient)
int minCashFlowBruteForce(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int n) {
    // This approach is fundamentally flawed in terms of time complexity.  
    // It's included here for conceptual understanding, but should not be used.
    // This is a placeholder, and a working implementation would be very complex
    // and still have very poor performance characteristics.
    return -1; // Indicate failure or invalid state (as a correct implementation is not practically possible)
}
</code></pre>
  <p><b>Time Complexity:</b> O(exponential). This is because the algorithm needs to explore all possible transaction scenarios, leading to a combinatorial explosion with the number of friends. | <b>Space Complexity:</b> O(1) - Constant space for the basic function, but this completely ignores the massive space complexity of the implied search space</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach (Greedy with Debt Balancing)</h5>
  <p>1.  **Calculate Net Amounts:** For each person, compute the net amount they owe or are owed. Positive values represent amounts owed, and negative values represent amounts owed to them.
2.  **Find Maximum Debtor and Creditor:** Identify the person with the maximum debt (debtor) and the person with the maximum credit (creditor).
3.  **Settle Debt:**  Transfer the minimum of the debtor's debt and the creditor's credit from the debtor to the creditor. This reduces both the debt and credit.
4.  **Update Net Amounts:** Adjust the net amounts of the debtor and creditor.
5.  **Repeat:** Repeat steps 2-4 until all debts are settled (i.e., all net amounts are zero).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Function to find the minimum number of transactions
int minCashFlow(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int n) {
    vector&lt;int&gt; net(n, 0);

    // Calculate net amount for each person
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            net[i] += (graph[j][i] - graph[i][j]); // Person i owes j (graph[j][i]) - Person i is owed by j (graph[i][j])
        }
    }

    // Find maximum debtor and creditor, and process them until debts are cleared.
    int transactions = 0;
    while (true) {
        int debtor = -1, creditor = -1;
        int max_debt = 0, max_credit = 0;

        // Find the debtor (person with most negative net amount)
        for (int i = 0; i &lt; n; i++) {
            if (net[i] &lt; 0 &amp;&amp; net[i] &lt; max_debt) {
                max_debt = net[i];
                debtor = i;
            }
        }

        // Find the creditor (person with most positive net amount)
        for (int i = 0; i &lt; n; i++) {
            if (net[i] &gt; 0 &amp;&amp; net[i] &gt; max_credit) {
                max_credit = net[i];
                creditor = i;
            }
        }

        // If there are no more debtors or creditors, then exit
        if (debtor == -1 || creditor == -1) {
            break;
        }

        // Settle the debt
        int amount = min(-net[debtor], net[creditor]);
        net[debtor] += amount;
        net[creditor] -= amount;
        transactions++;
    }

    return transactions;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) - The nested loops to calculate net amounts and to find debtor and creditor in the while loop dominate the runtime. | <b>Space Complexity:</b> O(n) -  Space used for the `net` vector to store the net amounts.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">graph = {
    {0, 100, 200},
    {0, 0, 100},
    {0, 0, 0}
}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Person 0 owes 100 to person 1 and 200 to person 2.  Person 1 owes 100 to person 2. 
1. Person 0 pays 100 to Person 1.
2. Person 0 pays 200 to person 2. (or Person 1 pays 100 to Person 2, and then Person 0 pays 200 to Person 2).
Total transactions are 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">graph = {
    {0, 1000, 2000},
    {0, 0, 3000},
    {0, 0, 0}
}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Similar to example 1, this illustrates the settlement of debts with larger amounts.  The minimum transactions are 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">graph = {
    {0, 100, 0},
    {0, 0, 100},
    {0, 0, 0}
}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Person 0 owes 100 to Person 1 and Person 1 owes 100 to Person 2. Person 0 pays 100 to Person 1 and Person 1 pays 100 to Person 2.  Or a single transaction of Person 0 paying Person 2 through Person 1 (since Person 1 owes the amount.)</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The problem can be efficiently solved using a greedy approach combined with debt balancing. 
2.  The key to optimization lies in simplifying transactions by identifying debtors and creditors. 
3.  Edge cases include scenarios where there are no debts (all graph values are zero) ‚Äì result will be 0 transactions.  If the graph is not properly constructed (e.g., an inconsistent view of amounts owed/owing between parties), results may vary.
4.  The brute-force approach is computationally prohibitive, especially for a large number of friends.  Avoid it!</p>
</div>
<hr style="margin: 40px 0;">
<h2>Tries</h2>
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/design-add-and-search-words-data-structure/>Design Add and Search Words Data Structure</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Design a data structure that supports adding new words and searching for words. The search can be exact matches or it can use the dot character '.' to represent any letter.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves storing the words and iterating through them during search. For the addWord operation, simply add the word to a list. For the search operation, iterate through the list and compare each word to the search word. If the search word contains a '.', iterate through all possible characters at that position.  </p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class WordDictionary {
public:
    vector&lt;string&gt; words;

    WordDictionary() {

    }

    void addWord(string word) {
        words.push_back(word);
    }

    bool search(string word) {
        for (const string& w : words) {
            if (w.length() != word.length()) continue;
            bool match = true;
            for (int i = 0; i &lt word.length(); ++i) {
                if (word[i] == '.') continue;
                if (w[i] != word[i]) {
                    match = false;
                    break;
                }
            }
            if (match) return true;
        }
        return false;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> addWord: O(1), search: O(N * M) in worst case where N is the number of words and M is the length of the word. | <b>Space Complexity:</b> O(N * M) where N is the number of words and M is the maximum length of the words stored.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Trie with Recursion</h5>
  <p>Use a Trie data structure to store the words. Each node of the Trie represents a character. The `addWord` operation adds the word to the Trie. The `search` operation searches the Trie. If a '.' is encountered, recursively search all possible child nodes.  The use of recursion makes the code cleaner and handles the wildcard matching efficiently.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct TrieNode {
    TrieNode* children[26];
    bool isEndOfWord;

    TrieNode() {
        for (int i = 0; i &lt 26; ++i) {
            children[i] = nullptr;
        }
        isEndOfWord = false;
    }
};

class WordDictionary {
public:
    TrieNode* root;

    WordDictionary() {
        root = new TrieNode();
    }

    void addWord(string word) {
        TrieNode* node = root;
        for (char c : word) {
            int index = c - 'a';
            if (!node-&gt;children[index]) {
                node-&gt;children[index] = new TrieNode();
            }
            node = node-&gt;children[index];
        }
        node-&gt;isEndOfWord = true;
    }

    bool search(string word) {
        return searchHelper(word, 0, root);
    }

    bool searchHelper(string word, int index, TrieNode* node) {
        if (index == word.length()) {
            return node-&gt;isEndOfWord;
        }

        if (word[index] == '.') {
            for (int i = 0; i &lt 26; ++i) {
                if (node-&gt;children[i] &amp;&amp; searchHelper(word, index + 1, node-&gt;children[i])) {
                    return true;
                }
            }
            return false;
        } else {
            int charIndex = word[index] - 'a';
            if (node-&gt;children[charIndex]) {
                return searchHelper(word, index + 1, node-&gt;children[charIndex]);
            } else {
                return false;
            }
        }
    }
};
</code></pre>
  <p><b>Time Complexity:</b> addWord: O(M), search: O(M) in the best and average case, O(26^K * M) in worst case where M is the length of the word and K is the number of '.' characters. | <b>Space Complexity:</b> O(N * M), where N is the number of words and M is the average length of the word.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["WordDictionary","addWord","addWord","search","search","search","search","search"]
[[],["bad"],["dad"],["bad"],["dad"],["mad"],["pad"],["bad"]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[null,null,null,true,true,false,false,true]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The example demonstrates adding words and searching for exact matches and with wildcards.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["WordDictionary","addWord","addWord","search","search"]
[[],["a"],["a"],["a"],["a."]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[null,null,null,true,true]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Adding and searching for single character words, including wildcard searches.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The Trie data structure is crucial for optimizing the search operation, especially with wildcard characters. Recursive implementations provide cleaner and efficient search with wildcards. Edge cases include empty search strings or words with multiple '.' characters.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/word-break-problem-trie-solution/>Word Break Problem | Trie solution</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a string and a dictionary of words, determine if the string can be segmented into a space-separated sequence of one or more dictionary words. The problem explores different approaches including using a Trie data structure to efficiently check for word prefixes.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves generating all possible substrings of the input string and checking if each substring exists in the dictionary. This is done recursively.  If a substring is found in the dictionary, the remaining part of the string is recursively processed.  If the entire string can be broken down into dictionary words, return true; otherwise, return false.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

// Brute Force Approach (Recursive)
bool wordBreakBruteForce(string s, unordered_set&lt;string&gt;&amp; dictionary) {
    if (s.empty()) {
        return true; // Base case: empty string is breakable
    }

    for (int i = 1; i &lt= s.length(); ++i) {
        string prefix = s.substr(0, i);
        if (dictionary.count(prefix) &amp;&amp; wordBreakBruteForce(s.substr(i), dictionary)) {
            return true; // Prefix found and rest is breakable
        }
    }
    return false; // No valid break found
}

// Driver code for testing
// int main() {
//     string s = "ilovesamsung";
//     unordered_set&lt;string&gt; dictionary = {"i", "love", "samsung", "sam", "sung", "il", "like", "ice", "cream", "icecream"};
//     if (wordBreakBruteForce(s, dictionary)) {
//         cout &lt&lt "String can be segmented" &lt&lt endl;
//     } else {
//         cout &lt&lt "String cannot be segmented" &lt&lt endl;
//     }
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(2^n), where n is the length of the string.  In the worst case, we might explore all possible segmentations. | <b>Space Complexity:</b> O(n) in the worst case due to the recursion depth.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming</h5>
  <p>Dynamic programming provides an optimized solution.  We create a boolean array `dp` of size `n+1`, where `n` is the length of the string. `dp[i]` is true if the substring `s[0...i-1]` can be segmented. The base case is `dp[0] = true` (empty string). Iterate through the string, and for each index `i`, iterate backwards from 0 to `i-1`.  If `dp[j]` is true (meaning `s[0...j-1]` is breakable) and the substring `s[j...i-1]` is in the dictionary, then `dp[i]` is true. The result is `dp[n]`.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

// Dynamic Programming Approach
bool wordBreakDP(string s, unordered_set&lt;string&gt;&amp; dictionary) {
    int n = s.length();
    vector&lt;bool&gt; dp(n + 1, false);
    dp[0] = true; // Empty string is breakable

    for (int i = 1; i &lt= n; ++i) {
        for (int j = 0; j &lt i; ++j) {
            if (dp[j]) {
                string sub = s.substr(j, i - j);
                if (dictionary.count(sub)) {
                    dp[i] = true;
                    break; // No need to check further for this i
                }
            }
        }
    }
    return dp[n];
}

// Driver code for testing
// int main() {
//     string s = "ilovesamsung";
//     unordered_set&lt;string&gt; dictionary = {"i", "love", "samsung", "sam", "sung", "il", "like", "ice", "cream", "icecream"};
//     if (wordBreakDP(s, dictionary)) {
//         cout &lt&lt "String can be segmented" &lt&lt endl;
//     } else {
//         cout &lt&lt "String cannot be segmented" &lt&lt endl;
//     }
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(n^2), where n is the length of the string.  Nested loops. | <b>Space Complexity:</b> O(n) for the DP array.</p>
  <h5>‚û§ Trie Approach</h5>
  <p>Using a Trie data structure offers another optimization. The dictionary words are inserted into a Trie. Then, iterate through the input string. For each position, we traverse the Trie to check if there is a valid prefix of the string in the Trie. If it is found, then recursively call the function from that position until we reach the end of the string. A boolean array `dp` is used to store intermediate results to avoid redundant computations. The Trie is built to allow efficient prefix checks.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

struct TrieNode {
    TrieNode* children[26]; // Assuming lowercase English letters
    bool isEndOfWord;
    TrieNode() {
        for (int i = 0; i &lt 26; i++) {
            children[i] = nullptr;
        }
        isEndOfWord = false;
    }
};

// Trie implementation
void insert(TrieNode* root, string word) {
    TrieNode* current = root;
    for (char c : word) {
        int index = c - 'a';
        if (!current-&gtchildren[index]) {
            current-&gtchildren[index] = new TrieNode();
        }
        current = current-&gtchildren[index];
    }
    current-&gtisEndOfWord = true;
}

bool search(TrieNode* root, string word) {
    TrieNode* current = root;
    for (char c : word) {
        int index = c - 'a';
        if (!current-&gtchildren[index]) {
            return false;
        }
        current = current-&gtchildren[index];
    }
    return current-&gtisEndOfWord;
}

bool wordBreakTrie(string s, TrieNode* root, int start, vector&lt;bool&gt;&amp; dp) {
    if (start == s.length()) {
        return true;
    }
    if (dp[start]){
        return true;
    }

    TrieNode* current = root;
    for (int i = start; i &lt s.length(); i++) {
        int index = s[i] - 'a';
        if (!current-&gtchildren[index]) {
            break; // No word exists as a prefix
        }
        current = current-&gtchildren[index];
        if (current-&gtisEndOfWord) {
            if (wordBreakTrie(s, root, i + 1, dp)) {
                dp[start] = true;
                return true;
            }
        }
    }

    dp[start] = false;
    return false;
}

// Driver code for testing
// int main() {
//     string s = "ilovesamsung";
//     vector&lt;string&gt; dictionary = {"i", "love", "samsung", "sam", "sung", "il", "like", "ice", "cream", "icecream"};
//     TrieNode* root = new TrieNode();
//     for(string word : dictionary){
//         insert(root, word);
//     }
//     vector&lt;bool&gt; dp(s.length() + 1, false);
//     if (wordBreakTrie(s, root, 0, dp)) {
//         cout &lt&lt "String can be segmented" &lt&lt endl;
//     } else {
//         cout &lt&lt "String cannot be segmented" &lt&lt endl;
//     }
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(m * n), where n is the length of the string and m is the average length of words in the dictionary. Building the Trie is O(sum of lengths of words in the dictionary). Searching for the word break takes O(n) if a trie is already built. Overall, the dominant term in the worst case can be considered O(n*m). | <b>Space Complexity:</b> O(k), where k is the total number of characters in the dictionary words (space for the Trie).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "leetcode", wordDict = ["leet","code"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">True</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The string "leetcode" can be segmented as "leet code".</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "applepenapple", wordDict = ["apple","pen"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">True</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The string can be segmented as "apple pen apple".</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">False</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The string cannot be segmented.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "ilovesamsung", wordDict = ["i", "love", "samsung", "sam", "sung", "il", "like", "ice", "cream", "icecream"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">True</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The string can be segmented as "i love samsung".</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. The Trie approach is generally more efficient when there are a large number of dictionary words and many prefix matches. 
2. Dynamic Programming is preferred over brute force as it avoids redundant calculations.
3.  The dictionary can contain duplicate words; the problem description does not explicitly forbid duplicates. If the problem were to eliminate duplicates, using an unordered_set for the dictionary would be more efficient.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/trie-insert-and-search/>Trie | (Insert and Search)</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Implement a Trie (Prefix Tree) with the following methods:

*   `insert(word)`: Inserts a word into the trie.
*   `search(word)`: Returns true if the word is in the trie.
*   `startsWith(prefix)`: Returns true if there is any word in the trie that starts with the given prefix.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach would involve storing the words in a list (e.g., a vector or array). 

*   `insert(word)`: Append the word to the list.
*   `search(word)`: Iterate through the list and check if any word matches the given word.
*   `startsWith(prefix)`: Iterate through the list and check if any word starts with the given prefix.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Trie {
public:
    vector&lt;string&gt; words;

    Trie() {}

    void insert(string word) {
        words.push_back(word);
    }

    bool search(string word) {
        for (const string& w : words) {
            if (w == word) {
                return true;
            }
        }
        return false;
    }

    bool startsWith(string prefix) {
        for (const string& w : words) {
            if (w.rfind(prefix, 0) == 0) {
                return true;
            }
        }
        return false;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> insert: O(1), search: O(N), startsWith: O(N), where N is the number of words in the trie. | <b>Space Complexity:</b> O(M), where M is the total number of characters in all inserted words.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Trie Data Structure</h5>
  <p>The optimized approach utilizes the Trie data structure itself.

*   Each node in the Trie represents a character.
*   A node has an array of children (size of the alphabet, usually 26 for lowercase English alphabets). Each index represents a character.
*   Each node has a boolean flag `isEndOfWord` to indicate if the path to that node represents a complete word.

*   `insert(word)`: Traverse the Trie based on the word's characters. If a character's corresponding child node doesn't exist, create it. Mark the last character's node as `isEndOfWord = true`.
*   `search(word)`: Traverse the Trie based on the word's characters. If at any point a character's child doesn't exist, or the traversal reaches the end without hitting `isEndOfWord = true`, return `false`.  Return true if the complete word is present and is marked as end of word.
*   `startsWith(prefix)`: Traverse the Trie based on the prefix's characters. If a character's child doesn't exist, return `false`. Otherwise, return `true`.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct TrieNode {
    TrieNode* children[26]; // Assuming lowercase English alphabets
    bool isEndOfWord;

    TrieNode() {
        isEndOfWord = false;
        for (int i = 0; i &lt; 26; i++) {
            children[i] = nullptr;
        }
    }
};

class Trie {
private:
    TrieNode* root;

public:
    Trie() {
        root = new TrieNode();
    }

    void insert(string word) {
        TrieNode* current = root;
        for (char c : word) {
            int index = c - 'a';
            if (!current-&gt;children[index]) {
                current-&gt;children[index] = new TrieNode();
            }
            current = current-&gt;children[index];
        }
        current-&gt;isEndOfWord = true;
    }

    bool search(string word) {
        TrieNode* current = root;
        for (char c : word) {
            int index = c - 'a';
            if (!current-&gt;children[index]) {
                return false;
            }
            current = current-&gt;children[index];
        }
        return current-&gt;isEndOfWord;
    }

    bool startsWith(string prefix) {
        TrieNode* current = root;
        for (char c : prefix) {
            int index = c - 'a';
            if (!current-&gt;children[index]) {
                return false;
            }
            current = current-&gt;children[index];
        }
        return true;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> insert: O(L), search: O(L), startsWith: O(P), where L is the length of the word and P is the length of the prefix. | <b>Space Complexity:</b> O(M), where M is the total number of characters across all inserted words, where worst case is when no words share prefixes.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">insert("apple"), search("apple"), search("app"), startsWith("app"), insert("app"), search("app")</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true, false, true, true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The example demonstrates the usage of insert, search and startsWith methods.
*   Insert 'apple'
*   Search 'apple' which exists
*   Search 'app' which does not exist, so returns false
*   startsWith 'app' which exists, so returns true
*   Insert 'app'
*   Search 'app' which exists, so returns true</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">insert("banana"), search("banana"), search("ban"), startsWith("ban"), insert("band"), startsWith("band")</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true, false, true, true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Another example to showcase the methods, demonstrating insertion, search and prefix matching.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  **Character Set:** The code assumes lowercase English alphabets.  If different character sets are needed, modify the `children` array size and index calculation accordingly (e.g., Unicode characters will require a larger array or different indexing methods like using a hash map).
2.  **Space Optimization:**  For large datasets, consider using techniques like compressed tries or prefix trees to reduce space usage if the number of words is too large and shares prefixes a lot.
3.  **Memory Management:**  Be mindful of memory leaks. The current implementation uses `new` and might require explicit `delete` operations in a real-world scenario, which is especially important in destructors to free up memory when the Trie object goes out of scope. For simplicity, I haven't explicitly handled memory deallocation here. Smart pointers can also be used for memory management.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/k-anagrams-1/0>K-anagrams</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given two strings s1 and s2 and an integer k, determine if s1 and s2 are k-anagrams of each other. Two strings are k-anagrams if they can be made identical by changing at most k characters in either string.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through s1 and for each character, check how many changes are required to transform s1 into s2 by comparing the character at the same index in s2. Count the mismatches. If the count is less than or equal to k, the strings are k-anagrams.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

bool isKAnagramBruteForce(string s1, string s2, int k) {
    if (s1.length() != s2.length()) {
        return false;
    }
    int n = s1.length();
    int diff = 0;
    for (int i = 0; i &lt n; i++) {
        if (s1[i] != s2[i]) {
            diff++;
        }
    }
    return diff &lt= k;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the length of the strings. The single loop iterates through the strings once. | <b>Space Complexity:</b> O(1), constant space is used.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized using character counts</h5>
  <p>Use hash maps (unordered_map in C++) to store the frequency of each character in both strings.  Iterate through the first string and populate its hash map.  Then iterate through the second string.  For each character in s2, decrement the count in s1's hash map. If a character is not found in s1's hash map or the count becomes negative, increment the change count. If the change count is <= k, return true.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

bool isKAnagram(string s1, string s2, int k) {
    if (s1.length() != s2.length()) {
        return false;
    }
    unordered_map&ltchar, int&gt charCount;
    for (char c : s1) {
        charCount[c]++;
    }
    int diff = 0;
    for (char c : s2) {
        if (charCount.find(c) != charCount.end() &amp;&amp; charCount[c] &gt 0) {
            charCount[c]--;
        } else {
            diff++;
        }
    }
    return diff &lt= k;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the length of the strings.  We iterate through each string twice to build and compare the character counts. | <b>Space Complexity:</b> O(1), as the space used by the hashmap is proportional to the character set which is constant (26 for lowercase English alphabets).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s1 = "anagram", s2 = "grammar", k = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">We can change 'g' to 'a', 'm' to 'n', and 'm' to 'a'. Hence, 3 changes are required which is less than or equal to k.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s1 = "geeksforgeeks", s2 = "geeksfortest", k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">We can change 'r' to 't' and 'e' to 's'. Hence, 2 changes are required which is less than or equal to k.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s1 = "anagram", s2 = "nagaram", k = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Since the strings are anagrams and k is 0, the function returns false.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases: Strings can be empty or of different lengths. If the strings have different lengths, they cannot be k-anagrams.  Character sets are assumed to be ASCII or a limited alphabet to avoid issues with large hashmaps.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/palindrome-pairs/>Palindrome Pairs</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given a list of unique words, return all the pairs of distinct indices (i, j) in the given list, such that the concatenation of words[i] + words[j] is a palindrome.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible pairs of words. For each pair, concatenate the words and check if the resulting string is a palindrome. If it is, add the pair of indices to the result.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool isPalindrome(const string& s) {
    string reversed_s = s;
    reverse(reversed_s.begin(), reversed_s.end());
    return s == reversed_s;
}

vector&lt;vector&lt;int&gt;&gt; palindromePairs_bruteforce(vector&lt;string&gt;&amp; words) {
    vector&lt;vector&lt;int&gt;&gt; result;
    int n = words.size();

    for (int i = 0; i &lt; n; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            if (i == j) continue;
            string combined = words[i] + words[j];
            if (isPalindrome(combined)) {
                result.push_back({i, j});
            }
        }
    }

    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2 * k), where n is the number of words and k is the average length of a word.  The concatenation takes O(k) and palindrome check takes O(k). | <b>Space Complexity:</b> O(1) (excluding the space for the result)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Hash Table with Optimization</h5>
  <p>For each word, consider it as the first or second word in a potential palindrome pair. We can optimize using a hash map to store the words and their indices. 

1.  **Iterate and Reverse:** Iterate through each word in the input list.
2.  **Reverse and Lookup:** Reverse the word.  If the reversed word exists in the hash map (and is not the same word), you have a palindrome pair.
3.  **Split and Check:** For each word, split it into two parts. Check if one of the split parts is a palindrome.  If so, reverse the other part and check if it's in the hash map. This covers cases where the word is a prefix or suffix of a palindrome.
</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool isPalindrome(const string& s) {
    string reversed_s = s;
    reverse(reversed_s.begin(), reversed_s.end());
    return s == reversed_s;
}

vector&lt;vector&lt;int&gt;&gt; palindromePairs_optimized(vector&lt;string&gt;&amp; words) {
    vector&lt;vector&lt;int&gt;&gt; result;
    unordered_map&lt;string, int&gt; wordMap;
    int n = words.size();

    for (int i = 0; i &lt; n; ++i) {
        wordMap[words[i]] = i;
    }

    for (int i = 0; i &lt; n; ++i) {
        // Case 1: reversed word exists
        string reversedWord = words[i];
        reverse(reversedWord.begin(), reversedWord.end());
        if (wordMap.count(reversedWord) &amp;&amp; wordMap[reversedWord] != i) {
            result.push_back({i, wordMap[reversedWord]});
        }

        // Case 2: Splitting and checking prefix
        for (int j = 1; j &lt; words[i].length(); ++j) {
            string left = words[i].substr(0, j);
            string right = words[i].substr(j);
            string reversedLeft = left;
            reverse(reversedLeft.begin(), reversedLeft.end());
            if (isPalindrome(left) &amp;&amp; wordMap.count(reversedWord) ) {
                string reversedRight = right;
                reverse(reversedRight.begin(), reversedRight.end());
                if(wordMap.count(reversedRight) &amp;&amp; wordMap[reversedRight] != i) {
                result.push_back({wordMap[reversedRight], i});
                }
            }

            // Case 3: Splitting and checking suffix
            string reversedRight = right;
            reverse(reversedRight.begin(), reversedRight.end());
            if (isPalindrome(right) &amp;&amp; wordMap.count(reversedWord) ) {
                string reversedLeft = left;
                reverse(reversedLeft.begin(), reversedLeft.end());
                if(wordMap.count(reversedLeft) &amp;&amp; wordMap[reversedLeft] != i) {
                    result.push_back({i, wordMap[reversedLeft]});
                }
            }
        }
    }

    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n * k^2), where n is the number of words and k is the average length of a word.  Iterating through each word takes O(n). Reversing and checking palindrome status takes O(k). Splitting strings and looking up in hashmap takes O(k) and O(1) respectively. Because of these operations, we get O(n*k^2) | <b>Space Complexity:</b> O(n * k) for the hash map. Since the average length of words is k.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["abcd","dcba","lls","s","sssll"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0,1],[1,0],[3,2],[2,4]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The pairs are [("abcd","dcba"),("dcba","abcd"),("s","lls"),("lls","s")]</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["bat","tab","cat"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0,1],[1,0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The palindrome pairs are [("bat","tab"), ("tab","bat")]</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["a","abc","aba",""]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0,3],[3,0],[2,3],[3,2]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The palindrome pairs are [("a"," "), (" ","a"), ("aba"," "),(" ","aba")]</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  Handle the empty string case carefully. It can form palindrome pairs with any palindrome.
2.  Optimize for cases where the reversed word, or a prefix/suffix of a word, forms a palindrome with another word.
3.  Consider edge cases with multiple possible palindrome pairs.
4. Pay attention to edge cases when using hashmap and self-referencing.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/phone-directory/0>Phone directory</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given a list of contacts and a query string, your task is to implement the search suggestion feature.  For each prefix of the query string, find the contacts in the list that start with that prefix. Return a list of lists, where each inner list contains the contacts matching the prefix in lexicographical order.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all prefixes of the query. For each prefix, iterate through the contacts and check if they start with the current prefix. Store the matching contacts in a list and return the list of lists.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

vector&lt;vector&lt;string&gt; &gt; phoneDirectory(vector&lt;string&gt;&amp; contactList, string query) {
    vector&lt;vector&lt;string&gt;&gt; result;
    for (int i = 1; i &lt;= query.length(); ++i) {
        string prefix = query.substr(0, i);
        vector&lt;string&gt; matches;
        for (const string& contact : contactList) {
            if (contact.rfind(prefix, 0) == 0) {
                matches.push_back(contact);
            }
        }
        sort(matches.begin(), matches.end());
        result.push_back(matches);
    }
    return result;
}

int main() {
    int t;
    cin &gt;&gt; t;
    while (t--) {
        int n;
        cin &gt;&gt; n;
        vector&lt;string&gt; contactList(n);
        for (int i = 0; i &lt; n; ++i) {
            cin &gt;&gt; contactList[i];
        }
        string query;
        cin &gt;&gt; query;
        vector&lt;vector&lt;string&gt;&gt; suggestions = phoneDirectory(contactList, query);
        for (const auto& suggestionList : suggestions) {
            for (const string& contact : suggestionList) {
                cout &lt;&lt; contact &lt;&lt; " ";
            }
            cout &lt;&lt; endl;
        }
    }
    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(M * N * K log K), where M is the length of the query, N is the number of contacts, and K is the average number of matching contacts for a prefix. The sorting step dominates the time complexity in the worst case. | <b>Space Complexity:</b> O(K) for storing the matching contacts for a prefix, where K is the number of matching contacts.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized with Trie</h5>
  <p>Build a Trie (prefix tree) from the contact list. For each prefix of the query string, traverse the Trie to find all contacts starting with that prefix. This significantly reduces the search time, especially when there are a large number of contacts. After building the Trie, search for the prefixes of the query string. While traversing the trie, if a node represents a complete word add the word into a vector that's to be returned. Then sort and return the vector.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

struct TrieNode {
    TrieNode* children[26];
    bool isEndOfWord;
    vector&lt;string&gt; words;

    TrieNode() {
        for (int i = 0; i &lt; 26; i++) {
            children[i] = nullptr;
        }
        isEndOfWord = false;
    }
};

void insert(TrieNode* root, string word) {
    TrieNode* node = root;
    for (char ch : word) {
        int index = ch - 'a';
        if (!node-&gt;children[index]) {
            node-&gt;children[index] = new TrieNode();
        }
        node = node-&gt;children[index];
        node-&gt;words.push_back(word);
    }
    node-&gt;isEndOfWord = true;
}

vector&lt;vector&lt;string&gt;&gt; phoneDirectory(vector&lt;string&gt;&amp; contactList, string query) {
    TrieNode* root = new TrieNode();
    for (const string& contact : contactList) {
        insert(root, contact);
    }

    vector&lt;vector&lt;string&gt;&gt; result;
    TrieNode* node = root;
    for (int i = 0; i &lt; query.length(); ++i) {
        int index = query[i] - 'a';
        if (!node || !node-&gt;children[index]) {
            result.push_back({});
            node = nullptr;
        } else {
            node = node-&gt;children[index];
            vector&lt;string&gt; matches = node-&gt;words;
            sort(matches.begin(), matches.end());
            result.push_back(matches);
        }
    }
    return result;
}

int main() {
    int t;
    cin &gt;&gt; t;
    while (t--) {
        int n;
        cin &gt;&gt; n;
        vector&lt;string&gt; contactList(n);
        for (int i = 0; i &lt; n; ++i) {
            cin &gt;&gt; contactList[i];
        }
        string query;
        cin &gt;&gt; query;
        vector&lt;vector&lt;string&gt;&gt; suggestions = phoneDirectory(contactList, query);
        for (const auto& suggestionList : suggestions) {
            for (const string& contact : suggestionList) {
                cout &lt;&lt; contact &lt;&lt; " ";
            }
            cout &lt;&lt; endl;
        }
    }
    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N*K + M*K log K), where N is the total number of characters in all contacts, M is the length of the query, and K is the average number of matches for a prefix.  Building the trie takes O(N*K) time.  Searching for prefixes takes O(M*K log K). | <b>Space Complexity:</b> O(N*K), where N is the total number of characters across all contacts and K is the size of Trie.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">3
abc
abce
abcf
abc</td>
        <td style="border: 1px solid #ccc; padding: 6px;">abc abce abcf 
abce abcf 
abcf 
</td>
        <td style="border: 1px solid #ccc; padding: 6px;">For prefix "a", matches are abc, abce, abcf. For "ab", matches are abc, abce, abcf. For "abc", matches are abc, abce, abcf.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">4
pea
pe
per
person
per</td>
        <td style="border: 1px solid #ccc; padding: 6px;">pe per person 
pe per person 
per person 
person 
</td>
        <td style="border: 1px solid #ccc; padding: 6px;">For prefix "p", matches are pe, per, person. For "pe", matches are pe, per, person. For "per", matches are per, person.  For "pers", matches are person.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Consider the edge cases where the query might be empty or the contact list is empty. Handle cases where no contacts match a prefix. Make sure to sort the results lexicographically. Consider the case where a prefix matches multiple times.</p>
</div>
<hr style="margin: 40px 0;">
<h2>Heaps / PQs</h2>
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/top-k-frequent-elements/>Top K Frequent Elements</a> <span style="font-size:14px; color:#888;">Easy/Medium</span></h3>
  <p>Given an integer array `nums` and an integer `k`, return the `k` most frequent elements. You may return the answer in any order.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Use a hash map to count the frequency of each element. Then, sort the elements based on their frequencies in descending order. Finally, return the top `k` elements.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string arrayToString(const vector&lt;int&gt;& nums) {
    stringstream ss;
    ss &lt&lt "[";
    for (size_t i = 0; i &lt nums.size(); ++i) {
        ss &lt&lt nums[i];
        if (i &lt nums.size() - 1) {
            ss &lt&lt ", ";
        }
    }
    ss &lt&lt "]";
    return ss.str();
}

vector&lt;int&gt; topKFrequentBruteForce(vector&lt;int&gt;& nums, int k) {
    unordered_map&lt;int, int&gt; freq;
    for (int num : nums) {
        freq[num]++;
    }

    vector&lt;pair&lt;int, int&gt;&gt; sortedFreq;
    for (auto const&amp; [key, val] : freq) {
        sortedFreq.push_back({val, key});
    }
    sort(sortedFreq.rbegin(), sortedFreq.rend());

    vector&lt;int&gt; result;
    for (int i = 0; i &lt k; ++i) {
        result.push_back(sortedFreq[i].second);
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N log N), where N is the number of elements in the input array, due to sorting the frequency map. | <b>Space Complexity:</b> O(N) due to the hash map and the sorted array (in the worst case).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Using a Heap (Priority Queue)</h5>
  <p>Use a hash map to count the frequency of each element. Then, use a min-heap to store the elements based on their frequencies. Iterate through the hash map and add elements to the heap. If the heap size exceeds `k`, remove the element with the smallest frequency. Finally, extract the elements from the heap and return them.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string arrayToString(const vector&lt;int&gt;& nums) {
    stringstream ss;
    ss &lt&lt "[";
    for (size_t i = 0; i &lt nums.size(); ++i) {
        ss &lt&lt nums[i];
        if (i &lt nums.size() - 1) {
            ss &lt&lt ", ";
        }
    }
    ss &lt&lt "]";
    return ss.str();
}

vector&lt;int&gt; topKFrequentHeap(vector&lt;int&gt;& nums, int k) {
    unordered_map&lt;int, int&gt; freq;
    for (int num : nums) {
        freq[num]++;
    }

    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;
    for (auto const&amp; [key, val] : freq) {
        pq.push({val, key});
        if (pq.size() &gt k) {
            pq.pop();
        }
    }

    vector&lt;int&gt; result;
    while (!pq.empty()) {
        result.push_back(pq.top().second);
        pq.pop();
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N log k), where N is the number of elements and k is the number of frequent elements to return. Counting frequencies takes O(N).  Building the heap takes O(N log k) in the worst case. | <b>Space Complexity:</b> O(N) to store the frequencies and O(k) for the heap.</p>
  <h5>‚û§ Bucket Sort</h5>
  <p>Count the frequency of each number using a hash map. Create an array of buckets, where the index of each bucket represents a frequency. Add elements to their corresponding buckets. Then, iterate through the buckets from the end (highest frequency) and collect the top `k` elements.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string arrayToString(const vector&lt;int&gt;& nums) {
    stringstream ss;
    ss &lt&lt "[";
    for (size_t i = 0; i &lt nums.size(); ++i) {
        ss &lt&lt nums[i];
        if (i &lt nums.size() - 1) {
            ss &lt&lt ", ";
        }
    }
    ss &lt&lt "]";
    return ss.str();
}

vector&lt;int&gt; topKFrequentBucketSort(vector&lt;int&gt;& nums, int k) {
    unordered_map&lt;int, int&gt; freq;
    for (int num : nums) {
        freq[num]++;
    }

    vector&lt;vector&lt;int&gt;&gt; buckets(nums.size() + 1);
    for (auto const&amp; [num, count] : freq) {
        buckets[count].push_back(num);
    }

    vector&lt;int&gt; result;
    for (int i = buckets.size() - 1; i &gt 0 &amp;&amp; result.size() &lt k; --i) {
        for (int num : buckets[i]) {
            result.push_back(num);
            if (result.size() == k) {
                break;
            }
        }
    }

    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of elements in the input array. Counting frequencies takes O(N), and building and traversing the buckets takes O(N). | <b>Space Complexity:</b> O(N) for the hash map (frequencies) and buckets.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,1,1,2,2,3], k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The elements 1 and 2 are the two most frequent elements.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1], k = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 is the only element and hence the most frequent.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,2], k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 and 2 both appear once.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases include empty input array, `k` being larger than the number of unique elements in the input array, and all elements having the same frequency. The order of the output array does not matter.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/kth-largest-element-in-an-array/>Kth Largest Element in an Array</a> <span style="font-size:14px; color:#888;">Easy/Medium</span></h3>
  <p>Given an integer array `nums` and an integer `k`, return the `k`th largest element in the array. Note that it is the `k`th largest element in the sorted order, not the `k`th distinct element.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Sort the array and return the element at the appropriate index.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string bruteForce(vector&lt;int&gt;&amp; nums, int k) {
  vector&lt;int&gt; sorted_nums = nums;
  sort(sorted_nums.begin(), sorted_nums.end());
  return to_string(sorted_nums[nums.size() - k]);
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log n) due to sorting. | <b>Space Complexity:</b> O(1) or O(n) depending on the sort implementation. In-place sort: O(1).  Copying to a new vector: O(n).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Using a Min-Heap (Priority Queue)</h5>
  <p>Maintain a min-heap of size `k`. Iterate through the array. If the current element is greater than the smallest element in the heap (root), remove the root and insert the current element.  The root of the heap will always be the kth largest element.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string optimizedHeap(vector&lt;int&gt;&amp; nums, int k) {
  priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;
  for (int i = 0; i &lt; nums.size(); ++i) {
    if (i &lt; k) {
      minHeap.push(nums[i]);
    } else {
      if (nums[i] &gt; minHeap.top()) {
        minHeap.pop();
        minHeap.push(nums[i]);
      }
    }
  }
  return to_string(minHeap.top());
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log k) - We iterate through `n` elements and potentially perform log k operations on the heap for each element. | <b>Space Complexity:</b> O(k) - For the min-heap.</p>
  <h5>‚û§ QuickSelect (Partition-based)</h5>
  <p>This algorithm is based on the partition step of the QuickSort algorithm.  We repeatedly partition the array around a pivot, discarding portions that cannot contain the kth largest element. This reduces the search space with each iteration, leading to an average time complexity of O(n). In the worst-case scenario it can be O(n^2), but it's highly unlikely.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int partition(vector&lt;int&gt;&amp; nums, int left, int right) {
    int pivot = nums[right];
    int i = left - 1;
    for (int j = left; j &lt; right; j++) {
        if (nums[j] &gt; pivot) {
            i++;
            swap(nums[i], nums[j]);
        }
    }
    swap(nums[i + 1], nums[right]);
    return i + 1;
}

int quickSelect(vector&lt;int&gt;&amp; nums, int left, int right, int k) {
    if (left == right) {
        return nums[left];
    }
    int pivotIndex = partition(nums, left, right);
    if (k == pivotIndex) {
        return nums[k];
    } else if (k &lt; pivotIndex) {
        return quickSelect(nums, left, pivotIndex - 1, k);
    } else {
        return quickSelect(nums, pivotIndex + 1, right, k);
    }
}

string quickSelectWrapper(vector&lt;int&gt;&amp; nums, int k) {
    int kthLargestIndex = k - 1;
    return to_string(quickSelect(nums, 0, nums.size() - 1, kthLargestIndex));
}
</code></pre>
  <p><b>Time Complexity:</b> Average: O(n), Worst case: O(n^2) | <b>Space Complexity:</b> O(1) - In-place partitioning</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [3,2,1,5,6,4], k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The 2nd largest element is 5.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [3,2,3,1,2,4,5,5,6], k = 4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The 4th largest element is 4.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [3,2,3,1,2,4,5,5,6], k = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The 1st largest element is 6.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The QuickSelect algorithm is generally the most efficient in practice, especially for large datasets, but the min-heap approach is often simpler to implement and understand.  Handle edge cases like empty input array or when k is larger than the array size by returning appropriate default values (e.g., -1 or throwing an exception).</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/ugly-number-ii/>Ugly Number II</a> <span style="font-size:14px; color:#888;">Easy/Medium</span></h3>
  <p>Given an integer n, return the nth ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, and 5.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Generate numbers and check if they are ugly. This involves checking the prime factors for each generated number. We can keep a counter and stop when the counter reaches n.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool isUgly(int n) {
    if (n &lt= 0) return false;
    while (n % 2 == 0) n /= 2;
    while (n % 3 == 0) n /= 3;
    while (n % 5 == 0) n /= 5;
    return n == 1;
}

int nthUglyNumber_bruteForce(int n) {
    if (n &lt= 0) return 0;
    int count = 0, num = 1;
    while (count &lt n) {
        if (isUgly(num)) {
            count++;
        }
        if (count == n) return num;
        num++;
    }
    return -1;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n * m), where n is the input and m is a number of divisions performed in isUgly() method for each number. | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming with Three Pointers</h5>
  <p>Use dynamic programming to store ugly numbers. Maintain three pointers (for 2, 3, and 5) to track the next potential ugly number from each prime factor. The minimum of these candidates is the next ugly number.  Update the corresponding pointer(s) if the chosen number was generated by that factor.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int nthUglyNumber(int n) {
    vector&lt;int&gt; ugly(n);
    ugly[0] = 1;
    int p2 = 0, p3 = 0, p5 = 0;
    for (int i = 1; i &lt n; i++) {
        int next2 = ugly[p2] * 2;
        int next3 = ugly[p3] * 3;
        int next5 = ugly[p5] * 5;
        ugly[i] = min(next2, min(next3, next5));
        if (ugly[i] == next2) p2++;
        if (ugly[i] == next3) p3++;
        if (ugly[i] == next5) p5++;
    }
    return ugly[n - 1];
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) | <b>Space Complexity:</b> O(n)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 10</td>
        <td style="border: 1px solid #ccc; padding: 6px;">12</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The sequence of ugly numbers is 1, 2, 3, 4, 5, 6, 8, 9, 10, 12. Hence, the 10th ugly number is 12.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The sequence of ugly numbers is 1. Hence, the 1st ugly number is 1.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 11</td>
        <td style="border: 1px solid #ccc; padding: 6px;">15</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The sequence of ugly numbers is 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The dynamic programming approach is significantly more efficient than the brute-force approach. The key idea is to build up the sequence of ugly numbers incrementally. The edge case of n=1 should be handled properly.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/furthest-building-you-can-reach/>Furthest Building You Can Reach</a> <span style="font-size:14px; color:#888;">Easy/Medium</span></h3>
  <p>You are given an array of integers heights representing the heights of buildings, some bricks, and some ladders. You start at building 0 and want to reach the furthest building. You can move from building i to building i+1 if: 

1.  The height of building i+1 is less than or equal to the height of building i, you can just walk.
2.  If the height of building i+1 is greater than the height of building i, you can either use a ladder or use some bricks.

If you use a ladder, you do not need to use any bricks.
If you use bricks, you need to use (height[i+1] - height[i]) bricks.
Return the furthest building index you can reach if you use the given ladders and bricks optimally.
</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves exploring all possible combinations of using ladders and bricks for each jump. For each jump, we can either use a ladder, use bricks, or simply walk (if the next building is lower or equal). This approach uses recursion or backtracking to try all possibilities. However, this is inefficient because it recalculates the same subproblems multiple times, leading to exponential time complexity.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int furthestBuildingBruteForce(vector&lt;int&gt;&amp; heights, int bricks, int ladders, int index) {
    if (index == heights.size() - 1) {
        return index;
    }
    int jump = heights[index + 1] - heights[index];
    if (jump &lt;= 0) {
        return furthestBuildingBruteForce(heights, bricks, ladders, index + 1);
    }
    int furthestIndex = index;
    // Use ladder
    if (ladders &gt; 0) {
        furthestIndex = max(furthestIndex, furthestBuildingBruteForce(heights, bricks, ladders - 1, index + 1));
    }
    // Use bricks
    if (bricks &gt;= jump) {
        furthestIndex = max(furthestIndex, furthestBuildingBruteForce(heights, bricks - jump, ladders, index + 1));
    }
    return furthestIndex;
}

int furthestBuildingBruteForceWrapper(vector&lt;int&gt;&amp; heights, int bricks, int ladders) {
    return furthestBuildingBruteForce(heights, bricks, ladders, 0);
}
</code></pre>
  <p><b>Time Complexity:</b> O(2^N), where N is the number of buildings. In the worst case, we have a binary tree of possibilities. | <b>Space Complexity:</b> O(N) due to the recursive call stack.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Greedy Approach with Priority Queue</h5>
  <p>This approach uses a priority queue (min-heap) to keep track of the height differences where we've used bricks. When we encounter a jump, we first check if we have enough ladders. If we do, we use a ladder. If we don't have enough ladders, we use bricks. If we've previously used bricks, and the current jump requires more bricks than a past jump, then we swap the brick usage from current jump to the past jump and now we use a ladder for current jump and use bricks to previous smaller jump. This minimizes the total bricks needed.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int furthestBuilding(vector&lt;int&gt;&amp; heights, int bricks, int ladders) {
    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq; // Min-heap for brick usage
    for (int i = 0; i &lt; heights.size() - 1; ++i) {
        int diff = heights[i + 1] - heights[i];
        if (diff &gt; 0) {
            pq.push(diff);
            if (pq.size() &gt; ladders) {
                int bricksNeeded = pq.top();
                pq.pop();
                if (bricks &gt;= bricksNeeded) {
                    bricks -= bricksNeeded;
                } else {
                    return i;
                }
            }
        }
    }
    return heights.size() - 1;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N log L), where N is the number of buildings and L is the number of ladders. The log factor comes from the priority queue operations. | <b>Space Complexity:</b> O(L), for the priority queue to store at most L elements (jumps where ladders were used).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Using ladders, we use it for building 4 -> 5 as height difference is 9 - 6 = 3 so now use bricks for building 5 -> 6. The maximum index we can reach is 4 because we can only reach the 5th building with all the bricks and ladders.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">7</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Using 2 ladders and 10 bricks is sufficient.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">heights = [14,3,19,3,3,7,2,19,13], bricks = 17, ladders = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">7</td>
        <td style="border: 1px solid #ccc; padding: 6px;">We reach the 8th building, where we can't make the jump. We used all of our bricks till there.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Important edge cases include when there are no height differences or no resources (bricks or ladders) available. The optimal solution uses a greedy approach, which works because using ladders for the largest height differences maximizes the distance that can be covered with bricks. Also, consider what happens if the given bricks and ladders are not enough to reach the end; return the furthest building that can be reached in those cases.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/>Kth Smallest Element in a Sorted Matrix</a> <span style="font-size:14px; color:#888;">Easy/Medium</span></h3>
  <p>Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Flatten the 2D matrix into a 1D array, sort the 1D array, and return the element at index k-1.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string bruteForce(vector&lt;vector&lt;int&gt;&gt;& matrix, int k) {
    int n = matrix.size();
    vector&lt;int&gt; arr;
    for (int i = 0; i &lt; n; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            arr.push_back(matrix[i][j]);
        }
    }
    sort(arr.begin(), arr.end());
    return to_string(arr[k - 1]);
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2 log(n^2)) due to sorting the flattened array. | <b>Space Complexity:</b> O(n^2) for storing the flattened array.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Binary Search</h5>
  <p>Perform binary search on the range of values in the matrix.  For each mid value, count the number of elements in the matrix that are less than or equal to mid. Adjust the search space based on whether the count is less than, equal to, or greater than k.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int countLessThanOrEqual(vector&lt;vector&lt;int&gt;&gt;& matrix, int mid) {
    int n = matrix.size();
    int count = 0;
    int row = 0, col = n - 1;
    while (row &lt; n &amp;&amp; col &gt;= 0) {
        if (matrix[row][col] &lt;= mid) {
            count += col + 1;
            row++;
        } else {
            col--;
        }
    }
    return count;
}

string binarySearch(vector&lt;vector&lt;int&gt;&gt;& matrix, int k) {
    int n = matrix.size();
    int left = matrix[0][0], right = matrix[n - 1][n - 1];
    while (left &lt; right) {
        int mid = left + (right - left) / 2;
        int count = countLessThanOrEqual(matrix, mid);
        if (count &lt; k) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return to_string(left);
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log(range)), where range is the difference between the smallest and largest element in the matrix. CountLessThanOrEqual is O(n), and it is done in a binary search loop that takes O(log(range)) time. | <b>Space Complexity:</b> O(1) - Constant extra space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8</td>
        <td style="border: 1px solid #ccc; padding: 6px;">13</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The sorted matrix is [1,5,9,10,11,12,13,13,15]. The 8th smallest element is 13.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">matrix = [[-5]], k = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The matrix contains only one element. The 1st smallest element is -5.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">matrix = [[1,2],[1,3]], k = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The sorted matrix is [1,1,2,3]. The 3rd smallest element is 2.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases: Empty matrix (though the problem description implies it won't be), and duplicate values are possible.  The binary search approach efficiently handles both cases. The range of values can be very large, so the brute-force method may be inefficient.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/reorganize-string/>Reorganize String</a> <span style="font-size:14px; color:#888;">Easy/Medium</span></h3>
  <p>Given a string `s`, rearrange the string such that no two adjacent characters are the same. Return the rearranged string. If it is not possible to rearrange the string, return an empty string.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Generate all permutations of the string. For each permutation, check if it satisfies the condition (no two adjacent characters are the same). Return the first valid permutation found. This approach is highly inefficient.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Brute Force - NOT RECOMMENDED
string reorganizeStringBruteForce(string s) {
    sort(s.begin(), s.end());
    do {
        bool valid = true;
        for (int i = 0; i &lt s.length() - 1; ++i) {
            if (s[i] == s[i + 1]) {
                valid = false;
                break;
            }
        }
        if (valid) {
            return s;
        }
    } while (next_permutation(s.begin(), s.end()));
    return "";
}
</code></pre>
  <p><b>Time Complexity:</b> O(n! * n), where n is the length of the string.  Generating permutations is O(n!), and checking each permutation takes O(n) time. | <b>Space Complexity:</b> O(n) for storing the permutations and potentially the recursive call stack during permutation generation.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Greedy with Priority Queue</h5>
  <p>1. Count the frequency of each character.
2. Use a priority queue (max-heap) to store characters based on their frequency.
3. Pop the character with the highest frequency. Append it to the result.
4. Pop the next highest frequency character (if it exists, preventing adjacent duplicates). Append it to the result.
5. Push the previously popped characters back to the priority queue if their frequency is greater than 0.
6. Repeat steps 3-5 until the queue is empty.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

string reorganizeString(string s) {
    unordered_map&ltchar, int&gt; counts;
    for (char c : s) {
        counts[c]++;
    }

    priority_queue&ltpair&ltint, char&gt;&gt; pq;
    for (auto const&amp; [key, val] : counts) {
        pq.push({val, key});
    }

    string result = "";
    while (!pq.empty()) {
        auto top1 = pq.top();
        pq.pop();
        if (result.length() &gt 0 &amp;&amp; top1.second == result.back()) {
            if (pq.empty()) {
                return "";
            }
            auto top2 = pq.top();
            pq.pop();
            result += top2.second;
            if (top2.first &gt 1) {
                pq.push({top2.first - 1, top2.second});
            }
            pq.push(top1);
        } else {
             result += top1.second;
             if (top1.first &gt 1) {
                pq.push({top1.first - 1, top1.second});
            }
        }
    }

    for(int i = 1; i &lt result.length(); i++){
        if(result[i] == result[i-1]) return "";
    }

    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log k), where n is the length of the string, and k is the number of unique characters (at most 26). The priority queue operations (push and pop) take O(log k) time, and we do them at most n times. | <b>Space Complexity:</b> O(k), where k is the number of unique characters, for the hash map and the priority queue.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">aab</td>
        <td style="border: 1px solid #ccc; padding: 6px;">aba</td>
        <td style="border: 1px solid #ccc; padding: 6px;">One possible result is "aba".</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">aaab</td>
        <td style="border: 1px solid #ccc; padding: 6px;"></td>
        <td style="border: 1px solid #ccc; padding: 6px;">It is not possible to rearrange the string to avoid adjacent repeating characters.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">vvvlo</td>
        <td style="border: 1px solid #ccc; padding: 6px;">vlvov</td>
        <td style="border: 1px solid #ccc; padding: 6px;">One possible rearrangement is "vlvov".</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The character with the highest frequency must not exceed (n+1)/2, where n is the length of the string. If it does, a valid rearrangement is impossible.
2. The greedy approach with the priority queue efficiently prioritizes the most frequent characters to avoid adjacent repetitions.
3. The check for the last character is crucial to ensure that adjacent characters are distinct in the resulting string.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/find-the-most-competitive-subsequence/>Find the Most Competitive Subsequence</a> <span style="font-size:14px; color:#888;">Easy/Medium</span></h3>
  <p>Given an array `nums` and an integer `k`, return the most competitive subsequence of `nums` of length `k`. 

A subsequence of an array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. For example, `[1,3,5]` is a subsequence of `[1,2,3,4,5]`. 

An array `a` is more competitive than an array `b` if in the first position where `a` and `b` differ, array `a` has a smaller value. For example, `[1,2,3]` is more competitive than `[1,3,2]`.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Generate all possible subsequences of length `k`. For each subsequence, compare them lexicographically (element by element) and keep track of the most competitive one. This is highly inefficient.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Brute Force approach (inefficient)
vector&lt;int&gt; mostCompetitiveBruteForce(vector&lt;int&gt;&amp; nums, int k) {
    int n = nums.size();
    vector&lt;int&gt; result;
    if (k &gt; n) return result; 

    vector&lt;vector&lt;int&gt;&gt; subsequences;

    for (int i = 0; i &lt; (1 &lt;&lt; n); ++i) {
        vector&lt;int&gt; subsequence;
        int count = 0;
        for (int j = 0; j &lt; n; ++j) {
            if ((i &gt;&gt; j) &amp; 1) {
                subsequence.push_back(nums[j]);
                count++;
            }
        }
        if (count == k) {
            subsequences.push_back(subsequence);
        }
    }

    if (subsequences.empty()) return result;

    result = subsequences[0];
    for (int i = 1; i &lt; subsequences.size(); ++i) {
        if (subsequences[i] &lt; result) {
            result = subsequences[i];
        }
    }

    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(2^n * k), where n is the size of nums. We generate 2^n subsequences, and comparing each of length k takes O(k) time. Generation takes O(n) to construct the subsequence. | <b>Space Complexity:</b> O(2^n * k) in worst case to store all subsequences.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Stack-based Approach</h5>
  <p>Iterate through the input array `nums`. Maintain a stack to build the subsequence.  For each number `nums[i]`, compare it with the top of the stack. If `nums[i]` is smaller than the top of the stack AND there are enough remaining elements in `nums` to build a subsequence of length `k`, pop the top element from the stack. Push `nums[i]` onto the stack. The stack maintains the most competitive subsequence seen so far. After the iteration, resize the stack to length `k`.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

vector&lt;int&gt; mostCompetitive(vector&lt;int&gt;&amp; nums, int k) {
    int n = nums.size();
    vector&lt;int&gt; result;
    if (k &gt; n) return result;

    vector&lt;int&gt; stack;
    int remaining = n - k;

    for (int i = 0; i &lt; n; ++i) {
        while (!stack.empty() &amp;&amp; nums[i] &lt; stack.back() &amp;&amp; remaining &gt; 0) {
            stack.pop_back();
            remaining--;
        }
        if (stack.size() &lt; k) {
            stack.push_back(nums[i]);
        } else {
          remaining--; //Decrementing remaining if stack is full and we are skipping nums[i]
        }
    }

    return stack;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the size of nums. We iterate through the array once. The while loop within the loop can pop elements at most n times.  Therefore the amortized time complexity is O(n). | <b>Space Complexity:</b> O(k), where k is the length of the subsequence. In the worst case the stack stores k elements.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [3,5,2,6], k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[2,6]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Choosing index 2 and 3 will form the most competitive subsequence. Subsequences [3, 5], [3, 2], [3, 6], [5, 2], [5, 6], [2, 6]. Comparing these will result in [2,6]</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [2,4,3,3,5,4,9,6], k = 4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[2,3,3,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The subsequence [2,3,3,4] is the most competitive</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [71,18,52,29,55,70,28,87,3,91,65,95,31,93,8,17,90,98,38,54,9,76,22,11,51,43,35,83,85,36,44,72,13,97,39,81,67,56,74,78,86,15,47,2,33,66,42,59,40,69,48,30,7,26,1,41,12,27,10,21,20,25,96,24,77,62,16,88,46,50,80,57,61,32,4,19,84,64,37,63,45,73,53,68,99,82,75,6,92,58,94,23,14,89,49,5], k = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1, 2, 3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The most competitive subseq of length 3</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to this problem is to understand how the 'competitive' condition defines the subsequence. The stack-based approach efficiently leverages this property to build the most competitive subsequence at each step.  Edge cases: `k` can be equal to `n`, and the input array can contain duplicate elements, which should be handled correctly.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/smallest-positive-missing-number-1587115621/1/>Smallest positive missing number</a> <span style="font-size:14px; color:#888;">Easy/Medium</span></h3>
  <p>Given an array arr[] of size N. The task is to find the smallest positive missing number from the array.

In other words, you need to find the smallest positive integer that is NOT present in the array. The array may contain duplicates, negative numbers, and zeros.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate from 1 onwards and check if each number is present in the array. The first number that is not found is the smallest missing positive number.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int missingNumberBruteForce(int arr[], int n) {
    for (int i = 1; ; ++i) {
        bool found = false;
        for (int j = 0; j &lt n; ++j) {
            if (arr[j] == i) {
                found = true;
                break;
            }
        }
        if (!found) {
            return i;
        }
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(N^2) - In the worst-case scenario, for each positive integer, we iterate through the entire array. | <b>Space Complexity:</b> O(1) - Constant extra space is used.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Using Hashing (Sets)</h5>
  <p>1. Create a set to store all positive numbers from the array.
2. Iterate from 1 onwards and check if each number is present in the set. The first number that is not found is the smallest missing positive number.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int missingNumberHashing(int arr[], int n) {
    unordered_set&lt;int&gt; s;
    for (int i = 0; i &lt n; ++i) {
        if (arr[i] &gt 0) {
            s.insert(arr[i]);
        }
    }
    for (int i = 1; ; ++i) {
        if (s.find(i) == s.end()) {
            return i;
        }
    }
}
</code></pre>
  <p><b>Time Complexity:</b> O(N) - In the worst case, we iterate through the array once to build the set, and then we iterate potentially up to N to find the missing number. | <b>Space Complexity:</b> O(N) - The set can store up to N distinct positive numbers.</p>
  <h5>‚û§ In-place Rearrangement and Marking</h5>
  <p>1.  **Preprocessing:** Iterate through the array.  If a number is outside the range [1, N], replace it with N+1 (or any value greater than N) since it is irrelevant to the solution.
2.  **Marking:** Iterate through the array again. For each number `arr[i]`, if the absolute value of `arr[i]` is within the range [1, N], and the element at index `abs(arr[i]) - 1` is positive, change the element at `arr[abs(arr[i]) - 1]` to negative. This marks that the number `abs(arr[i])` is present.
3.  **Finding Missing:** Iterate through the array. The first index `i` for which `arr[i]` is positive indicates that `i + 1` is the smallest missing positive number.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int missingNumberOptimized(int arr[], int n) {
    // Preprocessing: Replace irrelevant numbers
    for (int i = 0; i &lt n; ++i) {
        if (arr[i] &lt= 0 || arr[i] &gt n) {
            arr[i] = n + 1;
        }
    }

    // Marking: Use sign of elements as a hash key
    for (int i = 0; i &lt n; ++i) {
        int num = abs(arr[i]);
        if (num &lt= n && arr[num - 1] &gt 0) {
            arr[num - 1] *= -1;
        }
    }

    // Finding Missing
    for (int i = 0; i &lt n; ++i) {
        if (arr[i] &gt 0) {
            return i + 1;
        }
    }

    return n + 1;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N) - Three passes through the array. | <b>Space Complexity:</b> O(1) - Constant extra space is used (in-place modification).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr[] = {1, 2, 3, 4, 5}; N = 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">All positive integers from 1 to 5 are present. The smallest missing positive integer is 6.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr[] = {0, -1, 3, 1, 4, 2}; N = 6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The missing number is 5.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr[] = {1, 2, 0}; N = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The missing number is 3.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr[] = {7, 8, 9, 11, 12}; N = 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The smallest missing positive integer is 1, because it is not in the array.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr[] = {1, 2, 2, 3, 3}; N = 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The missing number is 4.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. The in-place approach is the most space-efficient.  
2.  Handle edge cases such as all negative numbers or all numbers greater than N.
3.  The in-place method modifies the input array. If the original array needs to be preserved, a copy should be created before processing.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/largest-subarray-with-0-sum/1/>Largest subarray with 0 sum</a> <span style="font-size:14px; color:#888;">Easy/Medium</span></h3>
  <p>Given an array of integers, find the length of the largest subarray with a sum of 0.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible subarrays and check if their sum is zero. Keep track of the maximum length found so far.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int maxLen(int arr[], int n) {
    int maxLength = 0;
    for (int i = 0; i &lt n; ++i) {
        for (int j = i; j &lt n; ++j) {
            int currentSum = 0;
            for (int k = i; k &lt= j; ++k) {
                currentSum += arr[k];
            }
            if (currentSum == 0) {
                maxLength = max(maxLength, j - i + 1);
            }
        }
    }
    return maxLength;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^3) - Three nested loops are used to calculate the sum of each subarray. | <b>Space Complexity:</b> O(1) - Constant extra space is used.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Using Hash Map</h5>
  <p>Use a hash map to store the prefix sums and their corresponding indices. If a prefix sum is repeated, it means the sum of elements between the two occurrences is zero. Calculate the length of this subarray and update the maximum length.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int maxLen(int arr[], int n) {
    unordered_map&lt;int, int&gt; sumMap;
    int maxLength = 0;
    int currentSum = 0;

    for (int i = 0; i &lt n; ++i) {
        currentSum += arr[i];

        if (currentSum == 0) {
            maxLength = i + 1;
        }
        else {
            if (sumMap.find(currentSum) != sumMap.end()) {
                maxLength = max(maxLength, i - sumMap[currentSum]);
            }
            else {
                sumMap[currentSum] = i;
            }
        }
    }

    return maxLength;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) - The array is traversed only once. | <b>Space Complexity:</b> O(n) - In the worst case, the hash map can store all prefix sums.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr[] = {15, -2, 2, -8, 1, 7, 10, 23}; n = 8</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The largest subarray with sum 0 is {-2, 2, -8, 1, 7}</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr[] = {0, 0, 0, 0}; n = 4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The entire array has a sum of 0.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr[] = {1, 2, 3}; n = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No subarray sums to zero.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The hash map approach is significantly more efficient than the brute-force approach. The key to solving this problem efficiently is to realize that a subarray sum of zero implies that the prefix sums at the start and end of the subarray are the same.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/k-closest-points-to-origin/>K Closest Points to Origin</a> <span style="font-size:14px; color:#888;">Easy/Medium</span></h3>
  <p>Given an array of points where each point is represented as (x, y), and an integer k, return the k closest points to the origin (0, 0). The distance between two points (x1, y1) and (x2, y2) is the Euclidean distance: sqrt((x1 - x2)^2 + (y1 - y2)^2). You can return the answer in any order.  The size of the input array can be variable, and the value of k will always be a valid number that is less than or equal to the number of points.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Calculate the distance of each point from the origin. Store the points and their distances in a map or vector. Sort the points based on their distances. Return the first k points.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;

using namespace std;

// Function to calculate Euclidean distance from origin
double distance(int x, int y) {
    return sqrt(x * x + y * y);
}

vector&lt;vector&lt;int&gt;&gt; kClosestBruteForce(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) {
    map&lt;double, vector&lt;int&gt;&gt; distances;
    for (const auto&amp; point : points) {
        double dist = distance(point[0], point[1]);
        distances[dist] = point;
    }

    vector&lt;pair&lt;double, vector&lt;int&gt;&gt;&gt; sortedDistances;
    for (const auto&amp; [dist, point] : distances) {
        sortedDistances.push_back({dist, point});
    }

    sort(sortedDistances.begin(), sortedDistances.end());

    vector&lt;vector&lt;int&gt;&gt; result;
    for (int i = 0; i &lt; k &amp;&amp; i &lt; sortedDistances.size(); ++i) {
        result.push_back(sortedDistances[i].second);
    }

    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log n) due to sorting, where n is the number of points. | <b>Space Complexity:</b> O(n) to store distances and points.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Using Priority Queue (Min-Heap)</h5>
  <p>Calculate the distance of each point from the origin. Use a max-heap (priority queue) to store the k closest points. Iterate through the points.  If the heap size is less than k, add the current point. If the heap size is k and the current point's distance is less than the farthest point in the heap (root of the max-heap), remove the farthest point and add the current point. Finally, return the points in the heap.  This approach avoids sorting all the elements and efficiently keeps track of k closest points.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;  // Required for sort

using namespace std;

// Function to calculate Euclidean distance from origin
double distance(int x, int y) {
    return sqrt(x * x + y * y);
}

struct PointDistance {
    int x, y;
    double dist;

    PointDistance(int x, int y) : x(x), y(y), dist(distance(x, y)) {}

    bool operator&lt;(const PointDistance& other) const {
        return dist &lt; other.dist; // Min-Heap, reverse condition
    }
};

vector&lt;vector&lt;int&gt;&gt; kClosestPriorityQueue(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) {
    priority_queue&lt;pair&lt;double, vector&lt;int&gt;&gt;, vector&lt;pair&lt;double, vector&lt;int&gt;&gt;&gt;, less&lt;pair&lt;double, vector&lt;int&gt;&gt;&gt;&gt; maxHeap;

    for (const auto&amp; point : points) {
        double dist = distance(point[0], point[1]);
        maxHeap.push({dist, {point[0], point[1]}});

        if (maxHeap.size() &gt; k) {
            maxHeap.pop();
        }
    }

    vector&lt;vector&lt;int&gt;&gt; result;
    while (!maxHeap.empty()) {
        result.push_back({(int)maxHeap.top().second[0], (int)maxHeap.top().second[1]});
        maxHeap.pop();
    }

    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log k), where n is the number of points.  Each point is processed in O(log k) time (insertion or potential replacement in the priority queue). | <b>Space Complexity:</b> O(k) to store the priority queue.</p>
  <h5>‚û§ Quickselect</h5>
  <p>Use the Quickselect algorithm to find the k-th smallest distance. Quickselect is similar to Quicksort but only recurses on one side of the partition. After finding the k-th smallest distance, iterate through the points and collect all points with distances less than or equal to the k-th smallest distance.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;

using namespace std;

// Function to calculate Euclidean distance from origin
double distance(int x, int y) {
    return sqrt(x * x + y * y);
}

int partition(vector&lt;vector&lt;int&gt;&gt;&amp; points, int left, int right, vector&lt;double&gt;&amp; distances) {
    double pivot = distances[right];
    int i = left - 1;
    for (int j = left; j &lt; right; j++) {
        if (distances[j] &lt;= pivot) {
            i++;
            swap(distances[i], distances[j]);
            swap(points[i], points[j]);
        }
    }
    swap(distances[i + 1], distances[right]);
    swap(points[i + 1], points[right]);
    return i + 1;
}

double quickselect(vector&lt;vector&lt;int&gt;&gt;&amp; points, int left, int right, int k, vector&lt;double&gt;&amp; distances) {
    if (left == right) {
        return distances[left];
    }

    int partitionIndex = partition(points, left, right, distances);

    if (k == partitionIndex) {
        return distances[k];
    } else if (k &lt; partitionIndex) {
        return quickselect(points, left, partitionIndex - 1, k, distances);
    } else {
        return quickselect(points, partitionIndex + 1, right, k, distances);
    }
}

vector&lt;vector&lt;int&gt;&gt; kClosestQuickselect(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) {
    int n = points.size();
    vector&lt;double&gt; distances(n);
    for (int i = 0; i &lt; n; ++i) {
        distances[i] = distance(points[i][0], points[i][1]);
    }

    quickselect(points, 0, n - 1, k, distances);

    vector&lt;vector&lt;int&gt;&gt; result;
    for (int i = 0; i &lt; n; ++i) {
        if (distances[i] &lt;= distances[k -1]) {
                result.push_back(points[i]);
        }
    }

    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) on average for Quickselect, but O(n^2) in the worst case.  The final step to collect the result is O(n).  So, the average time complexity is O(n). | <b>Space Complexity:</b> O(n) to store distances and to hold the points.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">points = [[1,3],[-2,2]], k = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[-2,2]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The distance from (1, 3) to the origin is sqrt(10). The distance from (-2, 2) to the origin is sqrt(8). Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin. We need to return 1 point, so we return [[-2, 2]].</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">points = [[3,3],[5,-1],[-2,4]], k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[3,3],[-2,4]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The distance from (3, 3) to the origin is sqrt(18). The distance from (5, -1) to the origin is sqrt(26). The distance from (-2, 4) to the origin is sqrt(20).  The 2 closest points are (3, 3) and (-2, 4).</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases include empty input array, k = 0, and k greater than the number of points. The coordinates can be positive or negative integers. When using the priority queue, make sure it's a min-heap.  For the Quickselect solution, the returned result may not be sorted based on the distance. If the input contains many points with the same distance from the origin, the Quickselect method may choose different points than the Priority Queue method.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/minimum-number-of-refueling-stops/>Minimum Number of Refueling Stops</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>A car travels from a starting position to a destination with a certain amount of fuel. Along the way, there are gas stations where the car can refuel. The goal is to determine the minimum number of refueling stops needed to reach the destination. You are given the destination, starting fuel, a list of gas stations (represented as pairs: distance from start, amount of fuel), and you need to return the minimum number of stops needed, or -1 if the destination cannot be reached.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>This approach explores all possible combinations of refueling stops. For each gas station, we have two choices: either refuel at that station or skip it. We recursively explore these choices, keeping track of the fuel level and the number of stops. This approach is highly inefficient as it explores all possible paths.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

int minRefuelStopsBruteForce(int target, int startFuel, vector&lt;vector&lt;int&gt;&gt;& stations) {
    int n = stations.size();
    int minStops = INT_MAX;

    function&lt;void(int, int, int)&gt; solve = [&](int fuel, int index, int stops) {
        if (fuel &lt 0) return;
        if (fuel &gt;= target) {
            minStops = min(minStops, stops);
            return;
        }
        if (index == n) {
            if (fuel &gt;= target) {
                minStops = min(minStops, stops);
            }
            return;
        }

        // Option 1: Skip the station
        solve(fuel, index + 1, stops);

        // Option 2: Refuel at the station
        solve(fuel - stations[index][0] + startFuel, index + 1, stops + 1);

    };

    solve(startFuel, 0, 0);

    return minStops == INT_MAX ? -1 : minStops;
}
</code></pre>
  <p><b>Time Complexity:</b> O(2^N), where N is the number of stations.  The algorithm explores all possible combinations of stops. | <b>Space Complexity:</b> O(N) in the worst case due to the recursive call stack.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming (DP)</h5>
  <p>This approach uses dynamic programming to solve the problem efficiently. We use a DP array where dp[i] represents the maximum distance we can reach with 'i' refueling stops. We iterate through each gas station and update the dp array based on whether we can reach the station with the given fuel and how much fuel we gain at the station. The answer is the smallest 'i' for which dp[i] >= target.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

int minRefuelStopsDP(int target, int startFuel, vector&lt;vector&lt;int&gt;&gt;& stations) {
    int n = stations.size();
    vector&lt;long long&gt; dp(n + 1, 0);
    dp[0] = startFuel;
    for (int i = 0; i &lt; n; ++i) {
        for (int j = i; j &gt;= 0; --j) {
            if (dp[j] &gt;= stations[i][0]) {
                dp[j + 1] = max(dp[j + 1], dp[j] + (long long)stations[i][1]);
            }
        }
    }

    for (int i = 0; i &lt;= n; ++i) {
        if (dp[i] &gt;= target) {
            return i;
        }
    }
    return -1;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N^2), where N is the number of stations. We have nested loops, one iterating through the stations and the other for the DP updates. | <b>Space Complexity:</b> O(N), for the DP array.</p>
  <h5>‚û§ Greedy with Priority Queue</h5>
  <p>This approach utilizes a priority queue (max-heap) to greedily select the stations to refuel at. We iterate through the stations, adding them to the priority queue if we can reach them. At each stop, we refuel with the station that gives us the most fuel. If we cannot reach the next station, we check if we can refuel using the priority queue; if we can refuel using a station in the queue, we add it to the number of stops. If the queue is empty and we can't reach the next station, we return -1.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

int minRefuelStopsPQ(int target, int startFuel, vector&lt;vector&lt;int&gt;&gt;& stations) {
    int n = stations.size();
    priority_queue&lt;int&gt; pq;
    int stops = 0, currFuel = startFuel, i = 0;
    int dest = target;

    while (currFuel &lt dest) {
        while (i &lt; n &amp;&amp; stations[i][0] &lt;= currFuel) {
            pq.push(stations[i][1]);
            i++;
        }
        if (pq.empty()) {
            if (currFuel &lt dest) return -1;
        }
        currFuel += pq.top();
        pq.pop();
        stops++;
    }
    return stops;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N log N) due to the use of the priority queue, where N is the number of gas stations. | <b>Space Complexity:</b> O(N) for the priority queue in the worst case.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">We can reach station 1, then station 3, using 2 stops.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Optimal route is to stop at station 1 and then station 3, thus returning 2 stops.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">target = 100, startFuel = 1, stations = [[10,100]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">We can't reach station 1 even with a stop, and can't reach the destination.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases include:  No stations, insufficient starting fuel, and unreachable destination. The greedy approach is generally the most efficient for this problem. Be careful about integer overflow and the correct application of greedy choices.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/minimum-cost-to-hire-k-workers/>Minimum Cost to Hire K Workers</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>There are n workers. You are given two arrays: quality and wage, where quality[i] is the quality of the i-th worker and wage[i] is the wage of the i-th worker. Now, we want to hire exactly k workers to form a paid group. The total cost of hiring a group of k workers is the sum of the wages of the workers.  The pay ratio of a worker in the group is their wage divided by their quality.  We want to minimize the total cost to hire k workers such that the pay ratio of every worker is no less than the pay ratio of any other worker in the group. Return the minimum cost to hire exactly k workers.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>This approach involves generating all possible combinations of k workers and calculating the cost for each combination. For each combination, we calculate the pay ratio for each worker in that combination. The cost of a combination is the sum of wages of workers. To be a valid combination the pay ratio of all workers must be greater than or equal to the maximum pay ratio within the combination. We return the minimum cost among all valid combinations.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    double calculateCost(vector&lt;int&gt;&amp; combination, vector&lt;int&gt;&amp; quality, vector&lt;int&gt;&amp; wage, double maxRatio) {
        double totalCost = 0;
        for (int index : combination) {
            if (wage[index] * 1.0 / quality[index] &gt; maxRatio) {
                return -1.0; // Invalid combination
            }
            totalCost += wage[index];
        }
        return totalCost;
    }

    double mincostToHireWorkers(vector&lt;int&gt;&amp; quality, vector&lt;int&gt;&amp; wage, int k) {
        int n = quality.size();
        double minCost = -1.0;

        for (int i = 0; i &lt; (1 &lt;&lt; n); ++i) {
            if (__builtin_popcount(i) != k) continue; // Check if combination has exactly k workers

            vector&lt;int&gt; combination;
            for (int j = 0; j &lt; n; ++j) {
                if ((i &amp; (1 &lt;&lt; j)) != 0) {
                    combination.push_back(j);
                }
            }

            double maxRatio = 0.0;
            for (int index : combination) {
                maxRatio = max(maxRatio, wage[index] * 1.0 / quality[index]);
            }

            double cost = calculateCost(combination, quality, wage, maxRatio);
            if (cost != -1.0) {
                if (minCost == -1.0 || cost &lt; minCost) {
                    minCost = cost;
                }
            }
        }
        return minCost == -1.0 ? 0.0 : minCost;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n^2 * 2^n),  where n is the number of workers. For each of the 2^n possible subsets, we check if their size is k which takes O(n). Calculating max ratio and cost also takes O(n). | <b>Space Complexity:</b> O(n), to store combination.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Greedy Approach with Sorting</h5>
  <p>The core idea is to sort the workers based on their pay ratio (wage / quality). Then, for each worker (starting with the lowest pay ratio), we add their quality to a max heap (priority queue) and calculate the current cost. We maintain a max heap of size k, which represents the k highest quality workers. The current cost is the current worker's pay ratio multiplied by the sum of the qualities in the heap.  We keep track of the minimum cost found so far. Whenever the heap size exceeds k, remove the highest-quality worker to maintain the k-size constraint, and compute the current cost again. Since the workers are sorted, we can iterate and determine valid combinations greedily. </p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    double mincostToHireWorkers(vector&lt;int&gt;&amp; quality, vector&lt;int&gt;&amp; wage, int k) {
        int n = quality.size();
        vector&lt;pair&lt;double, int&gt;&gt; workers;
        for (int i = 0; i &lt; n; ++i) {
            workers.push_back({(double)wage[i] / quality[i], i});
        }
        sort(workers.begin(), workers.end());

        double minCost = DBL_MAX;
        priority_queue&lt;int&gt; pq; // Max-heap
        double qualitySum = 0;

        for (auto&amp; worker : workers) {
            int index = worker.second;
            qualitySum += quality[index];
            pq.push(quality[index]);

            if (pq.size() &gt; k) {
                qualitySum -= pq.top();
                pq.pop();
            }

            if (pq.size() == k) {
                minCost = min(minCost, qualitySum * worker.first);
            }
        }
        return minCost;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n log n + n log k), where n is the number of workers.  Sorting takes O(n log n), and iterating through the workers, with heap operations, takes O(n log k). | <b>Space Complexity:</b> O(n) due to the worker vector and priority queue (max heap).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">quality = [10,20,5], wage = [70,50,30], k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">105.00000</td>
        <td style="border: 1px solid #ccc; padding: 6px;">We have 3 workers with qualities [10, 20, 5] and wages [70, 50, 30]. We want to hire 2 workers.

-   Worker 1 has pay ratio 70 / 10 = 7.
-   Worker 2 has pay ratio 50 / 20 = 2.5.
-   Worker 3 has pay ratio 30 / 5 = 6.

-   If we hire workers 2 and 3, we get a total cost of 50 + 30 = 80.

-   If we hire workers 1 and 3, we get a total cost of 70 + 30 = 100.

-   If we hire workers 1 and 2, we get a total cost of 70 + 50 = 120.

So, hiring workers 2 and 3 is the cheapest, giving a total cost of 80.  However, pay ratio of worker 3 (6) is better than worker 2 (2.5), which makes this combination not valid. Similarly combination 1 and 3 is also not valid, whereas combination 1 and 2 is valid, hence our answer will be 120. However, the approach will select 2, 3 and determine the minimum cost as 105.000</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">30.66667</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Hiring workers with index 0, 1, and 4 leads to the minimum cost.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Key considerations include:

-   The pay ratio is the critical factor for selecting workers.
-   Sorting by pay ratio helps to efficiently find the optimal solution.
-   Using a max-heap efficiently tracks the best quality workers.  Edge cases: k can be equal to n or less than n. If k equals to n, then all workers must be considered.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/swim-in-rising-water/>Swim in Rising Water</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>You are given an n x n integer matrix grid where each cell represents the elevation at that point. You are initially at the top-left cell (0, 0). You can swim to any adjacent cell in one direction (up, down, left, or right) if the elevation of the destination cell is at most the current time. The time it takes to reach a cell is the elevation of that cell. Return the least time it takes to reach the bottom-right cell (n-1, n-1).</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves trying all possible paths from the starting cell to the destination cell and finding the path with the minimum maximum elevation encountered. This can be done using Depth-First Search (DFS) or Breadth-First Search (BFS).  The time complexity will be high because it explores many redundant paths. This method is highly inefficient due to the exponential nature of path exploration in a grid.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col, int time, vector&lt;vector&lt;bool&gt;&gt;&amp; visited) {
    int n = grid.size();

    if (row &lt 0 || row &gt= n || col &lt 0 || col &gt= n || visited[row][col] || grid[row][col] &gt time) {
        return INT_MAX;
    }

    if (row == n - 1 &amp;&amp; col == n - 1) {
        return time;
    }

    visited[row][col] = true;
    int minTime = INT_MAX;
    int dr[] = {0, 0, 1, -1};
    int dc[] = {1, -1, 0, 0};

    for (int i = 0; i &lt 4; ++i) {
        int newRow = row + dr[i];
        int newCol = col + dc[i];
        minTime = min(minTime, dfs(grid, newRow, newCol, max(time, grid[row][col]), visited));
    }

    visited[row][col] = false;
    return minTime;
}

int swimInWaterBruteForce(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
    int n = grid.size();
    int left = grid[0][0], right = 2500;  // Assuming max elevation is 0-2500 as per constraints.
    int ans = right;
    
    while (left &lt= right) {
        int mid = left + (right - left) / 2;
        vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(n, false));
        if (dfs(grid, 0, 0, mid, visited) != INT_MAX) {
            ans = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return ans;
}

// int main() {
//     vector&lt;vector&lt;int&gt;&gt; grid = {
//         {0, 2},
//         {1, 3}
//     };
//     cout &lt;&lt; swimInWaterBruteForce(grid) &lt;&lt; endl;
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O( (4^(n*n)) * n * n), where n is the size of the grid. Exponential due to trying all paths in the worst case. | <b>Space Complexity:</b> O(n*n) due to recursion depth and visited matrix.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Binary Search with BFS/DFS (Optimized)</h5>
  <p>The optimal solution uses Binary Search to find the minimum time. For a given time, we use either BFS or DFS to check if a path exists from the top-left cell to the bottom-right cell such that the elevation of any cell on the path is no more than the given time. If such a path exists, we reduce the time, otherwise, we increase it. This approach reduces the search space significantly.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

bool isValid(int row, int col, int n) {
    return row &gt= 0 &amp;&amp; row &lt n &amp;&amp; col &gt= 0 &amp;&amp; col &lt n;
}

int swimInWaterOptimized(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
    int n = grid.size();
    int left = grid[0][0], right = 2500; // Assuming max elevation is 0-2500
    int ans = right;

    while (left &lt= right) {
        int mid = left + (right - left) / 2;
        vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(n, false));
        queue&lt;pair&lt;int, int&gt;&gt; q;
        q.push({0, 0});
        visited[0][0] = true;
        int dr[] = {0, 0, 1, -1};
        int dc[] = {1, -1, 0, 0};

        while (!q.empty()) {
            int row = q.front().first;
            int col = q.front().second;
            q.pop();

            if (row == n - 1 &amp;&amp; col == n - 1) {
                ans = mid;
                break;
            }

            for (int i = 0; i &lt 4; ++i) {
                int newRow = row + dr[i];
                int newCol = col + dc[i];

                if (isValid(newRow, newCol, n) &amp;&amp; !visited[newRow][newCol] &amp;&amp; grid[newRow][newCol] &lt= mid) {
                    q.push({newRow, newCol});
                    visited[newRow][newCol] = true;
                }
            }
        }
        
        if (visited[n-1][n-1]){
            right = mid -1;
        } else {
            left = mid + 1;
        }
    }

    return ans;
}

// int main() {
//     vector&lt;vector&lt;int&gt;&gt; grid = {
//         {0, 2},
//         {1, 3}
//     };
//     cout &lt;&lt; swimInWaterOptimized(grid) &lt;&lt; endl;
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(n^2 * log(M)), where n is the grid size and M is the maximum possible elevation (2500).  The binary search takes O(log M) iterations, and in each iteration, we perform a BFS/DFS which takes O(n^2) time. | <b>Space Complexity:</b> O(n^2) for the visited matrix and the queue/recursion stack.</p>
  <h5>‚û§ Dijkstra's Algorithm (Optimized)</h5>
  <p>This approach is the most efficient. Dijkstra's algorithm can be used to find the shortest path in a weighted graph. In this case, the grid can be considered a graph, where the weight of an edge between two cells is the maximum elevation between them. We use Dijkstra's to find the minimum time required to reach the bottom-right cell.  Prioritize based on max elevation till any node.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

int swimInWaterDijkstra(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
    int n = grid.size();
    priority_queue&lt;pair&lt;int, pair&lt;int, int&gt;&gt;, vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt;, greater&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt;&gt; pq; // min-heap
    pq.push({grid[0][0], {0, 0}});

    vector&lt;vector&lt;int&gt;&gt; dist(n, vector&lt;int&gt;(n, INT_MAX));
    dist[0][0] = grid[0][0];

    int dr[] = {0, 0, 1, -1};
    int dc[] = {1, -1, 0, 0};

    while (!pq.empty()) {
        int time = pq.top().first;
        int row = pq.top().second.first;
        int col = pq.top().second.second;
        pq.pop();

        if (row == n - 1 &amp;&amp; col == n - 1) {
            return time;
        }

        for (int i = 0; i &lt 4; ++i) {
            int newRow = row + dr[i];
            int newCol = col + dc[i];

            if (newRow &gt= 0 &amp;&amp; newRow &lt n &amp;&amp; newCol &gt= 0 &amp;&amp; newCol &lt n) {
                int newTime = max(time, grid[newRow][newCol]);
                if (newTime &lt dist[newRow][newCol]) {
                    dist[newRow][newCol] = newTime;
                    pq.push({newTime, {newRow, newCol}});
                }
            }
        }
    }

    return -1; // Should not reach here as a path always exists.
}

// int main() {
//     vector&lt;vector&lt;int&gt;&gt; grid = {
//         {0, 2},
//         {1, 3}
//     };
//     cout &lt;&lt; swimInWaterDijkstra(grid) &lt;&lt; endl;
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(n^2 * log(n^2)),  where n is the size of the grid. This is because Dijkstra's algorithm visits each cell at most once, and each cell's neighbors are explored in O(1).  Using a priority queue (min-heap) to select the next cell to visit contributes to the logarithmic factor. | <b>Space Complexity:</b> O(n^2) for the distance matrix and the priority queue.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">grid = [[0,2],[1,3]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The maximum elevation needed to swim to (1,1) is 3.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,10,9,8,17],[20,19,18,7,6]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">16</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The swimmer can reach the bottom right cell with a maximum elevation of 16.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">grid = [[3,2],[0,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The path [0, 0] -> [0, 1] -> [1, 1] is best.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The problem can be viewed as a shortest path problem in a graph where the edge weights are determined by the elevation. 
2.  Edge case: The grid size is at least 1x1 so a path always exists.
3.  The elevation values are non-negative integers.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/sliding-window-maximum/>Sliding Window Maximum</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given an array of integers `nums` and an integer `k`, return the maximum value of each sliding window of size `k`. A sliding window is a contiguous subarray of size `k` that moves from the beginning of the array to the end.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible windows of size k. For each window, find the maximum element. Return an array containing the maximums of each window.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

vector&lt;int&gt; maxSlidingWindowBruteForce(vector&lt;int&gt;&amp; nums, int k) {
    int n = nums.size();
    vector&lt;int&gt; result;
    if (n &lt k) return result;

    for (int i = 0; i &lt= n - k; ++i) {
        int max_val = nums[i];
        for (int j = i + 1; j &lt i + k; ++j) {
            max_val = max(max_val, nums[j]);
        }
        result.push_back(max_val);
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n*k) - We have n-k+1 windows, and for each window of size k, we iterate through all k elements to find the maximum. | <b>Space Complexity:</b> O(1) - We are using constant extra space.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Deque-based Solution</h5>
  <p>Use a double-ended queue (deque) to store the indices of the elements within the current window. The deque will store indices in decreasing order of their corresponding values.  The front of the deque always holds the index of the maximum element in the current window. When the window slides, remove the elements from the front of the deque that are out of the window and remove elements from the back that are smaller than the current element.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

vector&lt;int&gt; maxSlidingWindowDeque(vector&lt;int&gt;&amp; nums, int k) {
    int n = nums.size();
    vector&lt;int&gt; result;
    deque&lt;int&gt; dq;

    for (int i = 0; i &lt; n; ++i) {
        // Remove elements out of the window
        while (!dq.empty() &amp;&amp; dq.front() &lt= i - k) {
            dq.pop_front();
        }

        // Remove elements smaller than the current element from the back
        while (!dq.empty() &amp;&amp; nums[dq.back()] &lt; nums[i]) {
            dq.pop_back();
        }

        // Add the current element's index to the back
        dq.push_back(i);

        // If the window is full, add the maximum element to the result
        if (i &gt= k - 1) {
            result.push_back(nums[dq.front()]);
        }
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) - Each element is added and removed from the deque at most once. | <b>Space Complexity:</b> O(k) - The deque can hold at most k elements (indices).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,3,-1,-3,5,3,6,7], k = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[3,3,5,5,6,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1], k = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The maximum of the single element [1] is 1.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,-1], k = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,-1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The sliding window of size 1 yields [1, -1]</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The deque-based solution is the most efficient approach. It uses a deque to maintain indices of potential maximums within the window.  Edge cases include windows where k equals to 1 and the size of input array is 1. Also, input array with negative numbers requires special handling.</p>
</div>
<hr style="margin: 40px 0;">
<h2>Dynamic Programming</h2>
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/climbing-stairs>Climbing Stairs</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>You are climbing a staircase. It takes `n` steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach recursively explores all possible combinations of 1-step and 2-step climbs.  For each step, we try taking one step or two steps and recursively call the function to count ways for the remaining steps. The base cases are when we've reached the top (0 steps remaining) or gone past the top (negative steps remaining).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

int climbStairs_bruteForce(int n) {
    if (n &lt 0) {
        return 0;
    }
    if (n == 0) {
        return 1;
    }
    return climbStairs_bruteForce(n - 1) + climbStairs_bruteForce(n - 2);
}

// Example Usage (not part of the solution, for demonstration)
// int main() {
//     int n = 3;
//     cout &lt&lt "Number of ways: " &lt&lt climbStairs_bruteForce(n) &lt&lt endl;
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(2^n).  Each call makes two recursive calls, leading to exponential growth. | <b>Space Complexity:</b> O(n).  Due to the recursion depth, which can go up to n in the worst-case scenario. This is the space used by the call stack.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming (Tabulation)</h5>
  <p>This approach uses dynamic programming to avoid redundant calculations. We create an array `dp` where `dp[i]` stores the number of ways to reach step `i`. The base cases are `dp[0] = 1` (one way to stay at the bottom, not climb) and `dp[1] = 1`. Then, we calculate `dp[i]` using the formula `dp[i] = dp[i-1] + dp[i-2]`, representing the number of ways to reach step `i` by taking one step from `i-1` or two steps from `i-2`.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

int climbStairs_dp(int n) {
    if (n &lt= 2) {
        return n; // Base cases: 1 or 2 steps
    }
    vector&lt;int&gt; dp(n + 1);
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i &lt= n; ++i) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}

// Example usage
// int main() {
//     int n = 3;
//     cout &lt&lt "Number of ways: " &lt&lt climbStairs_dp(n) &lt&lt endl;
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(n). We iterate through the array of size n once. | <b>Space Complexity:</b> O(n). We use an array `dp` of size n+1 to store intermediate results.</p>
  <h5>‚û§ Dynamic Programming (Space Optimized)</h5>
  <p>We can optimize the space complexity of the tabulation approach. Notice that we only need the results from the previous two steps to calculate the current step. So, instead of storing the entire `dp` array, we can use two variables to keep track of the previous two step counts, reducing space complexity to O(1).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

int climbStairs_dp_optimized(int n) {
    if (n &lt= 2) {
        return n;
    }
    int first = 1, second = 2, third = 0;
    for (int i = 3; i &lt= n; ++i) {
        third = first + second;
        first = second;
        second = third;
    }
    return third;
}

// Example Usage
// int main() {
//     int n = 3;
//     cout &lt&lt "Number of ways: " &lt&lt climbStairs_dp_optimized(n) &lt&lt endl;
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(n).  We still iterate through n steps. | <b>Space Complexity:</b> O(1). We only use constant extra space (three integer variables).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There are two ways to climb to the top. 1. 1 step + 1 step. 2. 2 steps.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There are three ways to climb to the top. 1. 1 step + 1 step + 1 step. 2. 1 step + 2 steps. 3. 2 steps + 1 step.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The ways are: 1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The Fibonacci sequence is heavily involved in this problem. The number of ways to climb `n` stairs is the `n`-th Fibonacci number (with indexing starting from 1). The base cases for n=1 and n=2 are crucial. The space optimization is a key point. Consider edge cases such as when n is 0, 1, or 2. The Fibonacci sequence provides a very efficient solution pattern.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/maximum-product-subarray/>Maximum Product Subarray</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given an integer array `nums`, find a subarray that has the largest product, and return the product. A subarray is a contiguous non-empty sequence of elements within an array.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible subarrays and calculate their products. Keep track of the maximum product found so far.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int maxProductBruteForce(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    int max_product = nums[0];

    for (int i = 0; i &lt; n; ++i) {
        int current_product = 1;
        for (int j = i; j &lt; n; ++j) {
            current_product *= nums[j];
            max_product = max(max_product, current_product);
        }
    }

    return max_product;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2), where n is the size of the input array.  We have nested loops iterating through all possible subarrays. | <b>Space Complexity:</b> O(1), as we only use a constant amount of extra space.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming (Optimized)</h5>
  <p>Use dynamic programming to keep track of the maximum and minimum products ending at each index. This is because a negative number multiplied by another negative number can become positive, potentially resulting in a larger product.  We maintain `max_so_far`, `min_so_far`, and the overall `max_product`.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int maxProductOptimized(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    int max_so_far = nums[0];
    int min_so_far = nums[0];
    int max_product = nums[0];

    for (int i = 1; i &lt; n; ++i) {
        int current = nums[i];
        int temp_max = max({current, max_so_far * current, min_so_far * current});
        min_so_far = min({current, max_so_far * current, min_so_far * current});
        max_so_far = temp_max;
        max_product = max(max_product, max_so_far);
    }

    return max_product;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the size of the input array. We iterate through the array once. | <b>Space Complexity:</b> O(1), as we use a constant amount of extra space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [2,3,-2,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Subarray [2,3] has the largest product 6.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [-2,0,-1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Result cannot be 2, because [-2,-1] is not a subarray.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [-2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The largest product is -2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [0, 2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Subarray [2] has the largest product 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [-4,-3,-2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">12</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Subarray [-4,-3] has the largest product 12.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Key points to consider:
- Handle negative numbers, as multiplying two negatives results in a positive.
- Handle zeros carefully, as they can reset the product.
- Consider edge cases like arrays with only one element or all negative elements.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/ones-and-zeroes/>Ones and Zeroes</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>You are given an array of binary strings strs and two integers m and n. Return the size of the largest subset of strs such that there are at most m 0's and n 1's in the subset.

A subset of a string array is any combination of strings from the given array.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Generate all possible subsets of the given strings. For each subset, count the number of 0s and 1s. If the counts of 0s and 1s are within the given limits (m and n), update the maximum subset size.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    int findMaxForm(vector&lt;string&gt;& strs, int m, int n) {
        int maxSubsetSize = 0;
        int numStrings = strs.size();

        for (int i = 0; i &lt (1 &lt&lt numStrings); ++i) {
            int zeros = 0;
            int ones = 0;
            for (int j = 0; j &lt numStrings; ++j) {
                if ((i & (1 &lt&lt j)) != 0) {
                    for (char c : strs[j]) {
                        if (c == '0') {
                            zeros++;
                        } else {
                            ones++;
                        }
                    }
                }
            }

            if (zeros &lt= m &amp;&amp; ones &lt= n) {
                int currentSubsetSize = 0;
                for (int j = 0; j &lt numStrings; ++j) {
                    if ((i & (1 &lt&lt j)) != 0) {
                        currentSubsetSize++;
                    }
                }
                maxSubsetSize = max(maxSubsetSize, currentSubsetSize);
            }
        }
        return maxSubsetSize;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(2^k * L), where k is the number of strings and L is the average length of the strings. Generating all subsets takes O(2^k). For each subset, counting 0s and 1s takes O(L * k) in the worst case. | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming - 2D DP</h5>
  <p>Use dynamic programming to optimize the solution. Create a 2D DP table dp[i][j] where dp[i][j] represents the maximum size of the subset using at most i zeros and j ones. Iterate through the strings. For each string, count the number of zeros and ones. Then, iterate backwards through the DP table, updating each cell dp[p][q] if including the current string is beneficial.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    int findMaxForm(vector&lt;string&gt;& strs, int m, int n) {
        vector&lt;pair&lt;int, int&gt;&gt; counts;
        for (const string& str : strs) {
            int zeros = 0, ones = 0;
            for (char c : str) {
                if (c == '0') zeros++;
                else ones++;
            }
            counts.push_back({zeros, ones});
        }

        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));

        for (const auto& count : counts) {
            int zeros = count.first;
            int ones = count.second;
            for (int i = m; i &gt= zeros; --i) {
                for (int j = n; j &gt= ones; --j) {
                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1);
                }
            }
        }

        return dp[m][n];
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(k * m * n), where k is the number of strings.  The outer loop iterates through the strings (k). The nested loops iterate through the DP table (m * n). | <b>Space Complexity:</b> O(m * n)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">strs = ["10","0001","111001","1","0"], m = 5, n = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The largest subset with at most 5 0's and 3 1's is {"10", "0001", "1", "0"}, so the answer is 4.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">strs = ["10","0","1"], m = 1, n = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The largest subset with at most 1 0 and 1 1 is {"0", "1"}, so the answer is 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">strs = ["0","0","0","1","1","1","1","1","1","1","0","1","1","0","0","0","0","1","0","1"], m = 9, n = 6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">19</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Pick all the strings if possible.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to solving this problem efficiently is to use dynamic programming. The order of iteration through the dp table is crucial.  Also, consider edge cases where m or n could be 0.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/counting-bits/>Counting Bits</a> <span style="font-size:14px; color:#888;">Easy</span></h3>
  <p>Given an integer `n`, return an array `ans` of length `n + 1` such that for each `i` (0 &lt= i &lt= n), `ans[i]` is the number of 1's in the binary representation of `i`.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through each number from 0 to n. For each number, convert it to its binary representation (as a string) and count the number of '1's. Store the counts in the result array.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

string toBinary(int n) {
    if (n == 0) return "0";
    string binary = "";
    while (n &gt 0) {
        binary = to_string(n % 2) + binary;
        n /= 2;
    }
    return binary;
}

vector&lt;int&gt; countBitsBruteForce(int n) {
    vector&lt;int&gt; ans(n + 1);
    for (int i = 0; i &lt= n; ++i) {
        string binary = toBinary(i);
        int count = 0;
        for (char bit : binary) {
            if (bit == '1') {
                count++;
            }
        }
        ans[i] = count;
    }
    return ans;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n * k), where n is the input number and k is the average length of the binary representation of a number (which is approximately log2(n)). | <b>Space Complexity:</b> O(n) to store the result array.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming (Most Significant Bit)</h5>
  <p>Use dynamic programming. The number of set bits in a number can be derived from the number of set bits in a smaller number. For each number i, if i is even, the count of set bits is the same as i/2. If i is odd, the count of set bits is the count of set bits in i/2 plus 1. This reduces the problem to smaller subproblems.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

vector&lt;int&gt; countBitsDP(int n) {
    vector&lt;int&gt; ans(n + 1);
    ans[0] = 0;
    for (int i = 1; i &lt= n; ++i) {
        ans[i] = ans[i &gt&gt 1] + (i & 1);
    }
    return ans;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) | <b>Space Complexity:</b> O(n) to store the result array.</p>
  <h5>‚û§ Dynamic Programming (Least Significant Bit)</h5>
  <p>Leverage the relationship between a number and its right-shifted counterpart. The number of set bits in `i` is the same as the number of set bits in `i &gt&gt; 1` (i right-shifted by 1, equivalent to i / 2 integer division) plus 1 if the least significant bit of `i` is 1.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

vector&lt;int&gt; countBitsDP2(int n) {
    vector&lt;int&gt; ans(n + 1);
    ans[0] = 0;
    for (int i = 1; i &lt= n; ++i) {
        ans[i] = ans[i &gt&gt 1] + (i & 1);
    }
    return ans;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) | <b>Space Complexity:</b> O(n)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[0,1,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0 --> 0
1 --> 1
2 --> 10</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[0,1,1,2,1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0 --> 0</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to optimizing this problem lies in identifying the pattern of how the number of set bits changes as we increment the number. Dynamic programming allows us to efficiently reuse previously computed results.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/knight-dialer/>Knight Dialer</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>The knight is placed on a phone dialer. At each step, the knight can move one of the 8 possible moves (as shown in the figure). Given an integer n, return how many different phone numbers of length n we can dial. You are allowed to start at any number on the dialer.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Explore all possible paths using recursion. For each starting number, recursively explore all valid knight moves, decrementing the remaining steps. This approach has exponential time complexity due to the branching factor.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

int knightDialerRecursive(int row, int col, int steps) {
    if (steps == 0) {
        return 1;
    }

    int count = 0;
    int dr[] = {-2, -2, -1, -1, 1, 1, 2, 2};
    int dc[] = {-1, 1, -2, 2, -2, 2, -1, 1};

    for (int i = 0; i &lt 8; i++) {
        int newRow = row + dr[i];
        int newCol = col + dc[i];

        if (newRow &gt= 0 &amp;&amp; newRow &lt 4 &amp;&amp; newCol &gt= 0 &amp;&amp; newCol &lt 3 &amp;&amp; !(newRow == 3 &amp;&amp; newCol == 0) &amp;&amp; !(newRow == 3 &amp;&amp; newCol == 2)) {
            count = (count + knightDialerRecursive(newRow, newCol, steps - 1)) % 1000000007;
        }
    }
    return count;
}

int knightDialerBruteForce(int n) {
    int totalCount = 0;
    int startRows[] = {0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3}; // Rows for dialer (0-9, *) excluding #
    int startCols[] = {0, 1, 2, 0, 1, 2, 0, 1, 2, 1, 0}; // Columns for dialer

    for (int i = 0; i &lt 11; i++) {
        totalCount = (totalCount + knightDialerRecursive(startRows[i], startCols[i], n - 1)) % 1000000007;
    }
    return totalCount;
}
</code></pre>
  <p><b>Time Complexity:</b> O(8^n) - Exponential time complexity due to recursive calls for each possible move. | <b>Space Complexity:</b> O(n) - Space used by the call stack for recursion.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming (Tabulation)</h5>
  <p>Use dynamic programming to avoid redundant calculations. Create a 3D DP table dp[n+1][row][col], where dp[i][r][c] stores the number of phone numbers of length i that end at cell (r, c). Iterate through the lengths from 1 to n, calculating dp[i][r][c] by summing up the valid moves from the previous length (i-1).  Use modulo arithmetic to prevent integer overflow.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

int knightDialerDP(int n) {
    int mod = 1000000007;
    int dp[n + 1][4][3];
    memset(dp, 0, sizeof(dp));

    // Initialize for length 1
    for (int r = 0; r &lt 4; r++) {
        for (int c = 0; c &lt 3; c++) {
            if (!(r == 3 &amp;&amp; c == 0) &amp;&amp; !(r == 3 &amp;&amp; c == 2)) {
                dp[1][r][c] = 1;
            }
        }
    }

    int dr[] = {-2, -2, -1, -1, 1, 1, 2, 2};
    int dc[] = {-1, 1, -2, 2, -2, 2, -1, 1};

    for (int steps = 2; steps &lt= n; steps++) {
        for (int r = 0; r &lt 4; r++) {
            for (int c = 0; c &lt 3; c++) {
                if (!(r == 3 &amp;&amp; c == 0) &amp;&amp; !(r == 3 &amp;&amp; c == 2)) {
                    for (int i = 0; i &lt 8; i++) {
                        int prevR = r - dr[i];
                        int prevC = c - dc[i];
                        if (prevR &gt= 0 &amp;&amp; prevR &lt 4 &amp;&amp; prevC &gt= 0 &amp;&amp; prevC &lt 3 &amp;&amp; !(prevR == 3 &amp;&amp; prevC == 0) &amp;&amp; !(prevR == 3 &amp;&amp; prevC == 2)) {
                            dp[steps][r][c] = (dp[steps][r][c] + dp[steps - 1][prevR][prevC]) % mod;
                        }
                    }
                }
            }
        }
    }

    int totalCount = 0;
    for (int r = 0; r &lt 4; r++) {
        for (int c = 0; c &lt 3; c++) {
            totalCount = (totalCount + dp[n][r][c]) % mod;
        }
    }

    return totalCount;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) - The algorithm iterates over the number of steps and the dialer's cells. The inner loops for the moves add a constant factor. | <b>Space Complexity:</b> O(n) - For the DP table of size (n+1) * 4 * 3</p>
  <h5>‚û§ Optimized Dynamic Programming (Space Optimization)</h5>
  <p>Optimize the space complexity of the dynamic programming solution by using only two rows of the DP table at any given time (current row and previous row), as we only need information from the previous length to compute the current length.  Use modulo arithmetic to prevent integer overflow.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

int knightDialerDPSpaceOptimized(int n) {
    int mod = 1000000007;
    int dp[2][4][3];
    memset(dp, 0, sizeof(dp));

    // Initialize for length 1
    for (int r = 0; r &lt 4; r++) {
        for (int c = 0; c &lt 3; c++) {
            if (!(r == 3 &amp;&amp; c == 0) &amp;&amp; !(r == 3 &amp;&amp; c == 2)) {
                dp[1][r][c] = 1;
            }
        }
    }

    int dr[] = {-2, -2, -1, -1, 1, 1, 2, 2};
    int dc[] = {-1, 1, -2, 2, -2, 2, -1, 1};

    for (int steps = 2; steps &lt= n; steps++) {
        int current = steps % 2;
        int prev = 1 - current;

        for (int r = 0; r &lt 4; r++) {
            for (int c = 0; c &lt 3; c++) {
                dp[current][r][c] = 0; // Reset current dp values
                if (!(r == 3 &amp;&amp; c == 0) &amp;&amp; !(r == 3 &amp;&amp; c == 2)) {
                    for (int i = 0; i &lt 8; i++) {
                        int prevR = r - dr[i];
                        int prevC = c - dc[i];

                        if (prevR &gt= 0 &amp;&amp; prevR &lt 4 &amp;&amp; prevC &gt= 0 &amp;&amp; prevC &lt 3 &amp;&amp; !(prevR == 3 &amp;&amp; prevC == 0) &amp;&amp; !(prevR == 3 &amp;&amp; prevC == 2)) {
                            dp[current][r][c] = (dp[current][r][c] + dp[prev][prevR][prevC]) % mod;
                        }
                    }
                }
            }
        }
    }

    int totalCount = 0;
    int last = n % 2;
    for (int r = 0; r &lt 4; r++) {
        for (int c = 0; c &lt 3; c++) {
            totalCount = (totalCount + dp[last][r][c]) % mod;
        }
    }

    return totalCount;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) - The algorithm iterates through the number of steps and dialer cells. | <b>Space Complexity:</b> O(1) - Uses a fixed size 2x4x3 DP table.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">10</td>
        <td style="border: 1px solid #ccc; padding: 6px;">A knight can start at any number (0-9) and dial one digit in length 1.  The total possibilities is 10.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">20</td>
        <td style="border: 1px solid #ccc; padding: 6px;">If we are at number 1, the possible next moves are {6, 8}. Therefore we can have the following number combinations: 16, 18. Same applies to other numbers.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">46</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The number of paths for length 3 is 46.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The phone dialer has the digits 0-9, and the * and # keys.  The knight's moves are valid only within the dialer's 4x3 grid, and it cannot land on the * or # keys.  Handle the modulo operation (10^9 + 7) to prevent integer overflow.  The space-optimized DP approach significantly reduces memory usage.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/cutted-segments1642/1>Cutted Segments</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a rod of length n, and three integers x, y, and z, representing the lengths of the segments that can be cut from the rod, find the maximum number of segments that the rod can be cut into such that each segment is of length x, y, or z. If it's not possible to cut the rod into segments of the given lengths, return -1.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>This approach uses recursion to try all possible combinations of cuts. It explores all possibilities of cutting the rod using lengths x, y, and z and keeps track of the maximum number of cuts.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int solve_recursive(int n, int x, int y, int z) {
    if (n == 0) {
        return 0;
    }
    if (n &lt 0) {
        return -1;
    }

    int a = solve_recursive(n - x, x, y, z);
    int b = solve_recursive(n - y, x, y, z);
    int c = solve_recursive(n - z, x, y, z);

    int max_cuts = -1;
    if (a != -1) {
        max_cuts = max(max_cuts, a + 1);
    }
    if (b != -1) {
        max_cuts = max(max_cuts, b + 1);
    }
    if (c != -1) {
        max_cuts = max(max_cuts, c + 1);
    }

    return max_cuts;
}

int cutRod(int n, int x, int y, int z) {
    return solve_recursive(n, x, y, z);
}
</code></pre>
  <p><b>Time Complexity:</b> O(3^n) -  Each recursive call branches into 3 more calls in the worst case, leading to exponential time complexity. | <b>Space Complexity:</b> O(n) -  Due to the recursive call stack, in the worst-case, where n is the length of the rod.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming (Tabulation)</h5>
  <p>This approach uses dynamic programming to store and reuse results of subproblems. We create a dp array of size n+1 where dp[i] stores the maximum number of segments possible for a rod of length i.  The dp array is filled in a bottom-up manner, considering the options x, y, and z.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int cutRod(int n, int x, int y, int z) {
    vector&lt;int&gt; dp(n + 1, -1);
    dp[0] = 0;

    for (int i = 1; i &lt= n; i++) {
        if (i - x &gt= 0 &amp;&amp; dp[i - x] != -1) {
            dp[i] = max(dp[i], dp[i - x] + 1);
        }
        if (i - y &gt= 0 &amp;&amp; dp[i - y] != -1) {
            dp[i] = max(dp[i], dp[i - y] + 1);
        }
        if (i - z &gt= 0 &amp;&amp; dp[i - z] != -1) {
            dp[i] = max(dp[i], dp[i - z] + 1);
        }
    }
    return dp[n];
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) -  We iterate through the dp array once, which takes linear time based on the rod's length n. | <b>Space Complexity:</b> O(n) -  We use a dp array of size n+1 to store the results.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 5, x = 2, y = 1, z = 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The rod can be cut into five segments of length 1.  So 5 / 1 = 5 cuts.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 1, x = 1, y = 1, z = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The rod can be cut into one segment of length 1. So 1 / 1 = 1 cut.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 23, x = 11, y = 9, z = 12</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">We can cut rod into segments of 12 and 11 (12+11=23).</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 4, x = 2, y = 1, z = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">We can cut 4 segments of length 1.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 5, x = 5, y = 3, z = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">We can cut one segment of length 5.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases to consider: 
1.  If the rod's length is 0, the maximum number of segments is 0.
2. If it is impossible to cut the rod, return -1.
3. Consider the constraints of the problem and how they might impact the choice of cutting lengths.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/unique-paths/>Unique Paths</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram). How many possible unique paths are there?</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Recursively explore all possible paths. At each cell, the robot can either move right or down. The base cases are when the robot reaches the finish cell (count a path) or goes out of bounds (stop exploring that path).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt

using namespace std;

int uniquePathsRecursive(int m, int n, int row, int col) {
    if (row &gt= m || col &gt= n) {
        return 0;
    }
    if (row == m - 1 &amp;&amp; col == n - 1) {
        return 1;
    }
    return uniquePathsRecursive(m, n, row + 1, col) + uniquePathsRecursive(m, n, row, col + 1);
}

string generateBruteForceCode(int m, int n) {
  stringstream ss;
  ss &lt&lt "#include &ltbits/stdc++.h&gt\n\n";
  ss &lt&lt "using namespace std;\n\n";
  ss &lt&lt "int uniquePathsRecursive(int m, int n, int row, int col) {\n";
  ss &lt&lt "    if (row &gt= m || col &gt= n) {\n";
  ss &lt&lt "        return 0;\n";
  ss &lt&lt "    }\n";
  ss &lt&lt "    if (row == m - 1 &amp;&amp; col == n - 1) {\n";
  ss &lt&lt "        return 1;\n";
  ss &lt&lt "    }\n";
  ss &lt&lt "    return uniquePathsRecursive(m, n, row + 1, col) + uniquePathsRecursive(m, n, row, col + 1);\n";
  ss &lt&lt "}\n\n";
  ss &lt&lt "int main() {\n";
  ss &lt&lt "    int m = " &lt&lt m &lt&lt ";\n";
  ss &lt&lt "    int n = " &lt&lt n &lt&lt ";\n";
  ss &lt&lt "    cout &lt&lt uniquePathsRecursive(m, n, 0, 0) &lt&lt endl;\n";
  ss &lt&lt "    return 0;\n";
  ss &lt&lt "}\n";
  return ss.str();
}
</code></pre>
  <p><b>Time Complexity:</b> O(2^(m+n)), where m and n are the dimensions of the grid.  This is because in the worst-case scenario, the robot explores all possible paths, which grows exponentially with the grid size. | <b>Space Complexity:</b> O(m+n), due to the recursion depth. In the worst case (a straight path), the call stack will have a depth equal to the sum of the dimensions.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming (Tabulation)</h5>
  <p>Use dynamic programming to avoid redundant calculations. Create a 2D array `dp` where `dp[i][j]` stores the number of unique paths from (0, 0) to (i, j). Initialize `dp[0][0]` to 1. Iterate through the grid and calculate `dp[i][j]` by summing `dp[i-1][j]` and `dp[i][j-1]`.  Handle the boundary conditions correctly.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt

using namespace std;

int uniquePaths(int m, int n) {
    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));
    dp[0][0] = 1;

    for (int i = 0; i &lt; m; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            if (i &gt; 0) {
                dp[i][j] += dp[i - 1][j];
            }
            if (j &gt; 0) {
                dp[i][j] += dp[i][j - 1];
            }
        }
    }
    return dp[m - 1][n - 1];
}
</code></pre>
  <p><b>Time Complexity:</b> O(m*n), where m and n are the dimensions of the grid.  We iterate through each cell of the grid once. | <b>Space Complexity:</b> O(m*n), for the 2D `dp` array.</p>
  <h5>‚û§ Dynamic Programming (Optimized Space)</h5>
  <p>We can optimize the space complexity to O(n) by using a 1D array to store the number of paths for each column at a particular row. At each row, update the 1D array using values from the previous row and current row.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt

using namespace std;

int uniquePathsOptimized(int m, int n) {
    vector&lt;int&gt; dp(n, 0);
    dp[0] = 1;

    for (int i = 0; i &lt; m; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            if (j &gt; 0) {
                dp[j] += dp[j - 1];
            }
        }
    }
    return dp[n - 1];
}
</code></pre>
  <p><b>Time Complexity:</b> O(m*n), same as the tabulation approach. | <b>Space Complexity:</b> O(n), due to the 1D `dp` array.  We only need to store the values for the current row.</p>
  <h5>‚û§ Combinatorics</h5>
  <p>The problem can be solved using combinatorics. To reach the bottom-right corner, the robot must take a total of (m-1) steps down and (n-1) steps right. The unique paths can be calculated by choosing (m-1) moves down (or (n-1) moves right) from the total moves. The number of paths equals C(m+n-2, m-1) or C(m+n-2, n-1). Calculate the combination efficiently using precomputed factorials or by iterative calculations to avoid overflow.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt

using namespace std;

int uniquePathsCombinatorics(int m, int n) {
    long long totalMoves = m + n - 2;
    long long downMoves = m - 1;
    
    if (downMoves &gt totalMoves) return 0;

    double result = 1;
    for (int i = 1; i &lt= downMoves; ++i) {
        result = result * (totalMoves - i + 1) / i;
    }

    return (int)result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(min(m, n)), since we iterate up to min(m, n) in the combinatorics approach. | <b>Space Complexity:</b> O(1), as we only use a constant amount of extra space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">m = 3, n = 7</td>
        <td style="border: 1px solid #ccc; padding: 6px;">28</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The robot has to go 2 steps down and 6 steps right. The total number of moves is 8 and we need to pick 2 down moves from these 8 moves. So, we can use the combinatorics formula C(8, 2) = 28</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">m = 3, n = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">From the top-left corner, there are three ways to reach the bottom-right corner: Right -> Right -> Down, Right -> Down -> Right, Down -> Right -> Right.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">m = 1, n = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No movement is needed.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The problem is well-suited for dynamic programming because it exhibits overlapping subproblems (the robot can reach a cell from multiple directions) and optimal substructure (the optimal path to a cell is composed of optimal paths to its adjacent cells).  The combinatorics solution offers a more concise approach for calculating the result, but requires careful handling to avoid integer overflow.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/minimum-path-sum/>Minimum Path Sum</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. You can only move either down or right at any point in time.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach explores all possible paths from the top-left cell to the bottom-right cell. This is done by recursively exploring all possible moves (down or right) from each cell and calculating the sum of the path. The minimum path sum is then determined by comparing the sums of all paths.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

class Solution {
public:
    int minPathSumHelper(vector&lt;vector&lt;int&gt;&gt;& grid, int row, int col) {
        if (row &gt= grid.size() || col &gt= grid[0].size()) {
            return INT_MAX; // Invalid path
        }
        if (row == grid.size() - 1 &amp;&amp; col == grid[0].size() - 1) {
            return grid[row][col]; // Reached destination
        }

        int right = minPathSumHelper(grid, row, col + 1);
        int down = minPathSumHelper(grid, row + 1, col);

        return grid[row][col] + min(right, down);
    }

    int minPathSum(vector&lt;vector&lt;int&gt;&gt;& grid) {
        return minPathSumHelper(grid, 0, 0);
    };
};
</code></pre>
  <p><b>Time Complexity:</b> O(2^(m+n)), where m is the number of rows and n is the number of columns. In the worst case, we explore all possible paths. | <b>Space Complexity:</b> O(m+n) due to the recursive call stack. In the worst case, the depth of the recursion is the sum of rows and cols (m+n).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming (Tabulation)</h5>
  <p>This approach uses dynamic programming to efficiently compute the minimum path sum. A 2D DP table is created, where dp[i][j] stores the minimum path sum to reach cell (i, j). The table is filled iteratively, starting from the top-left cell. The minimum path sum to reach (i, j) is the sum of the current cell's value and the minimum of the path sums from the top and left cells (dp[i-1][j] and dp[i][j-1]).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

class Solution {
public:
    int minPathSum(vector&lt;vector&lt;int&gt;&gt;& grid) {
        int rows = grid.size();
        int cols = grid[0].size();

        vector&lt;vector&lt;int&gt;&gt; dp(rows, vector&lt;int&gt;(cols, 0));

        // Initialize the top-left cell
        dp[0][0] = grid[0][0];

        // Initialize the first row
        for (int j = 1; j &lt cols; j++) {
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }

        // Initialize the first column
        for (int i = 1; i &lt rows; i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }

        // Fill the dp table
        for (int i = 1; i &lt rows; i++) {
            for (int j = 1; j &lt cols; j++) {
                dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]);
            }
        }

        return dp[rows - 1][cols - 1];
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(m*n), where m is the number of rows and n is the number of columns. We iterate through each cell of the grid once. | <b>Space Complexity:</b> O(m*n) for the DP table.</p>
  <h5>‚û§ Dynamic Programming (Space Optimized)</h5>
  <p>This approach optimizes the space complexity of the dynamic programming solution by using only one row or column of the DP table at a time. Since to calculate the minimum path sum for a cell (i, j), we only need the values from the cells (i-1, j) and (i, j-1). So, we can maintain only one row (or column) of the DP table at a time to store the minimum path sums.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

class Solution {
public:
    int minPathSum(vector&lt;vector&lt;int&gt;&gt;& grid) {
        int rows = grid.size();
        int cols = grid[0].size();

        vector&lt;int&gt; dp(cols, 0);

        // Initialize the first row
        dp[0] = grid[0][0];
        for (int j = 1; j &lt cols; j++) {
            dp[j] = dp[j - 1] + grid[0][j];
        }

        // Fill the dp table
        for (int i = 1; i &lt rows; i++) {
            dp[0] += grid[i][0];
            for (int j = 1; j &lt cols; j++) {
                dp[j] = grid[i][j] + min(dp[j - 1], dp[j]);
            }
        }

        return dp[cols - 1];
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(m*n) | <b>Space Complexity:</b> O(n), where n is the number of columns. We are using only one row to store the DP values.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,3,1],[1,5,1],[4,2,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">7</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The path 1 ‚Üí 3 ‚Üí 1 ‚Üí 1 ‚Üí 1 minimizes the sum.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,2,3],[4,5,6]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">12</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The path 1 ‚Üí 2 ‚Üí 3 ‚Üí 6 minimizes the sum.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Only one element in the grid.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. The grid can contain only non-negative integers.
2. Handle the case where the grid has only one row or one column. 
3. Ensure that the code handles empty grids or grids with zero dimensions gracefully, although the problem description implies the grid will not be empty.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/coin-change/>Coin Change</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

You may assume that you have an infinite number of each kind of coin.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Recursively try all possible combinations of coins to reach the target amount. For each coin, either include it or exclude it in the combination and recursively call the function with the remaining amount.  Keep track of the minimum number of coins used.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    int coinChange(vector&lt;int&gt;&amp; coins, int amount) {
        int result = solve(coins, amount);
        return result == INT_MAX ? -1 : result;
    }

    int solve(vector&lt;int&gt;&amp; coins, int amount) {
        if (amount &lt; 0) {
            return INT_MAX;
        }
        if (amount == 0) {
            return 0;
        }

        int minCoins = INT_MAX;
        for (int coin : coins) {
            int subResult = solve(coins, amount - coin);
            if (subResult != INT_MAX) {
                minCoins = min(minCoins, subResult + 1);
            }
        }
        return minCoins;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(S^N), where S is the target amount and N is the number of coin denominations. In the worst case, we might explore all possible combinations, leading to exponential time complexity. | <b>Space Complexity:</b> O(S) in the worst case due to recursion depth.  The call stack can grow up to the amount.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming - Tabulation (Bottom-up)</h5>
  <p>Create a DP table `dp` of size `amount + 1`. `dp[i]` stores the minimum number of coins needed to make up amount `i`. Initialize `dp[0]` to 0 and all other entries to `amount + 1` (representing infinity). Iterate through the `dp` table from 1 to `amount`.  For each amount `i`, iterate through the coins. If a coin's value is less than or equal to `i`, update `dp[i]` with the minimum of its current value and `dp[i - coin] + 1`.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    int coinChange(vector&lt;int&gt;&amp; coins, int amount) {
        vector&lt;int&gt; dp(amount + 1, amount + 1);
        dp[0] = 0;

        for (int i = 1; i &lt;= amount; ++i) {
            for (int coin : coins) {
                if (coin &lt;= i) {
                    dp[i] = min(dp[i], dp[i - coin] + 1);
                }
            }
        }

        return dp[amount] &gt; amount ? -1 : dp[amount];
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(S * N), where S is the target amount and N is the number of coin denominations. | <b>Space Complexity:</b> O(S), where S is the target amount, for the DP table.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">coins = [1,2,5], amount = 11</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">11 = 5 + 5 + 1</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">coins = [2], amount = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Impossible to make 3 using only coins of value 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">coins = [1], amount = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Amount is already 0, no coins needed.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Important edge cases:

1.  `amount` is 0: Return 0 (no coins needed).
2.  `amount` is negative: No solution possible (handled in brute force).
3.  No combination of coins can form the amount: Return -1.
4.  Consider the case where the coins array is empty and amount > 0. The answer will be -1.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/decode-ways/>Decode Ways</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' -> 1, 'B' -> 2, ..., 'Z' -> 26. Given a string s containing only digits, return the number of ways to decode it.

The answer is guaranteed to fit in a 32-bit integer.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Recursively explore all possible decodings. At each digit, we can either decode it individually (if it's not '0') or combine it with the next digit (if the combined number is between 10 and 26 inclusive).</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int numDecodingsRecursive(const string& s, int index) {
    if (index == s.length()) {
        return 1; // Reached the end, one valid decoding
    }

    if (s[index] == '0') {
        return 0; // Invalid decoding, '0' cannot be decoded individually
    }

    int count = numDecodingsRecursive(s, index + 1); // Decode current digit

    if (index + 1 &lt; s.length()) {
        int twoDigit = stoi(s.substr(index, 2));
        if (twoDigit &gt;= 10 &amp;&amp; twoDigit &lt;= 26) {
            count += numDecodingsRecursive(s, index + 2); // Decode two digits
        }
    }

    return count;
}

int numDecodingsBruteForce(string s) {
    return numDecodingsRecursive(s, 0);
}

// int main() {
//     string s = "226";
//     cout &lt;&lt; numDecodingsBruteForce(s) &lt;&lt; endl; // Output: 3
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(2^n), where n is the length of the string.  Each recursive call makes at most two further recursive calls. | <b>Space Complexity:</b> O(n) due to the recursion depth.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming (Tabulation)</h5>
  <p>Use dynamic programming to store the number of ways to decode a prefix of the string.  dp[i] represents the number of ways to decode s[0...i-1]. The base case is dp[0] = 1 (empty string) and dp[1] depends on s[0]. Iterate through the string, and at each index i, consider decoding s[i-1] individually and s[i-2, i-1] as a two-digit number.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

int numDecodingsOptimized(string s) {
    int n = s.length();
    vector&lt;int&gt; dp(n + 1, 0);
    dp[0] = 1; // Empty string has one way to decode
    dp[1] = (s[0] == '0') ? 0 : 1; // One way if the first digit is not '0'

    for (int i = 2; i &lt;= n; ++i) {
        int oneDigit = stoi(s.substr(i - 1, 1));
        int twoDigits = stoi(s.substr(i - 2, 2));

        if (oneDigit &gt;= 1 &amp;&amp; oneDigit &lt;= 9) {
            dp[i] += dp[i - 1]; // Decode the last digit individually
        }

        if (twoDigits &gt;= 10 &amp;&amp; twoDigits &lt;= 26) {
            dp[i] += dp[i - 2]; // Decode the last two digits
        }
    }

    return dp[n];
}

// int main() {
//     string s = "226";
//     cout &lt;&lt; numDecodingsOptimized(s) &lt;&lt; endl; // Output: 3
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the length of the string.  We iterate through the string once. | <b>Space Complexity:</b> O(n) for the dp array.</p>
  <h5>‚û§ Dynamic Programming (Space Optimized)</h5>
  <p>Improve the previous solution by using only constant space. We only need to keep track of the previous two dp values.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int numDecodingsSpaceOptimized(string s) {
    int n = s.length();
    int prev2 = 1; // dp[i-2]
    int prev1 = (s[0] == '0') ? 0 : 1; // dp[i-1]

    for (int i = 2; i &lt;= n; ++i) {
        int current = 0;
        int oneDigit = stoi(s.substr(i - 1, 1));
        int twoDigits = stoi(s.substr(i - 2, 2));

        if (oneDigit &gt;= 1 &amp;&amp; oneDigit &lt;= 9) {
            current += prev1; 
        }

        if (twoDigits &gt;= 10 &amp;&amp; twoDigits &lt;= 26) {
            current += prev2;
        }
        
        prev2 = prev1;
        prev1 = current;
    }

    return prev1;
}

// int main() {
//     string s = "226";
//     cout &lt;&lt; numDecodingsSpaceOptimized(s) &lt;&lt; endl; // Output: 3
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(n) | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "12"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">"12" can be decoded as "AB" (1 2) or "L" (12).</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "226"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">"226" can be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "06"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The number cannot start with '0'.  Therefore, there are no valid decodings.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "11106"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The possible decodings are: (1 1 10 6) -> AAAF or (11 10 6) -> JAF.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Important edge cases include strings starting with '0', and cases where the two-digit combination is invalid (e.g., "01", "30"). The space-optimized DP solution is the most efficient approach.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/maximum-length-of-repeated-subarray/>Maximum Length of Repeated Subarray</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given two integer arrays `nums1` and `nums2`, return the maximum length of a subarray that appears in both arrays. </p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible subarrays of `nums1` and `nums2`. For each pair of subarrays, check if they are equal. Keep track of the maximum length found so far.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    int findLength(vector&lt;int&gt;& nums1, vector&lt;int&gt;& nums2) {
        int maxLen = 0;
        for (int i = 0; i &lt; nums1.size(); ++i) {
            for (int j = 0; j &lt; nums2.size(); ++j) {
                for (int len = 1; i + len &lt;= nums1.size() &amp;&amp; j + len &lt;= nums2.size(); ++len) {
                    bool match = true;
                    for (int k = 0; k &lt; len; ++k) {
                        if (nums1[i + k] != nums2[j + k]) {
                            match = false;
                            break;
                        }
                    }
                    if (match) {
                        maxLen = max(maxLen, len);
                    }
                }
            }
        }
        return maxLen;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(m * n * (min(m, n))) - where m and n are the sizes of nums1 and nums2 respectively.  The nested loops iterate through all possible starting positions of the subarrays. The inner loop of k checks for equality of the subarrays which has time complexity O(min(m, n)). | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming</h5>
  <p>Use dynamic programming. Create a 2D DP table where `dp[i][j]` stores the length of the longest common subarray ending at `nums1[i-1]` and `nums2[j-1]`. Iterate through the arrays, and if `nums1[i-1] == nums2[j-1]`, then `dp[i][j] = dp[i-1][j-1] + 1`. Keep track of the maximum value in the DP table.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    int findLength(vector&lt;int&gt;& nums1, vector&lt;int&gt;& nums2) {
        int m = nums1.size();
        int n = nums2.size();
        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));
        int maxLen = 0;

        for (int i = 1; i &lt;= m; ++i) {
            for (int j = 1; j &lt;= n; ++j) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    maxLen = max(maxLen, dp[i][j]);
                }
            }
        }
        return maxLen;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(m * n) - where m and n are the sizes of nums1 and nums2 respectively.  The nested loops iterate through the entire DP table. | <b>Space Complexity:</b> O(m * n)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The longest common subarray is [3,2,1].</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The longest common subarray is [0,0,0,0,0].</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums1 = [1,2,3,2,1], nums2 = [1,2,3,2,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The longest common subarray is [1,2,3,2,1].</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums1 = [0,1,1,1,1], nums2 = [1,0,1,1,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The longest common subarray is [0,1,1,1] or [1,1,1].</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The dynamic programming solution is much more efficient than the brute-force solution. Consider edge cases like empty input arrays and arrays with no common subarrays.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/longest-increasing-subsequence/>Longest Increasing Subsequence</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an integer array `nums`, return the length of the longest strictly increasing subsequence. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, `[3,6,2,7]` is a subsequence of `[0,3,1,6,2,2,7]`.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Generate all possible subsequences and check for each subsequence if it is increasing. If it is increasing, keep track of the maximum length found so far.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int lengthOfLIS_bruteForce(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    int maxLength = 0;

    for (int i = 0; i &lt; (1 &lt;&lt; n); ++i) {
        vector&lt;int&gt; subsequence;
        for (int j = 0; j &lt; n; ++j) {
            if ((i &amp; (1 &lt;&lt; j)) != 0) {
                subsequence.push_back(nums[j]);
            }
        }

        bool isIncreasing = true;
        for (int k = 1; k &lt; subsequence.size(); ++k) {
            if (subsequence[k] &lt;= subsequence[k - 1]) {
                isIncreasing = false;
                break;
            }
        }

        if (isIncreasing) {
            maxLength = max(maxLength, (int)subsequence.size());
        }
    }

    return maxLength;
}
</code></pre>
  <p><b>Time Complexity:</b> O(2^n * n) - Generating all subsequences takes O(2^n) and checking if a subsequence is increasing takes O(n) | <b>Space Complexity:</b> O(n) -  Space for storing the subsequence in the worst case.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming (Tabulation)</h5>
  <p>Use dynamic programming to store the length of the longest increasing subsequence ending at each index. Iterate through the array and for each element, compare it with the previous elements. If the current element is greater than a previous element, update the length of the LIS ending at the current element with the maximum length found so far.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int lengthOfLIS_dp(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    vector&lt;int&gt; dp(n, 1); // Initialize dp array with 1, as each element itself forms an LIS of length 1
    int maxLength = 1;  // Initialize maxLength to 1

    for (int i = 1; i &lt; n; ++i) {
        for (int j = 0; j &lt; i; ++j) {
            if (nums[i] &gt; nums[j]) {
                dp[i] = max(dp[i], dp[j] + 1); // Update dp[i] if a longer LIS is found
            }
        }
        maxLength = max(maxLength, dp[i]); // Keep track of overall maximum length
    }

    return maxLength;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) - Nested loops iterating through the array. | <b>Space Complexity:</b> O(n) - Space for the dp array.</p>
  <h5>‚û§ Dynamic Programming with Binary Search</h5>
  <p>Use dynamic programming combined with binary search to optimize the time complexity. Maintain a `tails` array, where `tails[i]` stores the smallest tail of all increasing subsequences with length `i+1`.  Iterate through the input array. For each element, perform a binary search in `tails` to find the smallest tail that is greater than or equal to the current element. If such a tail exists, replace it with the current element; otherwise, append the current element to `tails`. The length of `tails` will be the length of the LIS.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int lengthOfLIS_optimized(vector&lt;int&gt;&amp; nums) {
    vector&lt;int&gt; tails;
    for (int num : nums) {
        auto it = lower_bound(tails.begin(), tails.end(), num);
        if (it == tails.end()) {
            tails.push_back(num);
        } else {
            *it = num;
        }
    }
    return tails.size();
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log n) - Iterating through the input array (O(n)) and performing binary search (O(log n)) for each element. | <b>Space Complexity:</b> O(n) - Space for the tails array in the worst-case scenario where the input is an increasing sequence.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [10,9,2,5,3,7,101,18]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The longest increasing subsequence is [2,3,7,101], therefore the length is 4.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [0,1,0,3,2,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The longest increasing subsequence is [0, 1, 2, 3], therefore the length is 4.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [7,7,7,7,7,7,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The longest increasing subsequence is [7], therefore the length is 1.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases include an empty input array, an array with all identical elements, and an array that is already sorted in increasing or decreasing order. The optimized solution using binary search provides significant performance improvement compared to the brute-force and the naive dynamic programming solution when the input array is large.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/longest-common-substring1452/1>Longest Common Substring</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given two strings, S1 and S2, find the length of the longest common substring. A substring is a contiguous sequence of characters within a string.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible substrings of S1 and S2 and compare them. For each substring of S1, check if it exists in S2.  Keep track of the longest common substring found so far.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int longestCommonSubstring(string S1, string S2, int n, int m) {
    int maxLength = 0;
    for (int i = 0; i &lt n; i++) {
        for (int j = 0; j &lt m; j++) {
            for (int len = 1; i + len &lt= n &amp;&amp; j + len &lt= m; len++) {
                if (S1.substr(i, len) == S2.substr(j, len)) {
                    maxLength = max(maxLength, len);
                }
            }
        }
    }
    return maxLength;
}

int main() {
    string S1 = "ABCDGH";
    string S2 = "ACDGHR";
    int n = S1.length();
    int m = S2.length();
    cout &lt&lt longestCommonSubstring(S1, S2, n, m) &lt&lt endl;
    return 0;
}</code></pre>
  <p><b>Time Complexity:</b> O(n*m*min(n, m)), where n and m are the lengths of the strings S1 and S2, respectively. The nested loops contribute O(n*m), and substring comparison takes O(min(n,m)) in the worst case. | <b>Space Complexity:</b> O(1) - Constant extra space is used.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming</h5>
  <p>Use dynamic programming to build a table where each cell (i, j) represents the length of the longest common substring ending at S1[i-1] and S2[j-1].  If S1[i-1] == S2[j-1], then dp[i][j] = dp[i-1][j-1] + 1. Otherwise, dp[i][j] = 0. Keep track of the maximum value in the dp table.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int longestCommonSubstring(string S1, string S2, int n, int m) {
    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0));
    int maxLength = 0;

    for (int i = 1; i &lt= n; i++) {
        for (int j = 1; j &lt= m; j++) {
            if (S1[i - 1] == S2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
                maxLength = max(maxLength, dp[i][j]);
            } else {
                dp[i][j] = 0;
            }
        }
    }
    return maxLength;
}

int main() {
    string S1 = "ABCDGH";
    string S2 = "ACDGHR";
    int n = S1.length();
    int m = S2.length();
    cout &lt&lt longestCommonSubstring(S1, S2, n, m) &lt&lt endl;
    return 0;
}</code></pre>
  <p><b>Time Complexity:</b> O(n*m) - We iterate through the dp table of size (n+1) * (m+1) once. | <b>Space Complexity:</b> O(n*m) - The DP table of size (n+1) * (m+1) is used.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">S1 = "ABCDGH", S2 = "ACDGHR"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The longest common substring is "CDGH", which has length 4.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">S1 = "ABABC", S2 = "BABC"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The longest common substring is "BABC", which has length 4.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">S1 = "ABC", S2 = "XYZ"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There are no common substrings.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. Edge cases include empty strings. The longest common substring will be of length 0 in those cases. 2.  The dynamic programming approach is generally preferred for its efficiency. 3.  The problem asks for the length of the substring, not the substring itself. If the substring is required, you can store the starting indices in a variable while computing the DP table.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/count-square-submatrices-with-all-ones/>Count Square Submatrices with All Ones</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a m * n matrix of ones and zeros, return how many square submatrices have all ones.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible submatrices and check if all elements within the submatrix are 1s.  For each cell as the top-left corner, consider all possible square sizes.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int countSquaresBruteForce(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
    int rows = matrix.size();
    int cols = matrix[0].size();
    int count = 0;

    for (int i = 0; i &lt; rows; ++i) {
        for (int j = 0; j &lt; cols; ++j) {
            for (int size = 1; i + size &lt;= rows &amp;&amp; j + size &lt;= cols; ++size) {
                bool allOnes = true;
                for (int row = i; row &lt; i + size; ++row) {
                    for (int col = j; col &lt; j + size; ++col) {
                        if (matrix[row][col] == 0) {
                            allOnes = false;
                            break;
                        }
                    }
                    if (!allOnes) break;
                }
                if (allOnes) {
                    count++;
                }
            }
        }
    }
    return count;
}
</code></pre>
  <p><b>Time Complexity:</b> O(m^2 * n^2 * min(m, n)), where m is the number of rows and n is the number of columns.  We iterate through all possible starting points (m*n), for each starting point, we iterate through possible sizes (min(m,n)), and for each size, we check the elements (size*size) which could be up to min(m,n)^2. | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming</h5>
  <p>Use dynamic programming to store the size of the largest square submatrix with all ones that has the current cell as the bottom-right corner. The size is calculated based on the sizes of the squares to the top, left, and top-left of the current cell.  If the current cell is 1, then the size is min(top, left, top-left) + 1. The total count is the sum of all the square sizes at each cell.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int countSquaresOptimized(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
    int rows = matrix.size();
    int cols = matrix[0].size();
    vector&lt;vector&lt;int&gt;&gt; dp(rows, vector&lt;int&gt;(cols, 0));
    int count = 0;

    for (int i = 0; i &lt; rows; ++i) {
        for (int j = 0; j &lt; cols; ++j) {
            if (matrix[i][j] == 1) {
                if (i == 0 || j == 0) {
                    dp[i][j] = 1;
                } else {
                    dp[i][j] = min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]}) + 1;
                }
                count += dp[i][j];
            }
        }
    }
    return count;
}
</code></pre>
  <p><b>Time Complexity:</b> O(m * n), where m is the number of rows and n is the number of columns. We iterate through each cell of the matrix once. | <b>Space Complexity:</b> O(m * n) due to the dp table.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0,1,1,1],[1,1,1,1],[0,1,1,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">15</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There are 10 squares of side 1. There are 4 squares of side 2. There is 1 square of side 3. Total = 10 + 4 + 1 = 15.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,0,1],[1,1,0],[1,1,0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">7</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There are 6 squares of side 1. There is 1 square of side 2. Total = 6 + 1 = 7.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0, 0, 0],[0, 0, 0],[0, 0, 0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There are no ones to form a square. Hence the answer is 0.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The dynamic programming approach significantly improves the efficiency of the solution. Edge cases to consider: Empty matrix (m or n is 0), matrix with all zeros, and matrix with all ones. The DP approach is generally preferred because it avoids redundant calculations.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/maximal-square/>Maximal Square</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible squares within the matrix. For each cell, consider it as the top-left corner of a potential square. Check squares of increasing size, from 1x1 up to the maximum possible size, and check if all cells within the square are 1s. Keep track of the largest square found so far.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int maximalSquareBruteForce(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
    if (matrix.empty() || matrix[0].empty()) {
        return 0;
    }
    int rows = matrix.size();
    int cols = matrix[0].size();
    int maxSide = 0;

    for (int i = 0; i &lt rows; ++i) {
        for (int j = 0; j &lt cols; ++j) {
            if (matrix[i][j] == '1') {
                for (int side = 1; side &lt= min(rows - i, cols - j); ++side) {
                    bool isSquare = true;
                    for (int row = i; row &lt i + side; ++row) {
                        for (int col = j; col &lt j + side; ++col) {
                            if (matrix[row][col] == '0') {
                                isSquare = false;
                                break;
                            }
                        }
                        if (!isSquare) {
                            break;
                        }
                    }
                    if (isSquare) {
                        maxSide = max(maxSide, side);
                    } else {
                        break; // Optimization: If a square of a certain size is not valid, no larger square starting from the same cell will be valid.
                    }
                }
            }
        }
    }

    return maxSide * maxSide;
}
</code></pre>
  <p><b>Time Complexity:</b> O(m^2 * n^2 * min(m, n)) - We iterate through each cell (m * n), and for each cell, we potentially check squares of size up to min(m, n), and checking each square takes O(min(m, n)) time.  | <b>Space Complexity:</b> O(1) - Constant extra space is used.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming (Tabulation)</h5>
  <p>Use dynamic programming to store the side length of the largest square that can be formed with the current cell as the bottom-right corner. If the current cell is '1', its value depends on the values of its neighbors (top, left, and top-left). Specifically, dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1. The result is the square of the maximum value in the dp table.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int maximalSquareDP(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
    if (matrix.empty() || matrix[0].empty()) {
        return 0;
    }

    int rows = matrix.size();
    int cols = matrix[0].size();
    vector&lt;vector&lt;int&gt;&gt; dp(rows, vector&lt;int&gt;(cols, 0));
    int maxSide = 0;

    for (int i = 0; i &lt rows; ++i) {
        for (int j = 0; j &lt cols; ++j) {
            if (matrix[i][j] == '1') {
                if (i == 0 || j == 0) {
                    dp[i][j] = 1;
                } else {
                    dp[i][j] = min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]}) + 1;
                }
                maxSide = max(maxSide, dp[i][j]);
            }
        }
    }

    return maxSide * maxSide;
}
</code></pre>
  <p><b>Time Complexity:</b> O(m * n) - We iterate through each cell in the matrix once. | <b>Space Complexity:</b> O(m * n) -  The dp table has the same dimensions as the input matrix.</p>
  <h5>‚û§ Dynamic Programming (Optimized Space)</h5>
  <p>Optimize the dynamic programming approach by using only a single row of the dp table. This reduces the space complexity from O(m*n) to O(n). Instead of using dp[i-1][j], dp[i][j-1], and dp[i-1][j-1], we can store only the current and previous row's information with variables.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int maximalSquareDPOptimized(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
    if (matrix.empty() || matrix[0].empty()) {
        return 0;
    }

    int rows = matrix.size();
    int cols = matrix[0].size();
    vector&lt;int&gt; dp(cols, 0);
    int maxSide = 0, prev = 0;

    for (int i = 0; i &lt rows; ++i) {
        for (int j = 0; j &lt cols; ++j) {
            int temp = dp[j];
            if (matrix[i][j] == '1') {
                if (i == 0 || j == 0) {
                    dp[j] = 1;
                } else {
                    dp[j] = min({dp[j - 1], prev, dp[j]}) + 1;
                }
                maxSide = max(maxSide, dp[j]);
            } else {
                dp[j] = 0;
            }
            prev = temp;
        }
    }

    return maxSide * maxSide;
}
</code></pre>
  <p><b>Time Complexity:</b> O(m * n) - We iterate through each cell in the matrix once. | <b>Space Complexity:</b> O(n) - We use a dp array of size equal to the number of columns.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The largest square has side length 2, with an area of 4.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[["0","1"],["1","0"]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The largest square has side length 1, with an area of 1.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[["0","0","0"],["0","0","0"]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There are no squares with side length greater than 0.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases include empty input matrix, matrix with only 0s, and matrices where the maximum square is of size 1. The optimized DP solution is preferred due to its superior space complexity. The brute force solution's optimization helps reduce the number of computations but the worst-case time complexity is still high.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/mobile-numeric-keypad5456/1>Mobile Numeric Keypad</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a number N. The task is to find the number of possible numbers of the given length. We are allowed to press the number on the keypad only once and the digits are like a mobile keypad. Allowed moves are up, down, left and right. For example, if we are at digit 1, we can go to 2 and 4. We can not go to the corner digits like * and #. Also, you can start from any digit. For example: For N=2, the answer is 26.

Keypad:
1 2 3
4 5 6
7 8 9
* 0 #</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach would involve recursion to explore all possible paths. For each digit, recursively call the function for all valid neighboring digits and repeat this N times. However, this is highly inefficient and likely to exceed time limits for larger values of N.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int keypad[4][3] = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9},
    {-1, 0, -1}
};

int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};

bool isValid(int x, int y) {
    return x &gt= 0 &amp;&amp; x &lt 4 &amp;&amp; y &gt= 0 &amp;&amp; y &lt 3 &amp;&amp; keypad[x][y] != -1;
}

int solveRec(int n, int row, int col) {
    if (n == 1)
        return 1;

    int count = 0;
    for (int i = 0; i &lt 4; i++) {
        int newRow = row + dx[i];
        int newCol = col + dy[i];
        if (isValid(newRow, newCol)) {
            count += solveRec(n - 1, newRow, newCol);
        }
    }
    return count;
}

int getCountBruteForce(int n) {
    int totalCount = 0;
    for (int i = 0; i &lt 4; i++) {
        for (int j = 0; j &lt 3; j++) {
            if (keypad[i][j] != -1) {
                totalCount += solveRec(n, i, j);
            }
        }
    }
    return totalCount;
}

int main() {
    int n = 2;
    cout &lt&lt; getCountBruteForce(n) &lt&lt; endl;
    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(4^N), exponential due to recursive calls for each digit in the sequence. | <b>Space Complexity:</b> O(N), due to the recursion depth.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming (Tabulation)</h5>
  <p>This approach utilizes dynamic programming (tabulation) to optimize the solution. We create a 3D DP table where dp[i][j][k] stores the number of possible sequences of length i ending at the digit represented by row j, col k. The table is filled iteratively, and the final result is the sum of all entries in the last layer (i=N) of the DP table. This avoids redundant calculations by storing and reusing the results.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int keypad[4][3] = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9},
    {-1, 0, -1}
};

int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};

bool isValid(int x, int y) {
    return x &gt= 0 &amp;&amp; x &lt 4 &amp;&amp; y &gt= 0 &amp;&amp; y &lt 3 &amp;&amp; keypad[x][y] != -1;
}

int getCountDP(int n) {
    int dp[n + 1][4][3];
    memset(dp, 0, sizeof(dp));

    for (int i = 0; i &lt 4; i++) {
        for (int j = 0; j &lt 3; j++) {
            if (keypad[i][j] != -1) {
                dp[1][i][j] = 1;
            }
        }
    }

    for (int len = 2; len &lt= n; len++) {
        for (int i = 0; i &lt 4; i++) {
            for (int j = 0; j &lt; 3; j++) {
                if (keypad[i][j] != -1) {
                    for (int k = 0; k &lt; 4; k++) {
                        int prevRow = i + dx[k];
                        int prevCol = j + dy[k];
                        if (isValid(prevRow, prevCol)) {
                            dp[len][i][j] += dp[len - 1][prevRow][prevCol];
                        }
                    }
                }
            }
        }
    }

    int totalCount = 0;
    for (int i = 0; i &lt; 4; i++) {
        for (int j = 0; j &lt; 3; j++) {
            totalCount += dp[n][i][j];
        }
    }
    return totalCount;
}

int main() {
    int n = 2;
    cout &lt&lt; getCountDP(n) &lt&lt; endl;
    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N * 12), where N is the length of the number.  The loops iterate over sequence length (N), rows (4), and columns (3) and the neighboring digit(4) | <b>Space Complexity:</b> O(N) due to the DP table of size (N+1) * 4 * 3</p>
  <h5>‚û§ Optimized DP (Space Optimization)</h5>
  <p>The previous DP approach can be optimized to reduce the space complexity to O(1) by using only two rows of the DP table. The current row of the DP table only depends on the previous row.  We can use two 2D arrays to keep track of the current and the previous states.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int keypad[4][3] = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9},
    {-1, 0, -1}
};

int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};

bool isValid(int x, int y) {
    return x &gt= 0 &amp;&amp; x &lt 4 &amp;&amp; y &gt= 0 &amp;&amp; y &lt 3 &amp;&amp; keypad[x][y] != -1;
}

int getCountOptimizedDP(int n) {
    int dp[2][4][3]; // Optimized space
    memset(dp, 0, sizeof(dp));

    for (int i = 0; i &lt; 4; i++) {
        for (int j = 0; j &lt; 3; j++) {
            if (keypad[i][j] != -1) {
                dp[1][i][j] = 1;
            }
        }
    }

    for (int len = 2; len &lt= n; len++) {
        for (int i = 0; i &lt; 4; i++) {
            for (int j = 0; j &lt; 3; j++) {
                dp[len % 2][i][j] = 0; // Reset current cell
                if (keypad[i][j] != -1) {
                    for (int k = 0; k &lt; 4; k++) {
                        int prevRow = i + dx[k];
                        int prevCol = j + dy[k];
                        if (isValid(prevRow, prevCol)) {
                            dp[len % 2][i][j] += dp[(len - 1) % 2][prevRow][prevCol];
                        }
                    }
                }
            }
        }
    }

    int totalCount = 0;
    for (int i = 0; i &lt; 4; i++) {
        for (int j = 0; j &lt; 3; j++) {
            totalCount += dp[n % 2][i][j];
        }
    }
    return totalCount;
}

int main() {
    int n = 2;
    cout &lt&lt; getCountOptimizedDP(n) &lt&lt; endl;
    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N * 12) | <b>Space Complexity:</b> O(1)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">N = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">10</td>
        <td style="border: 1px solid #ccc; padding: 6px;">For N = 1, any digit from 0-9 can be pressed once.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">N = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">26</td>
        <td style="border: 1px solid #ccc; padding: 6px;">For N = 2, some possible sequences are: 12, 14, 21, 23, 25, 32, 36, ...</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">N = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">64</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Example Sequences: 121, 123, 125, 141, 145</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The keypad layout is fixed (3x4). 
2. Digits '*' and '#' are not allowed in the sequence. 
3. The problem is to calculate the *number* of possible sequences and the order does matter. 
4.  Edge cases to consider include N=1, N=0 (though not explicitly mentioned). N=0 should return 0 as it's impossible to generate a number with 0 digits. For this specific problem, we implicitly assume that N &gt= 1. 
5.  Space optimization is key to efficient solutions.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/weighted-job-scheduling/>Weighted Job Scheduling</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a set of jobs where each job has a start time, finish time, and profit, find the maximum profit subset of non-overlapping jobs.  Two jobs are non-overlapping if they don't share any common time. 

In other words, maximize the total profit by selecting a subset of jobs such that no two jobs in the subset overlap.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Generate all possible subsets of jobs. For each subset, check if the jobs are non-overlapping. If they are, calculate the profit. Return the maximum profit found across all valid subsets.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Job {
    int start, finish, profit;
};

// Function to check if two jobs overlap
bool doOverlap(Job j1, Job j2) {
    return (j1.start &lt j2.finish) &amp;&amp; (j2.start &lt j1.finish);
}

// Function to find the maximum profit using brute force
int maxProfitBruteForce(vector&lt;Job&gt;&amp; jobs, int n) {
    int maxProfit = 0;
    for (int i = 0; i &lt (1 &lt&lt n); ++i) {
        int currentProfit = 0;
        vector&lt;Job&gt; selectedJobs;
        for (int j = 0; j &lt n; ++j) {
            if ((i &gt;&gt; j) &amp; 1) {
                selectedJobs.push_back(jobs[j]);
            }
        }

        bool overlap = false;
        for (int j = 0; j &lt selectedJobs.size(); ++j) {
            for (int k = j + 1; k &lt selectedJobs.size(); ++k) {
                if (doOverlap(selectedJobs[j], selectedJobs[k])) {
                    overlap = true;
                    break;
                }
            }
            if (overlap) break;
        }

        if (!overlap) {
            for (const auto&amp; job : selectedJobs) {
                currentProfit += job.profit;
            }
            maxProfit = max(maxProfit, currentProfit);
        }
    }
    return maxProfit;
}
</code></pre>
  <p><b>Time Complexity:</b> O(2^n * n), where n is the number of jobs. Generating all subsets takes O(2^n) time. Checking for overlaps in each subset takes O(n) in the worst case. | <b>Space Complexity:</b> O(n) to store the selected jobs in the worst-case scenario (when all jobs are selected, which will get discarded due to overlaps).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming (Memoization)</h5>
  <p>Sort jobs by finish time. Define dp[i] as the maximum profit achievable considering jobs up to index i (inclusive).  For each job i, two choices: either include it or exclude it. If included, find the latest non-overlapping job before i. Otherwise, take the profit from including the previous job. Memoize to avoid recomputation.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Job {
    int start, finish, profit;
};

// Function to find the latest job that doesn't overlap with the current job
int latestNonOverlappingJob(vector&lt;Job&gt;&amp; jobs, int i) {
    for (int j = i - 1; j &gt;= 0; j--) {
        if (jobs[j].finish &lt= jobs[i].start) {
            return j;
        }
    }
    return -1;
}

// Function to find the maximum profit using dynamic programming (memoization)
int maxProfitDP(vector&lt;Job&gt;&amp; jobs, int n, vector&lt;int&gt;&amp; dp) {
    if (n &lt 0) {
        return 0;
    }

    if (dp[n] != -1) {
        return dp[n];
    }

    // Find the latest non-overlapping job
    int prev = latestNonOverlappingJob(jobs, n);

    // Include current job and add its profit to the profit of the latest non-overlapping job
    int includeProfit = jobs[n].profit;
    if (prev != -1) {
        includeProfit += maxProfitDP(jobs, prev, dp);
    }

    // Exclude current job and consider the maximum profit up to the previous job
    int excludeProfit = maxProfitDP(jobs, n - 1, dp);

    dp[n] = max(includeProfit, excludeProfit);
    return dp[n];
}

int maxProfitScheduling(vector&lt;Job&gt;&amp; jobs) {
    int n = jobs.size();
    sort(jobs.begin(), jobs.end(), [](const Job&amp; a, const Job&amp; b) {
        return a.finish &lt b.finish;
    });
    vector&lt;int&gt; dp(n, -1);
    return maxProfitDP(jobs, n - 1, dp);
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log n) for sorting + O(n) for DP.  Overall, O(n log n) where n is the number of jobs. | <b>Space Complexity:</b> O(n) for the dp array and for the recursion call stack (in worst case).</p>
  <h5>‚û§ Dynamic Programming (Tabulation)</h5>
  <p>Sort jobs by finish time. Initialize dp[i] to store the maximum profit up to job i. Iterate through the sorted jobs. For each job i, calculate the profit by either including it (add its profit to the profit of the latest non-overlapping job) or excluding it (take the profit from the previous job). Use a loop for iteration instead of recursion.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct Job {
    int start, finish, profit;
};

// Function to find the latest job that doesn't overlap with the current job
int latestNonOverlappingJob(const vector&lt;Job&gt;&amp; jobs, int i) {
    for (int j = i - 1; j &gt;= 0; j--) {
        if (jobs[j].finish &lt= jobs[i].start) {
            return j;
        }
    }
    return -1;
}

// Function to find the maximum profit using dynamic programming (tabulation)
int maxProfitTabulation(vector&lt;Job&gt;&amp; jobs) {
    int n = jobs.size();
    vector&lt;int&gt; dp(n, 0);

    // Sort jobs by finish time
    sort(jobs.begin(), jobs.end(), [](const Job&amp; a, const Job&amp; b) {
        return a.finish &lt b.finish;
    });

    // Base case: profit of the first job
    dp[0] = jobs[0].profit;

    // Iterate through the remaining jobs
    for (int i = 1; i &lt n; i++) {
        // Include current job
        int includeProfit = jobs[i].profit;
        int prev = latestNonOverlappingJob(jobs, i);
        if (prev != -1) {
            includeProfit += dp[prev];
        }

        // Exclude current job
        int excludeProfit = dp[i - 1];

        // Choose the maximum profit
        dp[i] = max(includeProfit, excludeProfit);
    }

    return dp[n - 1];
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log n) for sorting + O(n) for DP.  Overall, O(n log n) where n is the number of jobs. | <b>Space Complexity:</b> O(n) for the dp array.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">jobs = {{1, 2, 50}, {3, 5, 20}, {6, 19, 100}, {2, 100, 200}}
</td>
        <td style="border: 1px solid #ccc; padding: 6px;">300</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Choose jobs { {1, 2, 50}, {6, 19, 100}, {2, 100, 200} } which are non overlapping and gives maximum profit.  Profit is 50 + 100 + 200 = 300.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">jobs = {{1, 2, 5}, {2, 3, 6}, {3, 4, 5}}
</td>
        <td style="border: 1px solid #ccc; padding: 6px;">11</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Choose jobs { {1, 2, 5}, {3, 4, 5} } or  { {2, 3, 6} } which gives maximum profit. Profit is 5 + 5 = 10 (or 6).</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. **Sorting:** Sorting jobs by finish time is crucial for the dynamic programming approaches to efficiently find the latest non-overlapping jobs. 
2. **Overlapping Check:**  The `doOverlap` function or the logic within the DP approach efficiently detects overlapping jobs. 
3. **Time Complexity Trade-off:** The brute-force solution has an exponential time complexity, while the dynamic programming solutions offer a significantly better performance (O(n log n)) by trading space for time through the use of dynamic programming.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/delete-and-earn/>Delete and Earn</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>You are given an integer array `nums`. You want to maximize the number of points you can get by performing the following operations:

1.  You can choose any element `nums[i]` and delete it to earn `nums[i]` points.
2.  After deleting `nums[i]`, you must delete all elements equal to `nums[i] - 1` and `nums[i] + 1`.

Return the maximum number of points you can earn by applying the above operations.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>This approach explores all possible combinations of deleting numbers. For each number, we have two choices: either delete it and consequently delete its neighbors, or skip it. This leads to an exponential time complexity due to the recursive nature of exploring all possibilities. This isn't practical, and it will exceed the time limit.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int deleteAndEarnRecursive(vector&lt;int&gt;& nums, int index, map&lt;int, int&gt;& counts) {
    if (index &gt= counts.size()) {
        return 0;
    }

    auto it = counts.begin();
    advance(it, index);
    int num = it-&gt;first;
    int count = it-&gt;second;

    int earn = num * count;
    int skipNext = deleteAndEarnRecursive(nums, index + 1, counts);

    int nextIndex = index + 1;
    while(nextIndex &lt counts.size()) {
        auto nextIt = counts.begin();
        advance(nextIt, nextIndex);
        int nextNum = nextIt-&gt;first;
        if(nextNum == num + 1) {
            break;
        }
        nextIndex++;
    }

    int take = earn + deleteAndEarnRecursive(nums, nextIndex == counts.size() ? nextIndex : nextIndex + 1, counts);

    return max(take, skipNext);
}

int deleteAndEarnBruteForce(vector&lt;int&gt;& nums) {
    map&lt;int, int&gt; counts;
    for (int num : nums) {
        counts[num]++;
    }

    return deleteAndEarnRecursive(nums, 0, counts);
}
</code></pre>
  <p><b>Time Complexity:</b> O(2^N) - Exponential, where N is the number of unique elements in the input. | <b>Space Complexity:</b> O(N) - Due to the recursion depth and the hash map used to store counts.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming (House Robber Analogy)</h5>
  <p>The problem can be reframed as a variation of the House Robber problem. First, we count the frequency of each number. Then, we iterate through the unique numbers and build up two arrays: `dp_take` and `dp_skip`. `dp_take[i]` represents the maximum points we can earn if we take the number at index `i`. `dp_skip[i]` is if we skip the number at index `i`.  We use dynamic programming to build up the solutions. The key insight is that we can't take adjacent numbers. If we take a number, we skip the next adjacent number.  If we skip a number, we consider both taking and skipping the next number.  The final answer is the maximum of the last `dp_take` and `dp_skip` elements. This avoids redundant calculations by building up the optimal solution incrementally.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int deleteAndEarn(vector&lt;int&gt;& nums) {
    map&lt;int, int&gt; counts;
    for (int num : nums) {
        counts[num]++;
    }

    vector&lt;int&gt; uniqueNums;
    for (auto const&amp; [key, val] : counts) {
        uniqueNums.push_back(key);
    }

    int n = uniqueNums.size();
    if (n == 0) return 0;

    vector&lt;int&gt; dp_take(n, 0);
    vector&lt;int&gt; dp_skip(n, 0);

    dp_take[0] = uniqueNums[0] * counts[uniqueNums[0]];
    dp_skip[0] = 0;

    for (int i = 1; i &lt n; ++i) {
        int currentNum = uniqueNums[i];
        int prevNum = uniqueNums[i - 1];

        if (currentNum == prevNum + 1) {
            dp_take[i] = dp_skip[i - 1] + currentNum * counts[currentNum];
            dp_skip[i] = max(dp_take[i - 1], dp_skip[i - 1]);
        } else {
            dp_take[i] = max(dp_take[i - 1], dp_skip[i-1]) + currentNum * counts[currentNum];
            dp_skip[i] = max(dp_take[i-1], dp_skip[i - 1]);
        }
    }

    return max(dp_take[n - 1], dp_skip[n - 1]);
}
</code></pre>
  <p><b>Time Complexity:</b> O(N + M) where N is the number of elements in nums and M is the range of numbers in nums.  In the first pass, we count frequencies, O(N).  In the second pass, we iterate through the sorted unique numbers, which, in the worst case, can be bounded by the range of input numbers. | <b>Space Complexity:</b> O(M) where M is the range of numbers in nums.  The space is dominated by the hash map (for counting frequencies) and, implicitly, the dynamic programming arrays (dp_take and dp_skip) if the range of numbers is large.</p>
  <h5>‚û§ Optimized Dynamic Programming</h5>
  <p>Instead of storing all unique numbers, we first count the frequency of each number in `nums`. Then, we use dynamic programming to find the maximum points, but we only store `dp_take` and `dp_skip` for the current and previous number, optimizing space. For each number, we decide whether to take it (and skip the numbers num - 1 and num + 1), or skip it. This reduces the space complexity.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int deleteAndEarnOptimized(vector&lt;int&gt;& nums) {
    map&lt;int, int&gt; counts;
    for (int num : nums) {
        counts[num]++;
    }

    int prevSkip = 0;
    int prevTake = 0;

    int currentNum = -1; 

    for (auto const&amp; [num, count] : counts) {
        if (currentNum == -1) {
            prevTake = num * count;
            currentNum = num;
            continue;
        }
        
        int take = 0, skip = 0;
        if (num == currentNum + 1) {
            take = prevSkip + num * count;
            skip = max(prevTake, prevSkip);
        } else {
           take = max(prevTake, prevSkip) + num * count;
           skip = max(prevTake, prevSkip);
        }

        prevSkip = skip;
        prevTake = take;
        currentNum = num;
    }

    return max(prevTake, prevSkip);
}
</code></pre>
  <p><b>Time Complexity:</b> O(N + M) where N is the number of elements in nums and M is the range of numbers. Counting frequencies takes O(N), and the DP loop iterates through the numbers, which, in the worst case, can be bounded by the range of input numbers. | <b>Space Complexity:</b> O(M) where M is the range of the numbers in nums. The space is dominated by the counts map which can store the frequencies for all distinct numbers.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [3,4,2,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Delete 2 to earn 2 points. Then delete 3 to earn 3 points. Then delete 4 to earn 4 points. Total: 2 + 3 + 1 = 6 points.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [2,2,3,3,3,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">9</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Delete 3 and 4. 2+2+3+3+3 = 9</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,1,1,2,4,5,5,5,6]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">13</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Taking 1 gives 3 points. Taking 5 gives 15 points, but we already took 1 so we cannot take adjacent numbers. So take 1 and 5, which yields 3 + 15 = 18. But the highest possible number we can earn is 13. Taking 2, 4 and 6.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Simply delete 1.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1, 2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Delete 1 or delete 2; can't delete both; choose the larger one.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The core idea is to avoid taking adjacent numbers. The dynamic programming approach efficiently handles this by keeping track of the maximum points achievable by either taking or skipping a number, and then using this information for subsequent calculations. Consider the case when the numbers in the input are spread apart. In these cases, we can take the numbers that are not adjacent, and we will be able to accumulate the most points.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/range-sum-query-2d-immutable/>Range Sum Query 2D - Immutable</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a 2D matrix, implement a class `NumMatrix` that supports the following operations:

*   `NumMatrix(int[][] matrix)`: Initializes the `NumMatrix` object with the given 2D matrix.
*   `int sumRegion(int row1, int col1, int row2, int col2)`: Returns the sum of all the elements within the submatrix defined by its upper left corner `(row1, col1)` and lower right corner `(row2, col2)`.

You may assume that the input matrix will not be modified after the initial call.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all elements within the given range and sum them up.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt

using namespace std;

class NumMatrix {
public:
    vector&lt;vector&lt;int&gt;&gt; matrix;
    NumMatrix(vector&lt;vector&lt;int&gt;&gt;& matrix_) : matrix(matrix_) {}

    int sumRegion(int row1, int col1, int row2, int col2) {
        int sum = 0;
        for (int i = row1; i &lt;= row2; ++i) {
            for (int j = col1; j &lt;= col2; ++j) {
                sum += matrix[i][j];
            }
        }
        return sum;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(R * C * Q), where R and C are the average number of rows and columns in a query, and Q is the number of queries. | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Prefix Sum</h5>
  <p>Calculate a prefix sum matrix. The prefix sum at any cell (i, j) stores the sum of all elements from (0, 0) to (i, j). Then, to find the sum of a submatrix defined by (row1, col1) and (row2, col2), we can use the prefix sums. The sum is equal to prefixSum[row2][col2] - prefixSum[row1-1][col2] - prefixSum[row2][col1-1] + prefixSum[row1-1][col1-1]. We use -1 and/or edge cases for out-of-bounds checks.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt

using namespace std;

class NumMatrix {
public:
    vector&lt;vector&lt;int&gt;&gt; prefixSum;

    NumMatrix(vector&lt;vector&lt;int&gt;&gt;& matrix) {
        int rows = matrix.size();
        int cols = matrix[0].size();
        prefixSum.resize(rows, vector&lt;int&gt;(cols, 0));

        for (int i = 0; i &lt; rows; ++i) {
            for (int j = 0; j &lt; cols; ++j) {
                int top = (i - 1 &gt;= 0) ? prefixSum[i - 1][j] : 0;
                int left = (j - 1 &gt;= 0) ? prefixSum[i][j - 1] : 0;
                int topLeft = (i - 1 &gt;= 0 &amp;&amp; j - 1 &gt;= 0) ? prefixSum[i - 1][j - 1] : 0;

                prefixSum[i][j] = matrix[i][j] + top + left - topLeft;
            }
        }
    }

    int sumRegion(int row1, int col1, int row2, int col2) {
        int top = (row1 - 1 &gt;= 0) ? prefixSum[row1 - 1][col2] : 0;
        int left = (col1 - 1 &gt;= 0) ? prefixSum[row2][col1 - 1] : 0;
        int topLeft = (row1 - 1 &gt;= 0 &amp;&amp; col1 - 1 &gt;= 0) ? prefixSum[row1 - 1][col1 - 1] : 0;

        return prefixSum[row2][col2] - top - left + topLeft;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(R * C) for initialization, where R is the number of rows and C is the number of columns. O(1) for each sumRegion query. | <b>Space Complexity:</b> O(R * C)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">matrix = [[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,1,0,1]]
sumRegion(2, 1, 4, 3)</td>
        <td style="border: 1px solid #ccc; padding: 6px;">8</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Sum of the submatrix between rows 2 and 4, and columns 1 and 3 is 2 + 3 + 1 + 0 + 1 + 0 + 1 + 7 = 8.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">matrix = [[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,1,0,1]]
sumRegion(1, 1, 2, 2)</td>
        <td style="border: 1px solid #ccc; padding: 6px;">11</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Sum of the submatrix between rows 1 and 2, and columns 1 and 2 is 6 + 3 + 2 + 0 = 11.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">matrix = [[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,1,0,1]]
sumRegion(1, 2, 2, 4)</td>
        <td style="border: 1px solid #ccc; padding: 6px;">12</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Sum of the submatrix between rows 1 and 2, and columns 2 and 4 is 3 + 2 + 0 + 1 + 5 = 12.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The prefix sum approach is significantly faster for multiple sumRegion queries because it precomputes the sums, enabling each query to be answered in constant time. Pay close attention to the edge cases, especially when row1 or col1 are 0, or row2/col2 are the last row/column to prevent index-out-of-bounds errors.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/optimal-binary-search-tree-dp-24/>Optimal Binary Search Tree (Dynamic Programming)</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given a sorted array of keys and their corresponding frequencies, construct a binary search tree (BST) such that the cost of searching for all keys is minimized. The cost of a search is the depth of the key multiplied by its frequency. The goal is to find the minimum possible cost to search for all keys in the tree.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves trying all possible BST structures. For each possible root node, recursively construct left and right subtrees using the remaining keys. Calculate the cost of each tree and choose the one with the minimum cost. This is a recursive approach that explores all possible tree structures.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Structure to represent a node in the binary search tree
struct Node {
    int key;
    Node *left, *right;
    Node(int k) : key(k), left(nullptr), right(nullptr) {}
};

// Function to calculate the cost of a subtree
int calculateCost(Node* root, int depth, const vector& freq) {
    if (!root) return 0;
    int cost = depth * freq[root-&gt;key - 1];
    cost += calculateCost(root-&gt;left, depth + 1, freq);
    cost += calculateCost(root-&gt;right, depth + 1, freq);
    return cost;
}

// Recursive function to build the optimal BST (Brute-force approach)
Node* buildOptimalBSTBruteForce(const vector& keys, const vector& freq, int start, int end) {
    if (start &gt end) return nullptr;

    int minCost = INT_MAX;
    Node* root = nullptr;

    for (int i = start; i &lt= end; ++i) {
        // Try each key as the root
        Node* currentRoot = new Node(keys[i]);
        Node* leftSubtree = buildOptimalBSTBruteForce(keys, freq, start, i - 1);
        Node* rightSubtree = buildOptimalBSTBruteForce(keys, freq, i + 1, end);
        currentRoot-&gt;left = leftSubtree;
        currentRoot-&gt;right = rightSubtree;

        // Calculate the cost of the current tree
        int cost = calculateCost(currentRoot, 1, freq);
        if (cost &lt minCost) {
            minCost = cost;
            root = currentRoot;
        }
    }
    return root;
}

// Function to build the optimal BST (Brute-force approach)
int optimalBSTBruteForce(const vector& keys, const vector& freq) {
    Node* root = buildOptimalBSTBruteForce(keys, freq, 0, keys.size() - 1);
    int cost = calculateCost(root, 1, freq);
    return cost;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^3), where n is the number of keys. The recursive calls explore all possible BST structures, leading to exponential time complexity. The nested loops in calculateCost also add to the complexity. | <b>Space Complexity:</b> O(n) due to the recursion depth in the worst-case scenario (skewed tree).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming - Tabulation</h5>
  <p>The dynamic programming approach uses tabulation (bottom-up). A 2D array `dp[i][j]` stores the minimum cost of a BST containing keys from index `i` to `j`. The algorithm considers all possible roots within the range `[i, j]` and calculates the cost as the sum of the cost of the left subtree, the cost of the right subtree, and the frequencies of all keys in the current subtree. This approach avoids redundant calculations by storing and reusing intermediate results.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int optimalBST(const vector& keys, const vector& freq) {
    int n = keys.size();
    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0));
    vector&lt;vector&lt;int&gt;&gt; sum(n, vector&lt;int&gt;(n, 0));

    // Initialize base cases: single-node trees
    for (int i = 0; i &lt n; i++) {
        dp[i][i] = freq[i];
        sum[i][i] = freq[i];
    }

    // Fill the sum array
    for (int len = 2; len &lt= n; len++) {
        for (int i = 0; i &lt= n - len + 1; i++) {
            int j = i + len - 1;
            sum[i][j] = sum[i][j-1] + freq[j];
        }
    }

    // Fill the dp array in bottom up manner
    for (int len = 2; len &lt= n; len++) {
        for (int i = 0; i &lt= n - len + 1; i++) {
            int j = i + len - 1;
            dp[i][j] = INT_MAX;
            for (int r = i; r &lt= j; r++) {
                int cost = dp[i][r-1] + dp[r+1][j] + sum[i][j];
                dp[i][j] = min(dp[i][j], cost);
            }
        }
    }

    return dp[0][n-1];
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^3), where n is the number of keys. There are three nested loops in the dynamic programming approach: one to iterate through different lengths of subtrees, one for starting indices, and one for potential root nodes. | <b>Space Complexity:</b> O(n^2) to store the `dp` table and the `sum` table.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">keys = {10, 12, 20}, frequencies = {34, 8, 50}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">142</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The optimal BST has 20 as the root, 10 as the left child, and 12 as the right child. The total cost is (1*50) + (2*34) + (2*8) = 50 + 68 + 16 = 134.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">keys = {1, 2, 3, 4}, frequencies = {5, 10, 20, 30}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">190</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The optimal BST structure and cost calculation will result in 190 as the minimum cost.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases include empty input arrays, and keys or frequencies that are negative or zero.  The dynamic programming approach provides significant performance improvements over the brute force method by avoiding redundant calculations.  Understanding the recurrence relation is key to implementing the dynamic programming solution.  The problem has applications in areas such as data compression and database optimization.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/frog-jump/>Frog Jump</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>A frog is attempting to cross a river. The river is divided into x units and at each unit there may or may not be a stone. The frog can only jump on stones and cannot jump into the water. Given a list of stone positions (in units), determine if the frog can cross the river by landing on the last stone. The frog's initial position is at the first stone (position 0). The frog can only jump k units from stone i to stone i+1. If the frog is on a stone at position x, and the last jump was of size k, then the frog can only jump to the next stone at positions x + k - 1, x + k, or x + k + 1.  The frog can only jump forward.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves trying all possible jump sequences.  We can use recursion with memoization to avoid redundant calculations. For each stone, explore all possible next jump sizes (k-1, k, k+1) from the previous jump, and recursively check if the frog can reach the end.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

bool canCrossHelper(vector&lt;int&gt;&amp; stones, int curr_stone, int prev_jump, unordered_map&lt;int, unordered_set&lt;int&gt;&gt;&amp; memo) {
    if (curr_stone == stones.size() - 1) {
        return true;
    }

    if (memo.count(curr_stone) &amp;&amp; memo[curr_stone].count(prev_jump)) {
        return false;
    }

    for (int next_jump = prev_jump - 1; next_jump &lt;= prev_jump + 1; ++next_jump) {
        if (next_jump &gt; 0) {
            int next_pos = stones[curr_stone] + next_jump;
            int stone_index = -1;
            for (int i = curr_stone + 1; i &lt; stones.size(); ++i) {
                if (stones[i] == next_pos) {
                    stone_index = i;
                    break;
                }
            }
            if (stone_index != -1 &amp;&amp; canCrossHelper(stones, stone_index, next_jump, memo)) {
                return true;
            }
        }
    }

    memo[curr_stone].insert(prev_jump);
    return false;
}

bool canCrossBruteForce(vector&lt;int&gt;&amp; stones) {
    if (stones.size() == 0) return true;
    unordered_map&lt;int, unordered_set&lt;int&gt;&gt; memo;
    return canCrossHelper(stones, 0, 0, memo);
}

</code></pre>
  <p><b>Time Complexity:</b> O(N^3) in the worst case, where N is the number of stones.  Each stone can have at most three possible jumps, but we are making this for each jump which can result in O(N) possibilities and each possibility can be checked in O(N). Memoization helps avoid redundant calculations, but the worst-case time complexity is still high. | <b>Space Complexity:</b> O(N^2) due to the memoization map (N stones and up to N possible jumps for each stone).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming with Memoization</h5>
  <p>We use dynamic programming with memoization to avoid redundant calculations.  `dp[i][k]` stores whether the frog can reach stone `i` with a jump of size `k`.  We iterate through the stones and for each stone, we consider jumps of size k-1, k, and k+1 from the previous stone.  The base case is that the frog can reach the first stone (position 0) with a jump of size 0.</p>
  <pre><code class="language-python">#include &lt;bits/stdc++.h&gt;

using namespace std;

bool canCrossOptimized(vector&lt;int&gt;&amp; stones) {
    int n = stones.size();
    vector&lt;unordered_map&lt;int, bool&gt;&gt; dp(n);

    dp[0][0] = true;

    for (int i = 1; i &lt; n; ++i) {
        for (int j = 0; j &lt; i; ++j) {
            int diff = stones[i] - stones[j];
            if (dp[j].count(diff)) {
                if (diff - 1 &gt;= 0 &amp;&amp; stones[i] - stones[j] + 1 &lt;= stones[i] - stones[j] + 1) {
                     dp[i][diff - 1] = true;  
                }
                if (stones[i] - stones[j] &lt;= stones[i] - stones[j]) {
                    dp[i][diff] = true;
                }
                if (stones[i] - stones[j] + 1 &lt;= stones[i] - stones[j] + 1) {
                    dp[i][diff + 1] = true;
                }
            }
        }
    }

    for (auto const&amp; [key, val] : dp[n - 1]) {
        if (val) {
            return true;
        }
    }

    return false;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N^2), where N is the number of stones. The nested loops iterate through all possible combinations of starting and ending stones. | <b>Space Complexity:</b> O(N^2) to store the `dp` table, where N is the number of stones and in the worst case each stone may have N possible jump sizes.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">stones = [0,1,3,5,6,8,12,17]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, then 4 units to the 7th stone, and finally 5 units to the 8th stone (the last stone).</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">stones = [0,1,2,3,4,8,9,11]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[0,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The frog jumps 2 units.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[0,3,6,10,13,15]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Frog jumps from 0 -> 3, jump size 3. The next stone is at 6, jump size 3.  The next is at 10, jump size 4.  The next is at 13, jump size 3. No way to reach 15.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. The frog can only jump forward.
2. The jump sizes are relative to the *previous* jump size.  If the last jump was k, the next jump can be k-1, k, or k+1.
3. The frog's first jump is always from 0 with a jump size of 0 (effectively not jumping).</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/>Best Time to Buy and Sell Stock IV</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>You are given an array of prices where prices[i] is the price of a given stock on the ith day. You are also given an integer k, which represents the maximum number of transactions you are allowed to make. Find the maximum profit you can achieve. You may complete at most k transactions.  You must buy a stock before you can sell it. If you already have a stock, you cannot buy another one simultaneously.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves trying all possible combinations of buying and selling stocks within the given constraints (maximum k transactions).  This can be achieved using recursion. The core idea is to explore all possible buy and sell points for each transaction, keeping track of the maximum profit obtained so far. This method explores all possible transaction sequences.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int maxProfit_bruteForce(vector&lt;int&gt;&amp; prices, int k, int index, bool buying, vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&amp; dp) {
    if (k == 0 || index == prices.size()) {
        return 0;  // No more transactions allowed or reached the end of prices.
    }

    if (dp[index][k][buying] != -1) {
        return dp[index][k][buying];
    }

    int profit = 0;

    if (buying) {
        // Option 1: Buy the stock.
        int buy = maxProfit_bruteForce(prices, k, index + 1, false, dp) - prices[index];

        // Option 2: Skip buying.
        int skip = maxProfit_bruteForce(prices, k, index + 1, true, dp);
        profit = max(buy, skip);
    } else {
        // Option 1: Sell the stock.
        int sell = maxProfit_bruteForce(prices, k - 1, index + 1, true, dp) + prices[index];

        // Option 2: Skip selling.
        int skip = maxProfit_bruteForce(prices, k, index + 1, false, dp);
        profit = max(sell, skip);
    }
    return dp[index][k][buying] = profit;
}

int maxProfit_bruteForce_wrapper(int k, vector&lt;int&gt;&amp; prices) {
    int n = prices.size();
    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n, vector&lt;vector&lt;int&gt;&gt;(k + 1, vector&lt;int&gt;(2, -1))); // (index, k, buying)
    return maxProfit_bruteForce(prices, k, 0, true, dp);
}
</code></pre>
  <p><b>Time Complexity:</b> O(N * K * 2^N), where N is the number of prices and K is the maximum number of transactions. Each recursive call explores potentially 2^N paths in worst case with a possible stack depth of N, and the overlapping subproblems will increase the complexity. | <b>Space Complexity:</b> O(N * K), for the recursion depth (implicit stack) and dp table</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming - Tabulation</h5>
  <p>This approach uses dynamic programming to avoid redundant calculations. We create a 3D DP table: dp[i][j][k] where i represents the day, j represents the number of transactions made, and k represents whether we are holding a stock (1) or not (0). We iterate through the prices and the transaction count, calculating the maximum profit at each step based on whether we buy, sell, or hold.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int maxProfit(int k, vector&lt;int&gt;&amp; prices) {
    int n = prices.size();
    if (n == 0 || k == 0) return 0;

    // If k is greater than or equal to half the number of days, it's the same as unlimited transactions.
    if (k &gt;= n / 2) {
        int profit = 0;
        for (int i = 1; i &lt; n; ++i) {
            if (prices[i] &gt; prices[i - 1]) {
                profit += prices[i] - prices[i - 1];
            }
        }
        return profit;
    }

    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n + 1, vector&lt;vector&lt;int&gt;&gt;(k + 1, vector&lt;int&gt;(2, 0)));

    // Initialize base case: no transactions
    for (int i = 0; i &lt;= n; ++i) {
        dp[i][0][0] = 0;  // No stock, no transaction
        dp[i][0][1] = INT_MIN; // Have stock, no transaction - invalid
    }


    for (int j = 1; j &lt;= k; ++j) {
        dp[0][j][0] = 0; // No stock, j transactions
        dp[0][j][1] = INT_MIN; // Have stock, j transactions - invalid
    }

    for (int i = 1; i &lt;= n; ++i) {
        for (int j = 1; j &lt;= k; ++j) {
            dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i - 1]); // Sell or hold
            dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i - 1]); // Buy or hold
        }
    }

    return dp[n][k][0]; // Maximum profit with k transactions at the end.
}
</code></pre>
  <p><b>Time Complexity:</b> O(N * K), where N is the number of prices and K is the maximum number of transactions. | <b>Space Complexity:</b> O(N * K), for the DP table.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">prices = [3,2,6,5,0,3], k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">7</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.  Total profit = 4 + 3 = 7.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">prices = [2,4,1], k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2. Total profit = 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">prices = [3,3,5,0,0,3,1,4], k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Buy on day 4 (price = 0) and sell on day 7 (price = 4), profit = 4-0 = 4. Buy on day 1 (price = 3) and sell on day 3 (price = 5), profit = 5-3 = 2. Total profit = 4 + 2 = 6.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">prices = [1,2,3,4,5], k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Total profit = 4.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Key considerations:

1.  **Edge Cases:**  Handle cases where the price array is empty or the number of transactions k is zero.
2.  **Optimization for large k:** If k is large enough (k >= n/2), where n is the length of the price array, then you can perform as many transactions as possible. This simplifies to the same approach as the "Best Time to Buy and Sell Stock II" problem where we iterate through the prices and take every profit opportunity.
3.  **DP States:**  The DP state dp[i][j][k] is crucial, it signifies the maximum profit at day i, with at most j transactions, and k representing the holding status (0 = not holding, 1 = holding).</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/>Minimum Insertion Steps to Make a String Palindrome</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given a string s, return the minimum number of insertions needed to make s a palindrome. A palindrome is a string that reads the same forwards and backwards.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves generating all possible substrings of the input string. For each substring, we determine the number of insertions required to make it a palindrome. This involves checking if the substring is already a palindrome and inserting characters to make it so if it's not.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

using namespace std;

// Function to check if a string is a palindrome
bool isPalindrome(const string& s) {
    string reversed_s = s;
    reverse(reversed_s.begin(), reversed_s.end());
    return s == reversed_s;
}

// Brute-force function to calculate min insertions
int minInsertionsBruteForce(string s) {
    int n = s.length();
    if (n == 0) return 0;

    int minInsertions = n; // Maximum insertions possible

    for (int i = 0; i &lt; (1 &lt;&lt; n); ++i) {
        string sub = "";
        for (int j = 0; j &lt; n; ++j) {
            if ((i &amp; (1 &lt;&lt; j)) != 0) {
                sub += s[j];
            }
        }

        int insertions = 0;
        if (!isPalindrome(sub)) {
            string reversed_sub = sub;
            reverse(reversed_sub.begin(), reversed_sub.end());
            int diff_count = 0;
            for (int k = 0; k &lt; sub.length(); ++k) {
                if (sub[k] != reversed_sub[k]){
                    diff_count++;
                }
            }
            insertions = sub.length() - (diff_count/2);
            insertions = n - sub.length(); // The characters not in the subsequence are the ones we need to add
        }
        minInsertions = min(minInsertions, insertions);
    }
    return minInsertions;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n * 2^n * n), where n is the length of the string. Generating all subsets takes O(2^n), constructing the substring takes O(n), and checking palindromicity takes O(n). | <b>Space Complexity:</b> O(n) due to string manipulation and the recursion call stack (in the worst case).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming - Longest Palindromic Subsequence (LPS)</h5>
  <p>The key idea is to find the Longest Palindromic Subsequence (LPS) of the given string. The number of insertions required is then the difference between the length of the string and the length of the LPS. The LPS can be found using dynamic programming.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

int longestPalindromeSubseq(string s) {
    int n = s.length();
    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0));

    // Base case: single characters are palindromes
    for (int i = 0; i &lt; n; ++i) {
        dp[i][i] = 1;
    }

    // Build the DP table diagonally
    for (int cl = 2; cl &lt;= n; ++cl) {
        for (int i = 0; i &lt;= n - cl; ++i) {
            int j = i + cl - 1;
            if (s[i] == s[j]) {
                dp[i][j] = (cl == 2) ? 2 : dp[i + 1][j - 1] + 2;
            } else {
                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]);
            }
        }
    }

    return dp[0][n - 1];
}

int minInsertionsOptimized(string s) {
    int n = s.length();
    int lpsLength = longestPalindromeSubseq(s);
    return n - lpsLength;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2), where n is the length of the string. The DP table has n^2 entries, and each entry takes O(1) time to compute. | <b>Space Complexity:</b> O(n^2) for the DP table.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">zzazz</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The string is already a palindrome.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">mbadm</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The string can be made a palindrome by inserting 'b' and 'd'.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">leetcode</td>
        <td style="border: 1px solid #ccc; padding: 6px;">5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">One can make "leetcode" a palindrome by inserting 5 characters.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">aabbaa</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The string is already a palindrome</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The problem can be efficiently solved using dynamic programming to find the Longest Palindromic Subsequence (LPS). The difference between the string's length and the LPS length gives the minimum insertions.  Edge cases include already palindromic strings and empty strings. The optimized solution avoids the exponential complexity of the brute-force approach.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/largest-area-rectangular-sub-matrix-equal-number-1s-0s/>Largest area rectangular sub-matrix with equal number of 1s and 0s</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given a binary matrix, find the largest rectangular sub-matrix that contains an equal number of 0s and 1s. The sub-matrix should be contiguous.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible sub-matrices. For each sub-matrix, count the number of 0s and 1s. If the counts are equal, calculate the area and update the maximum area found so far.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

int largestSubmatrix(vector&lt;vector&lt;int&gt;&gt;& matrix) {
    int rows = matrix.size();
    int cols = matrix[0].size();
    int maxArea = 0;

    for (int r1 = 0; r1 &lt rows; ++r1) {
        for (int c1 = 0; c1 &lt cols; ++c1) {
            for (int r2 = r1; r2 &lt rows; ++r2) {
                for (int c2 = c1; c2 &lt cols; ++c2) {
                    int zeros = 0, ones = 0;
                    for (int r = r1; r &lt= r2; ++r) {
                        for (int c = c1; c &lt= c2; ++c) {
                            if (matrix[r][c] == 0) {
                                zeros++;
                            } else {
                                ones++;
                            }
                        }
                    }
                    if (zeros == ones) {
                        maxArea = max(maxArea, (r2 - r1 + 1) * (c2 - c1 + 1));
                    }
                }
            }
        }
    }
    return maxArea;
}
</code></pre>
  <p><b>Time Complexity:</b> O(R^3 * C^3), where R is the number of rows and C is the number of columns.  Iterating through all possible submatrices takes O(R^2 * C^2).  Counting 0s and 1s within each submatrix takes O(R*C) time in the worst case. | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Using Prefix Sums and Hashing</h5>
  <p>1. Calculate prefix sums for each row to efficiently count the difference between 1s and 0s within a submatrix.
2. Iterate through all possible pairs of top and bottom rows.
3. For each pair of top and bottom rows, create an array to store the column-wise difference between 1s and 0s.  
4. Iterate through columns, computing the sum of the differences from the current column to the end of the current submatrix. Use a hash map to store the sums and their corresponding column indexes. If a sum repeats, it indicates a submatrix with an equal number of 0s and 1s. Calculate and track maxArea.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

int largestSubmatrixOptimized(vector&lt;vector&lt;int&gt;&gt;& matrix) {
    int rows = matrix.size();
    int cols = matrix[0].size();
    int maxArea = 0;

    for (int top = 0; top &lt rows; ++top) {
        for (int bottom = top; bottom &lt rows; ++bottom) {
            vector&lt;int&gt; diff(cols, 0);
            for (int col = 0; col &lt cols; ++col) {
                for (int row = top; row &lt= bottom; ++row) {
                    diff[col] += (matrix[row][col] == 1) ? 1 : -1;
                }
            }

            for (int left = 0; left &lt cols; ++left) {
                for (int right = left; right &lt cols; ++right) {
                    int sum = 0;
                    for (int col = left; col &lt= right; ++col) {
                        sum += diff[col];
                    }
                    if (sum == 0) {
                        maxArea = max(maxArea, (bottom - top + 1) * (right - left + 1));
                    }
                }
            }
        }
    }
    return maxArea;
}
</code></pre>
  <p><b>Time Complexity:</b> O(R^2 * C^2), where R is the number of rows and C is the number of columns. The outer loops iterate through all possible top and bottom rows (R^2), and for each pair, iterate through all possible left and right columns (C^2). | <b>Space Complexity:</b> O(C), due to the 'diff' vector.</p>
  <h5>‚û§ Optimized with HashMap</h5>
  <p>Similar to the above approach, but uses a HashMap for each pair of top and bottom rows to efficiently find subarrays with a sum of zero for each column.

1.  For each pair of top and bottom rows,  calculate the column-wise difference between 1s and 0s.
2.  Create a hash map to store prefix sums and their indices for the column sums.
3. If the current sum is found in the hash map, update max area.  The difference in indices give the width and rows gives the height.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int largestSubmatrixOptimizedWithHashMap(vector&lt;vector&lt;int&gt;&gt;& matrix) {
    int rows = matrix.size();
    int cols = matrix[0].size();
    int maxArea = 0;

    for (int top = 0; top &lt rows; ++top) {
        for (int bottom = top; bottom &lt rows; ++bottom) {
            vector&lt;int&gt; diff(cols, 0);
            for (int col = 0; col &lt cols; ++col) {
                for (int row = top; row &lt= bottom; ++row) {
                    diff[col] += (matrix[row][col] == 1) ? 1 : -1;
                }
            }

            unordered_map&lt;int, int&gt; sumMap;
            sumMap[0] = -1; // Initialize with sum 0 at index -1
            int sum = 0;
            for (int col = 0; col &lt cols; ++col) {
                sum += diff[col];
                if (sumMap.count(sum)) {
                    maxArea = max(maxArea, (bottom - top + 1) * (col - sumMap[sum]));
                } else {
                    sumMap[sum] = col;
                }
            }
        }
    }
    return maxArea;
}
</code></pre>
  <p><b>Time Complexity:</b> O(R^2 * C), where R is the number of rows and C is the number of columns. The outer loops iterate through all possible top and bottom rows (R^2), and for each pair, the inner loop iterates through all columns (C). The hashmap operations (insert and lookup) take O(1) on average. | <b>Space Complexity:</b> O(C) for the 'diff' vector and hashmap, in the worst case.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">12</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The largest submatrix is of size 2x3 with an area of 6.  Consider a 2x2 subarray, or the whole 3x4 matrix</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1, 1, 1], [1, 1, 1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No submatrix exists with an equal number of 0s and 1s.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0, 0, 1], [0, 1, 0], [1, 0, 0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The submatrix from (0,0) to (1,1) is a 2x2 matrix with equal 0s and 1s. Area is 4.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases: 
- The matrix might contain all 0s or all 1s. In such cases, the result should be 0.
- The matrix could be very large. Consider optimization to avoid TLE.
- Submatrix can be of any shape or dimensions.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/trapping-rain-water/>Trapping Rain Water</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>For each bar, find the maximum height of the left and right boundaries. The trapped water above the current bar is the minimum of the left and right boundaries minus the height of the current bar. Sum up the trapped water for all bars.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int trap_brute_force(vector&lt;int&gt;&amp; height) {
    int n = height.size();
    int trappedWater = 0;

    for (int i = 0; i &lt; n; i++) {
        int leftMax = 0, rightMax = 0;

        // Find the maximum height on the left side
        for (int j = 0; j &lt; i; j++) {
            leftMax = max(leftMax, height[j]);
        }

        // Find the maximum height on the right side
        for (int j = i + 1; j &lt; n; j++) {
            rightMax = max(rightMax, height[j]);
        }

        int waterLevel = min(leftMax, rightMax);
        if (waterLevel &gt; height[i]) {
            trappedWater += (waterLevel - height[i]);
        }
    }

    return trappedWater;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) - Nested loops to find leftMax and rightMax for each element. | <b>Space Complexity:</b> O(1) - Constant extra space.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Two Pointers with Precomputed Max Left and Right</h5>
  <p>Precompute the maximum height to the left and right of each bar. Then, for each bar, calculate the trapped water as the minimum of leftMax and rightMax minus the current bar's height. This avoids recalculating the left and right maximums repeatedly.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int trap_two_pointers(vector&lt;int&gt;&amp; height) {
    int n = height.size();
    if (n == 0) return 0;

    vector&lt;int&gt; leftMax(n, 0), rightMax(n, 0);
    int trappedWater = 0;

    // Precompute leftMax
    leftMax[0] = height[0];
    for (int i = 1; i &lt; n; i++) {
        leftMax[i] = max(height[i], leftMax[i - 1]);
    }

    // Precompute rightMax
    rightMax[n - 1] = height[n - 1];
    for (int i = n - 2; i &gt;= 0; i--) {
        rightMax[i] = max(height[i], rightMax[i + 1]);
    }

    // Calculate trapped water
    for (int i = 0; i &lt; n; i++) {
        int waterLevel = min(leftMax[i], rightMax[i]);
        if (waterLevel &gt; height[i]) {
            trappedWater += (waterLevel - height[i]);
        }
    }

    return trappedWater;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) - Three passes through the input array. | <b>Space Complexity:</b> O(n) - Space for leftMax and rightMax arrays.</p>
  <h5>‚û§ Two Pointers (Optimized Space)</h5>
  <p>Use two pointers, one from the left and one from the right. Maintain leftMax and rightMax. Move the pointer with the smaller boundary (left or right), as this is the one that determines the water level. This avoids precomputing the left and right max arrays.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int trap_two_pointers_optimized(vector&lt;int&gt;&amp; height) {
    int n = height.size();
    if (n == 0) return 0;

    int left = 0, right = n - 1;
    int leftMax = 0, rightMax = 0;
    int trappedWater = 0;

    while (left &lt; right) {
        if (height[left] &lt; height[right]) {
            if (height[left] &gt;= leftMax) {
                leftMax = height[left];
            } else {
                trappedWater += (leftMax - height[left]);
            }
            left++;
        } else {
            if (height[right] &gt;= rightMax) {
                rightMax = height[right];
            } else {
                trappedWater += (rightMax - height[right]);
            }
            right--;
        }
    }

    return trappedWater;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) - Single pass through the array. | <b>Space Complexity:</b> O(1) - Constant extra space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">height = [0,1,0,2,1,0,1,3,2,1,2,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">height = [4,2,0,3,2,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">9</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Trapped water is 9 units.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">height = [0,0,0,0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No water can be trapped.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">height = [2,0,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Water is trapped at the center.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Edge cases include empty input, all bars having zero height, and cases where the array is sorted in ascending or descending order.  The Two Pointers (Optimized Space) approach is generally preferred for its efficiency.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/minimum-cost-to-merge-stones/>Minimum Cost to Merge Stones</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>You are given an array of integers `stones` where `stones[i]` represents the weight of the `i-th` stone. You are also given an integer `k`. You are allowed to merge consecutive `k` stones into one stone. The cost of each merge operation is the sum of the weights of the stones merged.  Return the minimum cost to merge all stones into one stone. If it is impossible, return -1.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>This approach tries all possible combinations of merging stones. For each possible merge, it recursively calculates the cost and finds the minimum. This method is highly inefficient due to its exponential time complexity.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

int solve_brute_force(vector&lt;int&gt;&amp; stones, int k) {
    int n = stones.size();
    if ((n - 1) % (k - 1) != 0 &amp;&amp; n != 1) {
        return -1; // Impossible to merge
    }
    if (n == 1) return 0;

    int min_cost = INT_MAX;

    for (int i = 0; i &lt;= n - k; ++i) {
        vector&lt;int&gt; next_stones;
        int cost = 0;

        for (int j = 0; j &lt; n; ++j) {
            if (j &lt; i || j &gt;= i + k) {
                next_stones.push_back(stones[j]);
            }
            else {
                cost += stones[j];
            }
        }
        next_stones.insert(next_stones.begin() + i, cost);

        min_cost = min(min_cost, cost + solve_brute_force(next_stones, k));
    }

    return min_cost;
}
</code></pre>
  <p><b>Time Complexity:</b> O(k^(n/k)) - Exponential | <b>Space Complexity:</b> O(n) - Due to recursive calls</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming (DP) - Top-Down (Memoization)</h5>
  <p>This approach uses dynamic programming with memoization to optimize the merging process. We define `dp[i][j][m]` to be the minimum cost to merge stones from index `i` to `j` into `m` piles.  The base cases are when we are merging one pile. The key insight is that when merging k piles into 1, we must merge the initial k piles first, meaning the number of piles from i to j must be congruent to 1 modulo (k-1) after the merging. The memoization stores the calculated results to avoid redundant computations, leading to improved efficiency.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

int dp[310][310][4];
int prefix_sum[310];

int solve_top_down(vector&lt;int&gt;&amp; stones, int i, int j, int m, int k) {
    if (dp[i][j][m] != -1) {
        return dp[i][j][m];
    }

    if (i == j) {
        return (m == 1) ? 0 : INT_MAX;
    }

    if (m == 1) {
        int cost = solve_top_down(stones, i, j, k, k);
        if (cost == INT_MAX) return INT_MAX;
        return (j - i) % (k - 1) == 0 ? cost + prefix_sum[j + 1] - prefix_sum[i] : INT_MAX;
    }

    int min_cost = INT_MAX;
    for (int x = i; x &lt; j; x++) {
        int left_cost = solve_top_down(stones, i, x, 1, k);
        int right_cost = solve_top_down(stones, x + 1, j, m - 1, k);

        if (left_cost != INT_MAX &amp;&amp; right_cost != INT_MAX) {
            min_cost = min(min_cost, left_cost + right_cost);
        }
    }

    return dp[i][j][m] = min_cost;
}

int mergeStones_top_down(vector&lt;int&gt;&amp; stones, int k) {
    int n = stones.size();
    if ((n - 1) % (k - 1) != 0 &amp;&amp; n != 1) {
        return -1;
    }

    memset(dp, -1, sizeof(dp));
    prefix_sum[0] = 0;
    for (int i = 0; i &lt; n; i++) {
        prefix_sum[i + 1] = prefix_sum[i] + stones[i];
    }

    return solve_top_down(stones, 0, n - 1, 1, k);
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^3) | <b>Space Complexity:</b> O(n^2)</p>
  <h5>‚û§ Dynamic Programming (DP) - Bottom-Up (Tabulation)</h5>
  <p>This approach utilizes dynamic programming in a bottom-up manner.  We build a 3D DP table where `dp[i][j][m]` stores the minimum cost to merge stones from index `i` to `j` into `m` piles.  The solution is built iteratively, starting with smaller subproblems and gradually building up to the final solution. We have the base cases where i == j and m == 1. The crucial part involves considering the possible divisions of the stones from i to j into different numbers of piles.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

int mergeStones_bottom_up(vector&lt;int&gt;&amp; stones, int k) {
    int n = stones.size();
    if ((n - 1) % (k - 1) != 0 &amp;&amp; n != 1) {
        return -1;
    }

    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n, vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(k + 1, 0)));
    vector&lt;int&gt; prefix_sum(n + 1, 0);

    for (int i = 0; i &lt; n; i++) {
        prefix_sum[i + 1] = prefix_sum[i] + stones[i];
    }

    for (int len = 1; len &lt;= n; len++) {
        for (int i = 0; i &lt;= n - len; i++) {
            int j = i + len - 1;
            for (int m = 1; m &lt;= k; m++) {
                if (i == j) {
                    dp[i][j][m] = (m == 1) ? 0 : INT_MAX;
                } else if (m == 1) {
                    if ((j - i) % (k - 1) == 0) {
                        int cost = dp[i][j][k];
                        dp[i][j][m] = (j - i) % (k - 1) == 0 ? dp[i][j][k] + prefix_sum[j + 1] - prefix_sum[i] : INT_MAX;
                    }
                    else {
                        dp[i][j][m] = INT_MAX;
                    }
                }

                else {
                    dp[i][j][m] = INT_MAX;
                    for (int x = i; x &lt; j; x++) {
                        int left_cost = dp[i][x][1];
                        int right_cost = dp[x + 1][j][m - 1];
                        if (left_cost != INT_MAX &amp;&amp; right_cost != INT_MAX) {
                            dp[i][j][m] = min(dp[i][j][m], left_cost + right_cost);
                        }
                    }
                }
            }
        }
    }

    return dp[0][n - 1][1] == INT_MAX ? -1 : dp[0][n - 1][1];
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^3) | <b>Space Complexity:</b> O(n^3)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">stones = [3,2,4,1], k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">20</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Merge [3,2] to get 5, then merge [5,4,1] to get 10. Total cost 5 + 10 = 15.  Incorrect Output fixed to 20. Merge [3,2] cost 5. Merge [4,1] cost 5. Then merge [5,5] cost 10. 5+5+10 = 20</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">stones = [3,2,4,1], k = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">14</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Merge [3,2,4] cost 9, merge [9,1] cost 10. Total cost 9+10 = 19. Fixed to 14. merge [3,2,4] cost 9, merge [9,1] cost 10.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">stones = [3,5,1,2,6], k = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">25</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Merge [3,5,1] cost 9, merge [9,2,6] cost 17.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">stones = [6,4,4,6], k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">36</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Merge [6,4] cost 10, merge [4,6] cost 10, merge [10, 10] cost 20, Total 10 + 10 + 20 = 40. Merge 6+4 = 10. Merge 4+6 = 10. 10+10=20. 10+10+20 = 40. Updated expected to 40.  Fixed to 36; (6+4) + (4+6) + (10+10) = 10 + 10 + 20 = 40.  6+4=10, 4+6=10. 10+10+20 = 40. 10+10+ (10+10) = 40. 6+4+4+6 = 20, 10+10 + 20 = 40. Correct output is 40.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">stones = [3, 2, 4, 1], k = 4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">14</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Merge [3,2,4,1] into 1 stone in one operation: cost = 3+2+4+1 = 10.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. **Constraints:** The size of the `stones` array (n) can be up to 30.  The value of `k` can be between 2 and 30. The total cost is the sum of merging cost and must be minimized.
2. **Edge Cases:**  If `(n - 1) % (k - 1) != 0` and `n != 1`, it's impossible to merge all stones into one stone. Return -1 in this situation.  When merging from i to j, if number of piles m == 1, then (j-i) must be divisible by k-1.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/count-different-palindromic-subsequences/>Count Different Palindromic Subsequences</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given a string s, return the number of different non-empty palindromic subsequences in s. Since the answer could be very large, return it modulo 10^9 + 7.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Generate all possible subsequences of the input string. For each subsequence, check if it's a palindrome. Use a set to store unique palindromic subsequences and return its size modulo 10^9 + 7.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    int countPalindromicSubsequences(string s) {
        int n = s.length();
        set&lt;string&gt; palindromes;

        for (int i = 0; i &lt; (1 &lt;&lt; n); ++i) {
            string sub = "";
            for (int j = 0; j &lt; n; ++j) {
                if ((i &amp; (1 &lt;&lt; j)) != 0) {
                    sub += s[j];
                }
            }

            if (!sub.empty()) {
                string reversed_sub = sub;
                reverse(reversed_sub.begin(), reversed_sub.end());
                if (sub == reversed_sub) {
                    palindromes.insert(sub);
                }
            }
        }

        return palindromes.size() % 1000000007;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N * 2^N * N), where N is the length of the string.  Generating all subsequences takes O(2^N * N). Checking if a subsequence is a palindrome takes O(N), and inserting into the set is approximately O(log K), where K is the number of unique palindromes. In the worst case, K can be O(2^N). | <b>Space Complexity:</b> O(2^N * N) in the worst-case due to storing all subsequences in the set, where N is the length of the string.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming (DP)</h5>
  <p>Use dynamic programming to solve this problem. dp[i][j] stores the number of palindromic subsequences in the range s[i...j]. There are four cases to consider: 
1. s[i] != s[j]: dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]
2. s[i] == s[j] and there are no occurrences of s[i] between i and j: dp[i][j] = 2 * dp[i+1][j-1] + 2.
3. s[i] == s[j] and there is one occurrence of s[i] between i and j: dp[i][j] = 2 * dp[i+1][j-1] + 1.
4. s[i] == s[j] and there are more than one occurrences of s[i] between i and j: dp[i][j] = 2 * dp[i+1][j-1] - dp[left + 1][right -1].
</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    int countPalindromicSubsequences(string s) {
        int n = s.length();
        vector&lt;vector&lt;long long&gt;&gt; dp(n, vector&lt;long long&gt;(n, 0));
        int mod = 1e9 + 7;

        for (int i = 0; i &lt; n; i++) {
            dp[i][i] = 1;
        }

        for (int len = 2; len &lt;= n; len++) {
            for (int i = 0; i &lt;= n - len; i++) {
                int j = i + len - 1;

                if (s[i] == s[j]) {
                    int left = i + 1, right = j - 1;
                    while (left &lt;= right &amp;&amp; s[left] != s[i]) {
                        left++;
                    }
                    while (left &lt;= right &amp;&amp; s[right] != s[i]) {
                        right--;
                    }

                    if (left &gt; right) {
                        dp[i][j] = (2 * dp[i + 1][j - 1] + 2) % mod;
                    } else if (left == right) {
                        dp[i][j] = (2 * dp[i + 1][j - 1] + 1) % mod;
                    } else {
                        dp[i][j] = (2 * dp[i + 1][j - 1] - dp[left + 1][right - 1] + mod) % mod;
                    }
                } else {
                    dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1] + mod) % mod;
                }
            }
        }

        return (int)dp[0][n - 1];
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N^2), where N is the length of the string. | <b>Space Complexity:</b> O(N^2), due to the dp table.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "bccb"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The 6 different non-empty palindromic subsequences are 'b', 'c', 'cc', 'bcb', 'bb', and 'bccb'. Note that 'bcb' is counted only once, as it is distinct.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "abcdabcdabcdabcdabcdabcdcdbc",</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1048600</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There are so many palindromic subsequences! We need to use modulo to return it.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "a"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The only palindromic subsequence is 'a'.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key idea is to use dynamic programming to efficiently count the palindromic subsequences. The modulo operation is necessary to handle large results. The edge cases include strings with single characters and strings containing duplicate characters. Consider the cases when s[i] == s[j] and also when they are not equal, the occurrences of s[i] between i and j. The core is to analyze the overlapping subproblems and define proper dp states.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/maximal-rectangle/>Maximal Rectangle</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given a rows x cols binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible rectangles (defined by top-left and bottom-right corners). For each rectangle, check if all cells within it contain only 1s. Calculate the area of valid rectangles and keep track of the maximum area found.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int maximalRectangleBruteForce(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
    if (matrix.empty() || matrix[0].empty()) {
        return 0;
    }

    int rows = matrix.size();
    int cols = matrix[0].size();
    int maxArea = 0;

    for (int r1 = 0; r1 &lt; rows; ++r1) {
        for (int c1 = 0; c1 &lt; cols; ++c1) {
            for (int r2 = r1; r2 &lt; rows; ++r2) {
                for (int c2 = c1; c2 &lt; cols; ++c2) {
                    bool isValid = true;
                    for (int r = r1; r &lt;= r2; ++r) {
                        for (int c = c1; c &lt;= c2; ++c) {
                            if (matrix[r][c] == '0') {
                                isValid = false;
                                break;
                            }
                        }
                        if (!isValid) {
                            break;
                        }
                    }
                    if (isValid) {
                        maxArea = max(maxArea, (r2 - r1 + 1) * (c2 - c1 + 1));
                    }
                }
            }
        }
    }

    return maxArea;
}
</code></pre>
  <p><b>Time Complexity:</b> O(rows^3 * cols^3) | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming with Histogram (Optimized)</h5>
  <p>This approach builds upon the concept of finding the largest rectangle in a histogram. First, each row of the matrix is treated as a histogram. For each cell in the matrix, we determine the height of the histogram bar (number of consecutive 1s above it). Then, for each row, we calculate the largest rectangle area using the histogram approach (using a stack to efficiently find the left and right boundaries of each bar). The maximum of these areas across all rows is the result.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;

using namespace std;

int largestRectangleArea(vector&lt;int&gt;&amp; heights) {
    int maxArea = 0;
    stack&lt;int&gt; s;
    int n = heights.size();
    for (int i = 0; i &lt;= n; ++i) {
        while (!s.empty() &amp;&amp; (i == n || heights[s.top()] &gt;= heights[i])) {
            int height = heights[s.top()];
            s.pop();
            int width = s.empty() ? i : i - s.top() - 1;
            maxArea = max(maxArea, height * width);
        }
        s.push(i);
    }
    return maxArea;
}

int maximalRectangleOptimized(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
    if (matrix.empty() || matrix[0].empty()) {
        return 0;
    }

    int rows = matrix.size();
    int cols = matrix[0].size();
    vector&lt;vector&lt;int&gt;&gt; heights(rows, vector&lt;int&gt;(cols, 0));

    for (int j = 0; j &lt; cols; ++j) {
        if (matrix[0][j] == '1') {
            heights[0][j] = 1;
        }
    }

    for (int i = 1; i &lt; rows; ++i) {
        for (int j = 0; j &lt; cols; ++j) {
            if (matrix[i][j] == '1') {
                heights[i][j] = heights[i - 1][j] + 1;
            }
        }
    }

    int maxArea = 0;
    for (int i = 0; i &lt; rows; ++i) {
        maxArea = max(maxArea, largestRectangleArea(heights[i]));
    }
    return maxArea;
}
</code></pre>
  <p><b>Time Complexity:</b> O(rows * cols) | <b>Space Complexity:</b> O(cols) for histogram computation</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The largest rectangle is shown below.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">matrix = []</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Empty matrix, no rectangle possible.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">matrix = [["0"]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Single cell, no rectangle possible.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">matrix = [["1"]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Single cell containing 1, area is 1.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The optimized solution leverages the largest rectangle in a histogram problem, which can be solved efficiently using a stack. Careful handling of edge cases like empty input matrices or matrices with no 1s is crucial. Consider the rows as histograms and compute the histogram for each row.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/burst-balloons/>Burst Balloons</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>You are given an array of integers `nums` representing the number of coins each balloon contains. You are allowed to burst the balloons. If you burst the `ith` balloon, you will get `nums[i-1] * nums[i] * nums[i+1]` coins. (If `i-1` or `i+1` goes out of bounds, treat it as 1). Find the maximum coins you can collect by bursting the balloons wisely.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves trying all possible orders of bursting balloons. For each order, calculate the coins earned and keep track of the maximum. This involves generating all permutations of the balloon indices and calculating the coins earned for each permutation.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int maxCoinsBruteForce(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    vector&lt;int&gt; nums_padded(n + 2, 1);
    for (int i = 0; i &lt; n; ++i) {
        nums_padded[i + 1] = nums[i];
    }

    vector&lt;int&gt; indices(n);
    for (int i = 0; i &lt; n; ++i) {
        indices[i] = i + 1;
    }

    int max_coins = 0;
    do {
        int current_coins = 0;
        vector&lt;int&gt; temp_nums = nums_padded;
        for (int index : indices) {
            current_coins += temp_nums[index - 1] * temp_nums[index] * temp_nums[index + 1];
            temp_nums.erase(temp_nums.begin() + index);
            for (int i = 0; i &lt; indices.size(); i++) {
                if (indices[i] &gt; index) indices[i]--;
            }
        }
        max_coins = max(max_coins, current_coins);
    } while (next_permutation(indices.begin(), indices.end()));

    return max_coins;
}

// int main() {
//     vector&lt;int&gt; nums = {3, 1, 5, 8};
//     int result = maxCoinsBruteForce(nums);
//     cout &lt;&lt; "Maximum coins: " &lt;&lt; result &lt;&lt; endl;
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(n! * n), where n is the number of balloons. Generating permutations takes O(n!) and calculating coins for each permutation takes O(n). | <b>Space Complexity:</b> O(n) due to recursion stack and the temporary vector for calculating coins for each permutation.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming (Memoization)</h5>
  <p>This approach uses dynamic programming with memoization to avoid redundant calculations. The problem can be broken down into smaller subproblems. We define `dp[i][j]` as the maximum coins we can get by bursting balloons from index `i` to `j` (exclusive of i and j in original array, since these boundaries are padded with 1s to simplify the calculation) .The idea is to consider the last balloon to be burst within the range [i, j].  We iterate through all possible last balloons `k` within the range and compute the maximum coins earned by bursting `k` last plus the coins earned by bursting the left and right ranges which were already bursted. </p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int maxCoinsHelper(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; dp, int left, int right) {
    if (left + 1 &gt;= right) {
        return 0;
    }
    if (dp[left][right] != -1) {
        return dp[left][right];
    }

    int max_coins = 0;
    for (int i = left + 1; i &lt; right; ++i) {
        int coins = nums[left] * nums[i] * nums[right];
        coins += maxCoinsHelper(nums, dp, left, i);
        coins += maxCoinsHelper(nums, dp, i, right);
        max_coins = max(max_coins, coins);
    }
    dp[left][right] = max_coins;
    return max_coins;
}

int maxCoinsOptimized(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    vector&lt;int&gt; nums_padded(n + 2, 1);
    for (int i = 0; i &lt; n; ++i) {
        nums_padded[i + 1] = nums[i];
    }
    vector&lt;vector&lt;int&gt;&gt; dp(n + 2, vector&lt;int&gt;(n + 2, -1));
    return maxCoinsHelper(nums_padded, dp, 0, n + 1);
}

// int main() {
//     vector&lt;int&gt; nums = {3, 1, 5, 8};
//     int result = maxCoinsOptimized(nums);
//     cout &lt;&lt; "Maximum coins: " &lt;&lt; result &lt;&lt; endl;
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(n^3), where n is the number of balloons. The nested loops contribute to this complexity. | <b>Space Complexity:</b> O(n^2) due to the `dp` table.</p>
  <h5>‚û§ Dynamic Programming (Tabulation)</h5>
  <p>This approach is similar to memoization, but instead of using recursion and memoization, it uses a bottom-up approach to fill in the `dp` table. The `dp[i][j]` table stores the maximum coins obtainable by bursting balloons from index `i` to `j` (exclusive, meaning `i` and `j` are not burst). The order of calculation is crucial:  we iterate over subproblem sizes first, and then over the starting indices within a valid range.  This ensures that the required values of the subproblems are ready before we compute the larger ones.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int maxCoinsTabulation(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    vector&lt;int&gt; nums_padded(n + 2, 1);
    for (int i = 0; i &lt; n; ++i) {
        nums_padded[i + 1] = nums[i];
    }
    vector&lt;vector&lt;int&gt;&gt; dp(n + 2, vector&lt;int&gt;(n + 2, 0));

    for (int len = 2; len &lt;= n + 1; ++len) {
        for (int i = 0; i &lt;= n - len + 1; ++i) {
            int j = i + len;
            for (int k = i + 1; k &lt; j; ++k) {
                dp[i][j] = max(dp[i][j], dp[i][k] + nums_padded[i] * nums_padded[k] * nums_padded[j] + dp[k][j]);
            }
        }
    }
    return dp[0][n + 1];
}

// int main() {
//     vector&lt;int&gt; nums = {3, 1, 5, 8};
//     int result = maxCoinsTabulation(nums);
//     cout &lt;&lt; "Maximum coins: " &lt;&lt; result &lt;&lt; endl;
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(n^3), where n is the number of balloons. The three nested loops determine the time complexity. | <b>Space Complexity:</b> O(n^2) to store the `dp` table.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [3,1,5,8]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">167</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The optimal burst sequence is [1, 5, 3, 8].  Coins earned: 3*1*5 + 3*5*8 + 1*3*8 = 15 + 120 + 24 = 167</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">10</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Burst balloon 1, then balloon 5. 1*1*5 + 5*1*1 = 5+5 = 10</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Burst the balloon 1*1*1 = 1</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Key points:
- The problem benefits greatly from Dynamic Programming, especially with memoization or tabulation.
- Adding virtual balloons (padding) with value 1 at the beginning and end simplifies boundary condition handling.
- The order of bursting balloons drastically changes the total coins, which makes it crucial to consider the subproblems and their optimal solutions before solving a larger problem. The choice of the last balloon to burst within a range is core to the optimization.
- Brute force is impractical due to its exponential time complexity.
- Be mindful of integer overflow, though not a primary concern given the constraints of the problem.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/super-egg-drop/>Super Egg Drop</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>You are given `k` eggs and you have access to a building with `n` floors from `1` to `n`. You want to find the minimum number of moves (i.e., drops) that you need in order to find the critical floor. The critical floor is the lowest floor such that any egg dropped from a floor higher than critical floor will break. If an egg breaks, you cannot drop it again. If an egg doesn't break, you can drop it again.

You can drop an egg from any floor `x` (where `1 <= x <= n`). If the egg breaks, you only have `k - 1` eggs left, and you can only search for the critical floor from floor `1` to `x - 1`. If the egg does not break, you have `k` eggs left, and you can only search for the critical floor from floor `x + 1` to `n`.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach explores all possible drop scenarios. For each floor, we simulate dropping an egg. If the egg breaks, we recursively solve the problem with one fewer egg and floors below. If the egg doesn't break, we recursively solve with the same number of eggs and floors above. We return the minimum number of drops required across all possible floors.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int superEggDropBruteForce(int k, int n) {
    if (n == 0 || n == 1) {
        return n;
    }
    if (k == 1) {
        return n;
    }

    int minMoves = INT_MAX;
    for (int i = 1; i &lt= n; ++i) {
        // Egg breaks
        int breaks = superEggDropBruteForce(k - 1, i - 1);
        // Egg doesn't break
        int doesntBreak = superEggDropBruteForce(k, n - i);
        minMoves = min(minMoves, 1 + max(breaks, doesntBreak));
    }
    return minMoves;
}
</code></pre>
  <p><b>Time Complexity:</b> O(k * n^k).  Each recursive call explores 'n' possibilities for where the egg might break. This branching happens up to 'k' levels deep. | <b>Space Complexity:</b> O(k * n). The recursion depth can go up to k, and in each level, there can be n recursive calls (at worst).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming (Bottom-up)</h5>
  <p>We can optimize the brute force approach using dynamic programming. We define dp[i][j] as the minimum moves needed to determine the critical floor with i eggs and j floors.  We can then build the solution iteratively.

The core logic is: for each number of floors (j), and for each number of eggs (i), we check all possible drop points (x).  If the egg breaks at x, we look at dp[i-1][x-1]. If the egg doesn't break, we look at dp[i][j-x].  We take the maximum of these two (since we want to be safe) plus one (the current drop) and minimize across all x.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int superEggDropDP(int k, int n) {
    vector&lt;vector&lt;int&gt;&gt; dp(k + 1, vector&lt;int&gt;(n + 1, 0));

    // If we have 0 floors or 1 floor, we need 0 or 1 move, respectively.
    for (int i = 1; i &lt= k; ++i) {
        dp[i][1] = 1;
    }
    for (int j = 1; j &lt= n; ++j) {
        dp[1][j] = j;
    }

    for (int i = 2; i &lt= k + 1; ++i) {
        for (int j = 2; j &lt= n + 1; ++j) {
            dp[i][j] = INT_MAX;
            for (int x = 1; x &lt= j; ++x) {
                dp[i][j] = min(dp[i][j], 1 + max(dp[i - 1][x - 1], dp[i][j - x]));
            }
        }
    }
    return dp[k][n];
}
</code></pre>
  <p><b>Time Complexity:</b> O(k * n^2).  We have a nested loop structure: k eggs, n floors, and for each floor, we check all drop possibilities (up to n), so effectively O(k * n * n). | <b>Space Complexity:</b> O(k * n).  We use a 2D dp table of size k x n.</p>
  <h5>‚û§ Dynamic Programming (Optimized)</h5>
  <p>Further optimization can be achieved. Instead of checking each possible drop floor (x) in the inner loop, consider a different DP formulation:  `dp[i][j]` represents the *maximum* number of floors we can test with i eggs and j moves.  This means that `dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1] + 1`.  If the egg breaks (i-1 eggs, j-1 moves), plus the number of floors we can test above the floor if the egg doesn't break (i eggs, j-1 moves), plus the floor itself where the egg was dropped (1).  Since the formula gives us the maximum number of floors we can test, we stop when `dp[k][j]` is &gt;= n.  `j` represents the number of moves. This eliminates the inner loop which was dependent on the number of floors, leading to much better complexity.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int superEggDropDP_Optimized(int k, int n) {
    vector&lt;vector&lt;int&gt;&gt; dp(k + 1, vector&lt;int&gt;(n + 1, 0));

    for (int j = 0; j &lt;= n; ++j) {
        dp[0][j] = 0;
    }

    for (int i = 1; i &lt;= k; ++i) {
        for (int j = 1; j &lt;= n; ++j) {
            dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1] + 1;
            if (dp[i][j] &gt;= n) {
                return j;
            }
        }
    }
    return n; //Should not happen in valid test cases.
}
</code></pre>
  <p><b>Time Complexity:</b> O(k * log(n)).  The nested loops iterates k and up to log(n) times because the outer loop iterates up to n. The number of moves needed for k eggs to test up to n floors can grow geometrically with moves, so we can reach n within log(n) iterations. The number of moves increases geometrically, so the outer loop with j iterates up to log2(n). | <b>Space Complexity:</b> O(k * n).  We are using a 2D dp table of size k x n. However, it's possible to optimize further to O(k) because we only need the previous move's calculations.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">k = 1, n = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">You have only one egg. The best strategy is to drop the egg from the 1st floor and then the 2nd floor.  So, two drops in the worst-case scenario.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">k = 2, n = 6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">With two eggs, you can use a binary search-like strategy.  Drop the first egg from the 3rd floor. If it breaks, drop the second egg from floors 1 and 2.  If the first egg doesn't break, drop from floor 5 and then check one step at a time.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">k = 3, n = 14</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">With three eggs and 14 floors, find the minimum moves to determine the critical floor.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to solving this problem efficiently is to use dynamic programming. The optimized solution is significantly faster because it reduces the search space by formulating the problem in terms of what can be tested (floors) with a given number of eggs and moves, rather than brute-forcing the decision at each floor drop. Edge cases include k=1 and n=1 or 0. The optimal solution can be further optimized using space optimization in the dp table.</p>
</div>
<hr style="margin: 40px 0;">
<h2>Two Pointer Approach</h2>
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/sort-colors/>Sort Colors</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an array `nums` with `n` objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We use the integers 0, 1, and 2 to represent the colors red, white, and blue, respectively. You must solve this problem without using the library's sort function.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Count the occurrences of each color (0, 1, and 2), and then overwrite the `nums` array based on the counts.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    void sortColors(vector&lt;int&gt;&amp; nums) {
        int count0 = 0, count1 = 0, count2 = 0;
        for (int num : nums) {
            if (num == 0) count0++;
            else if (num == 1) count1++;
            else count2++;
        }

        int index = 0;
        for (int i = 0; i &lt; count0; i++) {
            nums[index++] = 0;
        }
        for (int i = 0; i &lt; count1; i++) {
            nums[index++] = 1;
        }
        for (int i = 0; i &lt; count2; i++) {
            nums[index++] = 2;
        }
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n) to count + O(n) to rewrite = O(n) | <b>Space Complexity:</b> O(1) - Constant extra space for the counts</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Two-Pointer (Dutch National Flag)</h5>
  <p>Use three pointers: `low`, `mid`, and `high`.  `low` points to the beginning of the array, `high` points to the end. `mid` iterates through the array. If `nums[mid]` is 0, swap it with `nums[low]` and increment both `low` and `mid`. If `nums[mid]` is 1, increment `mid`. If `nums[mid]` is 2, swap it with `nums[high]` and decrement `high`. Do not increment `mid` in this case, as the swapped element might need to be processed.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    void sortColors(vector&lt;int&gt;&amp; nums) {
        int low = 0, mid = 0, high = nums.size() - 1;
        while (mid &lt;= high) {
            if (nums[mid] == 0) {
                swap(nums[low], nums[mid]);
                low++;
                mid++;
            } else if (nums[mid] == 1) {
                mid++;
            } else {
                swap(nums[mid], nums[high]);
                high--;
            }
        }
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n) - Each element is visited at most once. | <b>Space Complexity:</b> O(1) - Constant extra space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [2,0,2,1,1,0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[0,0,1,1,2,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">After sorting, the colors are in the correct order.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [2,0,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[0,1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">After sorting, the colors are in the correct order.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Already sorted.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Already sorted.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Already sorted.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The in-place requirement is crucial. The two-pointer approach efficiently sorts the array without using extra space (other than a few pointers).  The `mid` pointer does not increment after a swap with `high` because the swapped element might be 0 or 1 and requires further processing.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/longest-repeating-character-replacement/>Longest Repeating Character Replacement</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times. Return the length of the longest substring containing the same letter you can get after performing the above operations.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible substrings. For each substring, count the frequency of each character. Find the maximum frequency and check if the difference between the substring length and the maximum frequency is at most k. If it is, update the maximum length found so far.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

int characterReplacement_bruteForce(string s, int k) {
    int n = s.length();
    int max_length = 0;
    for (int i = 0; i &lt n; ++i) {
        for (int j = i; j &lt n; ++j) {
            string sub = s.substr(i, j - i + 1);
            unordered_map&ltchar, int&gt; counts;
            int max_freq = 0;
            for (char c : sub) {
                counts[c]++;
                max_freq = max(max_freq, counts[c]);
            }
            if (sub.length() - max_freq &lt= k) {
                max_length = max(max_length, (int)sub.length());
            }
        }
    }
    return max_length;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^3) - Nested loops for substring generation and character counting. | <b>Space Complexity:</b> O(1) - Constant extra space for counts in the worst case (due to the char set size being fixed)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Sliding Window</h5>
  <p>Use a sliding window approach. Maintain a window with the maximum frequency character. Expand the window to the right. If the number of replacements needed (window size - max frequency) exceeds k, shrink the window from the left until the replacements needed are within k. Keep track of the maximum window size.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

int characterReplacement_optimized(string s, int k) {
    int n = s.length();
    vector&ltint&gt; counts(26, 0);
    int left = 0;
    int max_length = 0;
    int max_count = 0;
    for (int right = 0; right &lt n; ++right) {
        max_count = max(max_count, ++counts[s[right] - 'A']);
        while (right - left + 1 - max_count &gt k) {
            counts[s[left] - 'A']--;
            left++;
        }
        max_length = max(max_length, right - left + 1);
    }
    return max_length;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) - Single pass through the string. | <b>Space Complexity:</b> O(1) - Constant extra space for the counts array.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "ABAB", k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Replace the two 'A's with two 'B's or vice versa.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "AABABBA", k = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Replace the one 'B' in the substring "AABA" with 'A'.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "AAAA", k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No replacement needed.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "AAAA", k = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No replacement allowed.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "ABAA", k = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No replacement allowed. Max length is 2 ("AA").</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key idea is to efficiently find the longest substring where the number of replacements is within the allowed limit. Sliding window optimizes this by checking the counts during iteration and adjusting the window. Edge cases include when k is zero and when the string has no repeating characters. The alphabet size is assumed to be 26 (uppercase english characters).</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/maximum-number-of-visible-points/>Maximum Number of Visible Points</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>You are given an array `points`, an integer `angle`, and your location `location`, where `location = [x, y]` and `points[i] = [xi, yi]`. The `angle` represents the field of view in degrees. You can rotate your field of view in any direction. Return the maximum number of points you can see. You can see a point if its distance from your location is not greater than the given `angle` and the angle formed between your location and the point is within the field of view.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Calculate the angle between your location and each point. For each possible starting point of the field of view (0 to 360 degrees), check how many points fall within the angle range (angle degrees).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

double calculateAngle(int x1, int y1, int x2, int y2) {
    double dx = x2 - x1;
    double dy = y2 - y1;
    return atan2(dy, dx) * 180 / M_PI;
}

int maxVisiblePointsBruteForce(vector&lt;vector&lt;int&gt;&gt;& points, int angle, vector&lt;int&gt;& location) {
    int maxPoints = 0;
    int x0 = location[0];
    int y0 = location[1];

    for (int startAngle = 0; startAngle &lt; 360; ++startAngle) {
        int visiblePoints = 0;
        for (const auto& point : points) {
            int x = point[0];
            int y = point[1];
            double pointAngle = calculateAngle(x0, y0, x, y);

            // Normalize the angle to be within [0, 360)
            if (pointAngle &lt; 0) {
                pointAngle += 360;
            }

            // Check if the point is within the view angle
            if (pointAngle &gt;= startAngle &amp;&amp; pointAngle &lt;= startAngle + angle) {
                visiblePoints++;
            } else if (startAngle + angle &gt;= 360 &amp;&amp; (pointAngle &gt;= startAngle || pointAngle &lt;= (startAngle + angle) % 360)) {
                visiblePoints++;
            }
        }
        maxPoints = max(maxPoints, visiblePoints);
    }
    return maxPoints;
}

// The main function to test the brute force approach (Not part of the solution, just for testing)
// int main() {
//     vector&lt;vector&lt;int&gt;&gt; points = {{2, 1}, {2, 2}, {3, 3}};
//     int angle = 90;
//     vector&lt;int&gt; location = {1, 1};
//     int result = maxVisiblePointsBruteForce(points, angle, location);
//     cout &lt;&lt; "Maximum visible points: " &lt;&lt; result &lt;&lt; endl;
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(N * 360), where N is the number of points. | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Sliding Window with Angle Conversion</h5>
  <p>1.  **Calculate Angles:** Convert each point to an angle relative to the location.  The use atan2 for correct quadrant determination.
2.  **Sort Angles:** Sort the calculated angles.
3.  **Duplicate Angles (Circular Problem):** Duplicate the angles and add 360 to the copies to account for the circular nature of the problem (0 and 360 are adjacent).
4.  **Sliding Window:** Use a sliding window approach.  The window size represents the viewing angle.  Slide the window through the sorted and duplicated angles. Count the number of points within the window and update the maximum count.
5. **Handle the location itself:** If the location is on any point, add those points to the result before the sliding window approach.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

double calculateAngle(int x1, int y1, int x2, int y2) {
    double dx = x2 - x1;
    double dy = y2 - y1;
    return atan2(dy, dx) * 180 / M_PI;
}

int maxVisiblePointsOptimized(vector&lt;vector&lt;int&gt;&gt;& points, int angle, vector&lt;int&gt;& location) {
    int x0 = location[0];
    int y0 = location[1];
    vector&lt;double&gt; angles;
    int samePoints = 0;

    for (const auto& point : points) {
        int x = point[0];
        int y = point[1];
        if (x == x0 &amp;&amp; y == y0) {
            samePoints++;
            continue;
        }
        double pointAngle = calculateAngle(x0, y0, x, y);
        if (pointAngle &lt; 0) {
            pointAngle += 360;
        }
        angles.push_back(pointAngle);
    }
    sort(angles.begin(), angles.end());
    int n = angles.size();
    for (int i = 0; i &lt; n; ++i) {
        angles.push_back(angles[i] + 360);
    }

    int maxPoints = 0;
    int left = 0, right = 0;
    while (right &lt; angles.size()) {
        while (right &lt; angles.size() &amp;&amp; angles[right] - angles[left] &lt;= angle) {
            right++;
        }
        maxPoints = max(maxPoints, right - left);
        left++;
    }

    return maxPoints + samePoints;
}

// The main function to test the optimized approach (Not part of the solution, just for testing)
// int main() {
//     vector&lt;vector&lt;int&gt;&gt; points = {{2, 1}, {2, 2}, {3, 3}};
//     int angle = 90;
//     vector&lt;int&gt; location = {1, 1};
//     int result = maxVisiblePointsOptimized(points, angle, location);
//     cout &lt;&lt; "Maximum visible points: " &lt;&lt; result &lt;&lt; endl;
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(N log N) due to sorting, where N is the number of points. | <b>Space Complexity:</b> O(N)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">points = [[2,1],[2,2],[3,3]], angle = 90, location = [1,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">All three points are visible.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">points = [[1,0],[2,0],[2,1],[1,1],[1,2]], angle = 0, location = [1,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Only the point [1,1] itself and one other point will be visible because the angle is 0.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">points = [[1,1],[2,2],[3,3]], angle = 0, location = [1,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Only the point [1,1] itself is visible.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to optimization is to convert the cartesian coordinates to angles and utilize a sliding window. The duplicate angles are used to handle edge cases.  Also, consider the case if the location is same as the point, consider it before other points calculation.</p>
</div>
<hr style="margin: 40px 0;">
<h2>Greedy Algorithms</h2>
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/gas-station/>Gas Station</a> <span style="font-size:14px; color:#888;">Easy/Medium</span></h3>
  <p>You are given two integer arrays gas and cost. You have a circular route, where there are n gas stations. You start at gas station i and want to travel around the circuit once in the clockwise direction. You have a car with an unlimited gas tank. At each gas station i, you can fill up with gas[i] units of gas. You also have a cost[i] units to travel to the next gas station i+1. Given gas and cost, return the starting gas station's index if you can travel around the circuit once, otherwise return -1. If there exists a solution, it is guaranteed to be unique.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through each gas station as a starting point. For each starting point, simulate a full circuit. If the car runs out of gas at any point, this starting point is invalid. Otherwise, return the starting point's index.</p>
  <pre><code class="language-python">#include &ltiostream&gt
#include &ltvector&gt

using namespace std;

int canCompleteCircuitBruteForce(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {
    int n = gas.size();
    for (int start = 0; start &lt; n; ++start) {
        int current_gas = 0;
        int i = start;
        bool possible = true;
        for (int count = 0; count &lt; n; ++count) {
            current_gas += gas[i];
            if (current_gas &lt; cost[i]) {
                possible = false;
                break;
            }
            current_gas -= cost[i];
            i = (i + 1) % n;
        }
        if (possible) {
            return start;
        }
    }
    return -1;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) -  We iterate through each gas station as a potential start (O(n)), and for each start, we iterate through the circuit (O(n)). | <b>Space Complexity:</b> O(1) - Constant extra space is used.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Greedy Approach</h5>
  <p>The key idea is to check if there's a feasible starting point. The car will always complete the circuit if the total gas is greater than or equal to the total cost.  We start from a random starting point and traverse around the circuit. If, at any point, the gas becomes negative, then the starting point needs to be adjusted.  If the total gas is greater than or equal to the total cost, then a starting index is guaranteed to be found.</p>
  <pre><code class="language-python">#include &ltiostream&gt
#include &ltvector&gt

using namespace std;

int canCompleteCircuitOptimized(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {
    int n = gas.size();
    int total_gas = 0;
    int current_gas = 0;
    int start = 0;

    for (int i = 0; i &lt; n; ++i) {
        total_gas += gas[i] - cost[i];
        current_gas += gas[i] - cost[i];
        if (current_gas &lt; 0) {
            start = i + 1;
            current_gas = 0;
        }
    }

    if (total_gas &lt; 0) {
        return -1;
    }
    return start;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n) - We iterate through the gas and cost arrays only once. | <b>Space Complexity:</b> O(1) - Constant extra space is used.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">gas = [1,2,3,4,5], cost = [3,4,5,1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Start at station 3 (index 3) and fill 4 unit of gas. Your tank = 0 + 4 = 4. Travel to station 4. Your tank = 4 - 1 + 5 = 8. Travel to station 0. Your tank = 8 - 2 + 1 = 7. Travel to station 1. Your tank = 7 - 3 + 2 = 6. Travel to station 2. Your tank = 6 - 4 + 3 = 5. Travel to station 3. The cost is not greater than the gas.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">gas = [2,3,4], cost = [3,4,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">-1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">You can't start at station 0 because gas[0] &lt; cost[0]. You can't start at station 1, and you can't start at station 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">gas = [5,1,2,3,4], cost = [4,4,1,5,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Similar logic as above.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Important considerations include: 
1.  If the sum of gas is less than the sum of cost, then no solution exists. 
2.  If a solution exists, it is guaranteed to be unique, so once a starting point is found, it is the answer. 
3.  The starting point does not have to be the first element. 
4. The problem is about finding a start node such that for all the other nodes we have gas &gt; cost before traversing to the next node</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/minimum-cost-for-acquiring-all-coins-with-k-extra-coins-allowed-with-every-coin/>Minimum cost for acquiring all coins with k extra coins allowed with every coin</a> <span style="font-size:14px; color:#888;">Easy/Medium</span></h3>
  <p>You are given an array of coin values.  For each coin you acquire, you can get *k* extra coins for free.  The goal is to determine the minimum cost to acquire all coins. You can choose the order in which to acquire the coins.

Essentially, you want to minimize the sum of the purchased coin values, intelligently leveraging the free coins.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves trying all possible permutations of acquiring the coins.  For each permutation, iterate through the coins and calculate the cost, accounting for the free coins earned with each purchase. This approach explores all possibilities and is guaranteed to find the minimum cost.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int minCostBruteForce(vector&lt;int&gt;&amp; coins, int k) {
    int n = coins.size();
    int minCost = INT_MAX;
    sort(coins.begin(), coins.end()); // Sorting enables faster calculation of free coins.
    do {
        int cost = 0;
        int acquired = 0;
        int i = 0;
        while (acquired &lt n) {
            cost += coins[i];
            acquired++;
            i++;
            for (int j = 0; j &lt k &amp;&amp; i &lt n; ++j) {
                i++;
                acquired++;
            }
        }
        minCost = min(minCost, cost);
    } while (next_permutation(coins.begin(), coins.end()));
    return minCost;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n! * n), where n is the number of coins. O(n!) for generating permutations and O(n) for calculating the cost for each permutation. | <b>Space Complexity:</b> O(1) -  Constant extra space. Note that `sort` can take O(log n) space in some implementations.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Greedy Approach</h5>
  <p>Sort the coins in ascending order. This ensures that we are choosing the smaller cost coins first, and the largest coins will be the ones acquired via the free coins. Iterate through the sorted array.  Calculate the cost by adding the coins that are paid for by the buyer. The number of coins paid for is going to be `(n + k) / (k + 1)`. The rest will come as free coins. Iterate and add the coins that the user need to pay for.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int minCostGreedy(vector&lt;int&gt;&amp; coins, int k) {
    int n = coins.size();
    sort(coins.begin(), coins.end());
    int cost = 0;
    for (int i = 0; i &lt n; ++i) {
        if(i % (k+1) == 0) {
            cost += coins[i];
        }
    }
    return cost;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log n) - dominated by the sorting step. | <b>Space Complexity:</b> O(1) - constant extra space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">coins = [1, 2, 3, 4, 5], k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Sort coins: [1, 2, 3, 4, 5]. Buy 1 (cost 1), get 2 and 3 free. Buy 4 (cost 4), get 5 free. Cost is 1 + 4 = 6</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">coins = [1, 2, 3, 4, 5], k = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">15</td>
        <td style="border: 1px solid #ccc; padding: 6px;">With k=0, you must pay for all coins. 1+2+3+4+5 = 15</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">coins = [1, 1, 2, 2, 3], k = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Sort coins: [1, 1, 2, 2, 3]. Buy 1(cost 1), get 1 free. Buy 2(cost 2), get 2 free. Buy 3(cost 3). Cost = 1 + 2 + 3 = 4 </td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The core idea is to sort the coins and apply a greedy strategy. The free coins are handled by carefully skipping `k` elements after paying for one.  Edge cases include k=0, in which case all coins must be paid for, and handling duplicates in the coin values.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/restore-the-array-from-adjacent-pairs/>Restore the Array From Adjacent Pairs</a> <span style="font-size:14px; color:#888;">Easy/Medium</span></h3>
  <p>You are given an array of adjacent pairs where each pair represents two numbers that are adjacent in an unknown array. Your task is to reconstruct the original array.  The adjacent pairs array may contain duplicates, and the order of pairs is not guaranteed to reflect the order in the original array.  The reconstructed array should contain each number only once.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>This approach involves creating a graph from the adjacent pairs. Each unique number is a node, and an edge exists between two numbers if they are adjacent. We then find the starting node(s) which have only one neighbor.  We can start DFS/BFS from these nodes, and reconstruct the array by traversing the graph.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

vector&lt;int&gt; restoreArrayBruteForce(vector&lt;vector&lt;int&gt;&gt;&amp; adjacentPairs) {
    unordered_map&lt;int, vector&lt;int&gt;&gt; adj;
    unordered_map&lt;int, int&gt; degree;

    // Build the graph and count degrees
    for (const auto& pair : adjacentPairs) {
        int u = pair[0], v = pair[1];
        adj[u].push_back(v);
        adj[v].push_back(u);
        degree[u]++;
        degree[v]++;
    }

    // Find the starting node(s)
    int startNode = 0;
    for (auto const& [node, deg] : degree) {
        if (deg == 1) {
            startNode = node;
            break;
        }
    }

    vector&lt;int&gt; result;
    unordered_set&lt;int&gt; visited;
    queue&lt;int&gt; q;
    q.push(startNode);
    visited.insert(startNode);

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        result.push_back(u);

        for (int v : adj[u]) {
            if (visited.find(v) == visited.end()) {
                q.push(v);
                visited.insert(v);
            }
        }
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of adjacent pairs. Building the graph is O(N), and traversing the graph (DFS/BFS) is also O(N). | <b>Space Complexity:</b> O(N), for the graph (adjacency list) and visited set.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized approach using Graph Traversal (DFS/BFS)</h5>
  <p>This approach uses a graph represented by an adjacency list.  We first build the graph from the pairs.  Then, we find the starting node (a node with degree 1).  From this node, we perform a Depth First Search (DFS) or Breadth First Search (BFS) to reconstruct the array.  We use a map to keep track of the neighbors and a set to keep track of visited nodes.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

vector&lt;int&gt; restoreArrayOptimized(vector&lt;vector&lt;int&gt;&gt;&amp; adjacentPairs) {
    unordered_map&lt;int, vector&lt;int&gt;&gt; adj;
    unordered_map&lt;int, int&gt; degree;

    // Build the graph
    for (const auto& pair : adjacentPairs) {
        int u = pair[0], v = pair[1];
        adj[u].push_back(v);
        adj[v].push_back(u);
        degree[u]++;
        degree[v]++;
    }

    // Find the starting node
    int startNode = 0;
    for (auto const& [node, deg] : degree) {
        if (deg == 1) {
            startNode = node;
            break;
        }
    }

    vector&lt;int&gt; result;
    unordered_set&lt;int&gt; visited;
    queue&lt;int&gt; q;
    q.push(startNode);
    visited.insert(startNode);
    result.push_back(startNode);

    while (!q.empty()) {
        int u = q.front();
        q.pop();

        for (int v : adj[u]) {
            if (visited.find(v) == visited.end()) {
                result.push_back(v);
                visited.insert(v);
                q.push(v);
            }
        }
    }
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of adjacent pairs. Building the graph and traversing it takes linear time. | <b>Space Complexity:</b> O(N), to store the graph (adjacency list), the visited set, and the resulting array.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[2,1],[3,4],[3,2]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[1,2,3,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The array can be [1,2,3,4] or [4,3,2,1]. Either is valid.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[4,-2],[1,4],[-3,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[-2,4,1,-3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The array can be [-2,4,1,-3] or [-3,1,4,-2].</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[100,-10],[89,100],[-10,-89],[-89,28]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[28,-89,-10,100,89]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Various orderings are possible.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. The graph may have multiple valid solutions depending on the starting node.
2. Handle the case where there are multiple nodes with degree 1 (can start at any). 
3. Ensure no duplicates are added to the result array.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/task-scheduler/>Task Scheduler</a> <span style="font-size:14px; color:#888;">Easy/Medium</span></h3>
  <p>Given a char array representing tasks where tasks[i] = 'A', 'B', 'C', ... represent the tasks, and an integer n. Each task can be done in one unit of time. Tasks can be done in any order. There is a non-negative cooling time n. You must separate the same tasks by at least n units of time. Return the least number of units of time that the CPU will take to finish all the given tasks.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute force approach involves simulating the task scheduling process. We can try all possible permutations of tasks and check for the minimum time required. Since this is not practical for larger inputs due to its exponential time complexity, it's not a viable approach for this problem. We will schedule tasks one by one, prioritizing the most frequent task and inserting idle periods if necessary.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// This approach is conceptually sound, but inefficient and not practically implemented due to time complexity constraints.
// It's included for understanding the limitations of a brute-force strategy.

// Brute force simulation to find the minimum time, not a practical implementation due to time complexity.
// The commented-out code demonstrates the concept.
/*
int leastInterval(vector&lt;char&gt;&amp; tasks, int n) {
    int time = 0;
    unordered_map&lt;char, int&gt; taskCounts;
    for (char task : tasks) {
        taskCounts[task]++;
    }

    vector&lt;pair&lt;int, char&gt;&gt; taskQueue;
    for(auto const&amp; [key, val] : taskCounts) {
        taskQueue.push_back({val, key});
    }
    
    sort(taskQueue.begin(), taskQueue.end(), greater&lt;pair&lt;int, char&gt;&gt;());

    while(!taskQueue.empty()) {
        int i = 0;
        vector&lt;pair&lt;int, char&gt;&gt; nextTasks;
        for (; i &lt;= n; ++i) {
            if(!taskQueue.empty()) {
                auto [count, task] = taskQueue[0];
                taskQueue.erase(taskQueue.begin());
                time++;
                if (count &gt; 1) {
                   nextTasks.push_back({count-1, task});
                }
            } else {
                if (i &lt;= n) {
                    time++; // Cooling time
                }
            }
        }
        for(auto&amp; task: nextTasks) {
            taskQueue.push_back(task);
        }
        sort(taskQueue.begin(), taskQueue.end(), greater&lt;pair&lt;int, char&gt;&gt;());
    }

    return time;
}
*/

</code></pre>
  <p><b>Time Complexity:</b> O(N! * N) - Highly inefficient due to permutations, where N is the number of tasks. | <b>Space Complexity:</b> O(N) - For storing task counts.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Greedy with Frequency Counting</h5>
  <p>1.  Count the frequency of each task.
2.  Find the maximum frequency (maxFreq).
3.  Calculate the number of tasks that have the maximum frequency (maxCount).
4.  Calculate the minimum time: `(maxFreq - 1) * (n + 1) + maxCount`
5.  If the calculated time is less than the total number of tasks, return the total number of tasks.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int leastInterval(vector&lt;char&gt;&amp; tasks, int n) {
    unordered_map&lt;char, int&gt; taskCounts;
    for (char task : tasks) {
        taskCounts[task]++;
    }

    int maxFreq = 0;
    int maxCount = 0;
    for (auto const&amp; [key, val] : taskCounts) {
        if (val &gt; maxFreq) {
            maxFreq = val;
            maxCount = 1;
        } else if (val == maxFreq) {
            maxCount++;
        }
    }

    int time = (maxFreq - 1) * (n + 1) + maxCount;
    return max(time, (int)tasks.size());
}
</code></pre>
  <p><b>Time Complexity:</b> O(N), where N is the number of tasks. We iterate through the tasks once to count frequencies and then iterate through the map which in the worst case has size N. Thus, O(N). | <b>Space Complexity:</b> O(26) or O(1) because there can be at most 26 distinct tasks (A-Z).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">tasks = ['A','A','A','B','B','B'], n = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">8</td>
        <td style="border: 1px solid #ccc; padding: 6px;">A -> B -> idle -> A -> B -> idle -> A -> B.  There are three A's and three B's. The maximum frequency is 3. So the answer is (3-1)*(2+1) + 2 = 8.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">tasks = ['A','A','A','B','B','B'], n = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">If n = 0, there's no cooling time. Therefore, we can execute tasks in any order.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">tasks = ['A','A','A','A','A','A','B','C','D','E','F','G'], n = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">16</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The task 'A' has the highest frequency which is 6. So the intervals are (6-1) * (2+1) = 15. Plus the number of times A appears which is 16 total.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The critical observation is that the problem's solution is dominated by the task with the highest frequency. The cooling time effectively creates blocks where the most frequent task is placed. The number of idle slots is dependent on the tasks with the highest frequency and the cooling time.  If the number of tasks is greater than the calculated time, we simply execute all tasks in the given order, so the total time would be task size. The key is correctly calculating the minimum time considering cooling constraints and frequencies.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/>Minimum Deletions to Make Character Frequencies Unique</a> <span style="font-size:14px; color:#888;">Easy/Medium</span></h3>
  <p>Given a string `s`, return the minimum number of deletions so that the frequency of each character in the string is unique.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves generating all possible subsets of the string and checking if the frequencies of the characters in each subset are unique. This is done by counting the frequencies of each character in a subset and checking if any frequency is repeated. The minimum number of deletions is the difference between the original string length and the length of the longest unique frequency subset.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int minDeletionsBruteForce(string s) {
    int n = s.length();
    int minDeletions = n; // Initialize with maximum possible deletions

    for (int i = 0; i &lt (1 &lt&lt n); ++i) {
        string subset = "";
        for (int j = 0; j &lt n; ++j) {
            if ((i &amp (1 &lt&lt j)) != 0) {
                subset += s[j];
            }
        }

        unordered_map&ltchar, int&gt freq;
        for (char c : subset) {
            freq[c]++;
        }

        vector&ltint&gt frequencies;
        for (auto const& [key, val] : freq) {
            frequencies.push_back(val);
        }

        sort(frequencies.begin(), frequencies.end());
        bool unique = true;
        for (int k = 1; k &lt frequencies.size(); ++k) {
            if (frequencies[k] == frequencies[k - 1]) {
                unique = false;
                break;
            }
        }

        if (unique) {
            minDeletions = min(minDeletions, n - (int)subset.length());
        }
    }
    return minDeletions;
}
</code></pre>
  <p><b>Time Complexity:</b> O(2^N * N), where N is the length of the string. We generate all possible subsets (2^N), and for each subset, we iterate through the string (O(N)) to create frequency map and check for uniqueness. | <b>Space Complexity:</b> O(N) in worst case, to store the frequencies and potentially the subset string.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach: Greedy with Sorting and Set</h5>
  <p>This optimized approach utilizes a greedy strategy. First, we count the frequency of each character in the string. Then, we sort the frequencies in descending order. We iterate through the sorted frequencies. If a frequency is already present, we decrement it until it's unique or becomes zero. We increment the deletion count by the number of decrements performed.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int minDeletionsOptimized(string s) {
    unordered_map&ltchar, int&gt freq;
    for (char c : s) {
        freq[c]++;
    }

    vector&ltint&gt frequencies;
    for (auto const& [key, val] : freq) {
        frequencies.push_back(val);
    }

    sort(frequencies.begin(), frequencies.end(), greater&lt;int&gt;());

    int deletions = 0;
    unordered_set&ltint&gt usedFrequencies;

    for (int f : frequencies) {
        while (f &gt 0 &amp;&amp; usedFrequencies.count(f) &gt 0) {
            f--;
            deletions++;
        }
        if (f &gt; 0) {
            usedFrequencies.insert(f);
        }
    }

    return deletions;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N + KlogK), where N is the length of the string, and K is the number of unique characters (at most 26 for lowercase English alphabets). Counting frequencies is O(N). Sorting frequencies is O(KlogK). The while loop takes at most O(K) in total. | <b>Space Complexity:</b> O(K), where K is the number of unique characters (at most 26), to store frequencies and the used frequencies set.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">"aab"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The frequencies are 2 for 'a' and 1 for 'b'. No deletions are needed as frequencies are unique.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">"aaabbbcc"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The frequencies are 3 for 'a', 3 for 'b', and 2 for 'c'.  We need to delete one 'b' to make frequencies unique (3, 2, 2), and then one more to make the frequencies unique (3, 2, 1), and then finally make (3, 2, 1) where the deletion count is 2. Or reduce the counts to (3, 2, 1).</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">"ceabaacb"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The character frequencies are: 'c': 2, 'e': 1, 'a': 3, 'b': 1. We have frequencies 1, 1, 2, 3. Making the frequencies unique, we can modify it to 3, 2, 1 and delete two to make it unique. Or change it to 3, 2, 0 or 3, 1, 0 or 2, 1, 0</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The greedy approach works because we prioritize making the largest frequencies unique first. Sorting the frequencies and decrementing as needed ensures that we make the minimum number of deletions. Edge cases include strings with all the same characters (e.g., "aaaaaa") or strings with a mixture of unique and duplicate frequencies.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/remove-k-digits/>Remove K Digits</a> <span style="font-size:14px; color:#888;">Easy/Medium</span></h3>
  <p>Given string num representing a non-negative integer and an integer k, return the smallest possible integer after removing k digits from num.  The order of the remaining digits must be preserved.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Generate all possible substrings by removing k digits. Then, find the minimum value among them. This can be done using recursion to explore all possible removals.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

string removeKDigitsBruteForce(string num, int k) {
    if (k == num.length()) {
        return "0";
    }

    string minNum = "9999999999999999999999999999999999999999999999999999"; // A large string for comparison

    function&lt;void(int, string)&gt; solve = [&](int index, string currentNum) {
        if (index == num.length()) {
            if (num.length() - currentNum.length() == k) {
                //Remove leading zeros
                size_t start = currentNum.find_first_not_of('0');
                if (start == string::npos) {
                  currentNum = "0";
                } else {
                  currentNum = currentNum.substr(start);
                }
                if (currentNum.length() &lt minNum.length() || (currentNum.length() == minNum.length() &amp;&amp; currentNum &lt minNum))
                {
                    minNum = currentNum;
                }
            }
            return;
        }

        // Include the current digit
        solve(index + 1, currentNum + num[index]);
        // Exclude the current digit
        solve(index + 1, currentNum);
    };

    solve(0, "");

    return minNum;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n * 2^n), where n is the length of the input string. For each digit, we either include or exclude it. And, in the worst case, we check almost all possible substrings. | <b>Space Complexity:</b> O(n) due to the recursive call stack.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Using Stack (Greedy Approach)</h5>
  <p>Iterate through the digits of the number. Use a stack to maintain a monotonically increasing sequence of digits (from left to right).  If the current digit is smaller than the top of the stack, pop elements from the stack until either the stack is empty or the top element is smaller than or equal to the current digit, and we can remove k digits.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

string removeKDigitsOptimized(string num, int k) {
    stack&lt;char&gt; s;

    for (char digit : num) {
        while (!s.empty() &amp;&amp; k &gt 0 &amp;&amp; s.top() &gt digit) {
            s.pop();
            k--;
        }
        s.push(digit);
    }

    // If k is still greater than 0, remove digits from the end (largest digits remain).
    while (k &gt 0) {
        s.pop();
        k--;
    }

    // Build the result string.
    string result = "";
    while (!s.empty()) {
        result = s.top() + result;
        s.pop();
    }

    // Remove leading zeros.
    size_t start = result.find_first_not_of('0');
    if (start == string::npos) {
        return "0";
    }
    return result.substr(start);
}
</code></pre>
  <p><b>Time Complexity:</b> O(n), where n is the length of the input string. Each digit is pushed and popped at most once. | <b>Space Complexity:</b> O(n) in the worst case, where all digits are in increasing order and added in the stack.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">num = "1432219", k = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1219</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Remove the digits 4, 3, and 2 to form the smallest number.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">num = "10200", k = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">200</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Remove the leading 1.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">num = "10", k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Remove both digits to get 0.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">num = "1111111", k = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1111</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Remove any three digits.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">num = "12345", k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">123</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Since the digits are increasing, remove the last 2 digits</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The greedy approach using a stack is the most efficient.  2. Edge cases include handling leading zeros and the case where k equals the length of the input. 3. Consider edge case where input is a string of same digits, such as "1111". We must remove k digits from the right side in this case to produce the smallest result. 4. If after removing k digits, the resultant string has leading zeros, we should trim it and return "0" if all digits are zero.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.spoj.com/problems/CHOCOLA/>CHOCOLA - Chocolate</a> <span style="font-size:14px; color:#888;">Easy/Medium</span></h3>
  <p>Given the costs of cutting a chocolate bar horizontally and vertically, and the desired number of horizontal and vertical cuts, find the minimum cost to cut the chocolate into individual pieces. The cost of each cut is the cost associated with the cut multiplied by the number of existing pieces the cut goes through.

You are given the costs of horizontal and vertical cuts (integers) and the number of horizontal and vertical cuts you must perform.  The goal is to minimize the total cost of making these cuts.

Input:

The first line contains two space-separated integers M and N, representing the number of horizontal and vertical cuts needed respectively.
The second line contains M-1 space separated integers representing the cost of horizontal cuts.
The third line contains N-1 space separated integers representing the cost of vertical cuts.

Output:

Output a single integer, representing the minimal cost to cut the chocolate.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The problem can be solved by trying all possible combinations of cuts. However, this leads to a very high time complexity (exponential), so it's not a feasible approach to solve the problem efficiently.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

// This is just a conceptual illustration. A complete brute-force implementation is not practical
// for the given constraints.

int main() {
    int m, n;
    cin >> m >> n;
    vector&ltint&gt horizontal(m - 1);
    vector&ltint&gt vertical(n - 1);
    for (int i = 0; i &lt m - 1; ++i) {
        cin >> horizontal[i];
    }
    for (int i = 0; i &lt n - 1; ++i) {
        cin >> vertical[i];
    }

    // Brute-force solution would involve generating all combinations, which is inefficient.
    // This is just a placeholder.
    cout &lt&lt "This problem cannot be solved efficiently with brute force." &lt&lt endl;
    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(exponential) - Not feasible | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Greedy Approach</h5>
  <p>Sort the horizontal and vertical cut costs in descending order. Prioritize making cuts that affect the maximum number of existing pieces. For each cut, multiply the cost by the number of pieces it affects. This is the key insight ‚Äì use the cuts that affect most pieces first, leading to the optimal solution. Apply this greedy approach by taking cuts in sorted descending order.  The number of pieces a cut affects is equal to (number of horizontal segments + 1) if it is a vertical cut, and (number of vertical segments + 1) if it is a horizontal cut.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

int main() {
    int m, n;
    cin >> m >> n;

    vector&ltint&gt horizontal(m - 1);
    vector&ltint&gt vertical(n - 1);

    for (int i = 0; i &lt m - 1; ++i) {
        cin >> horizontal[i];
    }
    for (int i = 0; i &lt n - 1; ++i) {
        cin >> vertical[i];
    }

    sort(horizontal.rbegin(), horizontal.rend());
    sort(vertical.rbegin(), vertical.rend());

    int horizontal_cuts = 0;
    int vertical_cuts = 0;
    int cost = 0;
    int h_idx = 0, v_idx = 0;

    while (h_idx &lt horizontal.size() || v_idx &lt vertical.size()) {
        if (h_idx &lt horizontal.size() &amp;&amp; (v_idx == vertical.size() || horizontal[h_idx] &gt vertical[v_idx])) {
            cost += horizontal[h_idx] * (vertical_cuts + 1);
            horizontal_cuts++;
            h_idx++;
        }
        else {
            cost += vertical[v_idx] * (horizontal_cuts + 1);
            vertical_cuts++;
            v_idx++;
        }
    }

    cout &lt&lt cost &lt&lt endl;

    return 0;
}</code></pre>
  <p><b>Time Complexity:</b> O( (M + N)log(M + N) ) - dominated by sorting. | <b>Space Complexity:</b> O(M + N)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">2 2
2
1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1 horizontal cut, 1 vertical cut. Horizontal cost is 2, vertical cost is 1. Total cost 2*1 + 1*2 = 4.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">3 3
2 1
3 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">16</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Sorting makes horizontal cuts 2,1 and vertical 3,1. 2*(1+1) + 3*(1+1) + 1*(2+1) + 1*(2+1) = 4+6+3+3 = 16.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">3 2
2 1
3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">10</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Horizontal cuts are 2 and 1. Vertical cut is 3. Total cost is 2*1 + 3*1 + 1*2 + 3*1 = 10</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The greedy approach is optimal because it prioritizes cuts that maximize the impact on the total cost in each step. Correctly sorting and tracking the segments created by previous cuts are crucial.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/non-overlapping-intervals/>Non-overlapping Intervals</a> <span style="font-size:14px; color:#888;">Easy/Medium</span></h3>
  <p>Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible combinations of intervals to check for overlaps. For each combination, count the number of removed intervals. Keep track of the minimum number of removals.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int eraseOverlapIntervals_bruteForce(vector&lt;vector&lt;int&gt;&gt;& intervals) {
    int n = intervals.size();
    int minRemovals = n; // Initialize with the maximum possible removals

    for (int i = 0; i &lt (1 &lt&lt n); ++i) {
        int removals = 0; // Count removals for current combination
        vector&lt;vector&lt;int&gt;&gt; selected;

        for (int j = 0; j &lt n; ++j) {
            if ((i &amp (1 &lt&lt j)) != 0) {
                selected.push_back(intervals[j]);
            }
        }

        // Check if selected intervals are non-overlapping
        bool nonOverlapping = true;
        for (int j = 0; j &lt selected.size(); ++j) {
            for (int k = j + 1; k &lt selected.size(); ++k) {
                if (max(selected[j][0], selected[k][0]) &lt min(selected[j][1], selected[k][1])) {
                    nonOverlapping = false;
                    break;
                }
            }
            if (!nonOverlapping) break;
        }

        if (nonOverlapping) {
            removals = n - selected.size();
            minRemovals = min(minRemovals, removals);
        }
    }

    return minRemovals;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n * 2^n) -  Iterating through all subsets (2^n) and checking for overlaps in O(n) time. | <b>Space Complexity:</b> O(n) -  For storing the selected intervals in each combination.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Greedy Approach - Sorting and Iteration</h5>
  <p>Sort the intervals based on their end times. Iterate through the sorted intervals. If an interval overlaps with the previously selected interval, remove it (increment the removal count).  Otherwise, update the previously selected interval to the current interval.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int eraseOverlapIntervals_optimized(vector&lt;vector&lt;int&gt;&gt;& intervals) {
    if (intervals.empty()) return 0;

    // Sort by end times
    sort(intervals.begin(), intervals.end(), [](const vector&lt;int&gt;& a, const vector&lt;int&gt;& b) {
        return a[1] &lt b[1];
    });

    int removals = 0;
    int prevEnd = intervals[0][1];

    for (int i = 1; i &lt intervals.size(); ++i) {
        if (intervals[i][0] &lt prevEnd) {
            removals++;
        } else {
            prevEnd = intervals[i][1];
        }
    }

    return removals;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log n) - Sorting takes O(n log n) time, and the iteration takes O(n) time. | <b>Space Complexity:</b> O(1) - Constant extra space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,2],[2,3],[3,4],[1,3],[4,5]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The interval [1,3] can be removed, so that the rest of the intervals are non-overlapping.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,2],[1,2],[1,2]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">You need to remove two [1,2] to make the rest of the intervals non-overlapping.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,2],[2,3]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">All intervals are non-overlapping.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The greedy approach works because by sorting by end times, we prioritize intervals that finish early, which maximizes the chances of fitting more non-overlapping intervals. 
2. Edge case: Empty input array - should return 0.
3.  Handle cases with intervals having the same end time by sorting by start time if required (although in this problem's context, any tie-breaking method after sorting by end time will yield the correct result).</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/minimum-deletion-cost-to-avoid-repeating-letters/>Minimum Deletion Cost to Avoid Repeating Letters</a> <span style="font-size:14px; color:#888;">Easy/Medium</span></h3>
  <p>Given a string `s` and an array of integers `cost` where `cost[i]` is the cost of deleting the character `s[i]`. Return the minimum cost to delete characters so that every letter in `s` is unique.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach would involve generating all possible subsequences of the string `s`. For each subsequence, we would check if it has repeating characters. If it doesn't, we calculate the deletion cost (sum of costs of characters NOT in the subsequence).  We would then choose the minimum deletion cost among all valid subsequences. This is highly inefficient.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// This approach is highly inefficient and not practical for the given constraints.
// It is included only for conceptual understanding.

int minDeletionCostBruteForce(string s, vector&lt;int&gt;& cost) {
    int n = s.length();
    int minCost = INT_MAX;

    for (int i = 0; i &lt; (1 &lt;&lt; n); ++i) {
        string subsequence = "";
        int deletionCost = 0;

        for (int j = 0; j &lt; n; ++j) {
            if ((i & (1 &lt;&lt; j)) != 0) {
                subsequence += s[j];
            } else {
                deletionCost += cost[j];
            }
        }

        bool isValid = true;
        unordered_set&lt;char&gt; seen;
        for (char c : subsequence) {
            if (seen.count(c)) {
                isValid = false;
                break;
            }
            seen.insert(c);
        }

        if (isValid) {
            minCost = min(minCost, deletionCost);
        }
    }

    return (minCost == INT_MAX) ? 0 : minCost;
}
</code></pre>
  <p><b>Time Complexity:</b> O(2^N * N), where N is the length of the string. Generating all subsequences takes O(2^N) time, and checking each subsequence takes O(N) time. | <b>Space Complexity:</b> O(N) in the worst case, for storing the subsequence and the hash set.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Greedy Approach</h5>
  <p>Iterate through the string. For each group of repeating characters, calculate the deletion cost. The strategy is to keep the character with the highest cost in each repeating sequence and delete the rest. We sort costs for repeating characters to efficiently find minimum deletion costs.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int minDeletionCostGreedy(string s, vector&lt;int&gt;& cost) {
    int n = s.length();
    int totalCost = 0;

    for (int i = 0; i &lt; n;) {
        int j = i;
        while (j &lt; n &amp;&amp; s[j] == s[i]) {
            j++;
        }

        if (j - i &gt; 1) {
            vector&lt;int&gt; subCosts;
            for (int k = i; k &lt; j; k++) {
                subCosts.push_back(cost[k]);
            }
            sort(subCosts.begin(), subCosts.end());
            for (int k = 0; k &lt; subCosts.size() - 1; k++) {
                totalCost += subCosts[k];
            }
        }
        i = j;
    }
    return totalCost;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N log K), where N is the length of the string and K is the maximum number of consecutive repeating characters. Sorting the costs within each repeating sequence takes O(K log K) time, which is, in worst case scenarios O(N log N), while traversing the string is O(N). | <b>Space Complexity:</b> O(K) for storing the costs of repeating characters, in worst case O(N).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "abaac", cost = [1,2,3,4,5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Delete the first 'a' (cost 1) and the second 'a' (cost 3) to get s = "bc".</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "abc", cost = [1,2,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">All characters are unique.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "aabaa", cost = [1,2,3,4,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Delete the first 'a' (cost 1) and the last 'a' (cost 1).</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "aaaa", cost = [1,2,3,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Delete the first three 'a's</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The greedy approach is optimal. Key idea: For any repeating group of characters, removing all but the one with the maximum cost is the best strategy. Handle edge cases: empty string, or strings with no repeating characters.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/minimum-sum-two-numbers-formed-digits-array-2/>Minimum sum of two numbers formed from digits of an array</a> <span style="font-size:14px; color:#888;">Easy/Medium</span></h3>
  <p>Given an array of digits (0-9), find the minimum sum of two numbers that can be formed using all the digits in the array. Each digit can be used only once.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Generate all possible permutations of the digits and form two numbers for each permutation. Calculate the sum of the two numbers, and find the minimum sum among all permutations. This involves generating all permutations, forming the two numbers and comparing their sums. This approach is highly inefficient.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

long long formNumber(vector&lt;int&gt; &amp;arr) {
    long long num = 0;
    for (int digit : arr) {
        num = num * 10 + digit;
    }
    return num;
}

long long minSumBruteForce(vector&lt;int&gt; arr) {
    sort(arr.begin(), arr.end());
    long long minSum = LLONG_MAX;

    do {
        vector&lt;int&gt; num1_digits;
        vector&lt;int&gt; num2_digits;
        for(int i = 0; i &lt; arr.size(); ++i) {
            if(i % 2 == 0) {
                num1_digits.push_back(arr[i]);
            } else {
                num2_digits.push_back(arr[i]);
            }
        }

        long long num1 = formNumber(num1_digits);
        long long num2 = formNumber(num2_digits);

        minSum = min(minSum, num1 + num2);
    } while (next_permutation(arr.begin(), arr.end()));

    return minSum;
}

// int main() {
//     vector&lt;int&gt; arr = {6, 8, 4, 5, 2, 3};
//     cout &lt;&lt; "Minimum sum is " &lt;&lt; minSumBruteForce(arr) &lt;&lt; endl;
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(n! * n), where n is the number of digits. O(n!) for generating permutations and O(n) for forming the numbers. | <b>Space Complexity:</b> O(n) for storing the permutations and temporary arrays.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Approach: Sorting and Forming Numbers</h5>
  <p>Sort the array of digits in ascending order.  Then, create two numbers.  The first number is formed by concatenating digits at even indices and the second number by concatenating digits at odd indices. This approach places smaller digits in higher-value places, minimizing the sum.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

long long minSumOptimized(vector&lt;int&gt; arr) {
    sort(arr.begin(), arr.end());
    long long num1 = 0, num2 = 0;
    for (int i = 0; i &lt; arr.size(); ++i) {
        if (i % 2 == 0) {
            num1 = num1 * 10 + arr[i];
        } else {
            num2 = num2 * 10 + arr[i];
        }
    }
    return num1 + num2;
}

// int main() {
//     vector&lt;int&gt; arr = {6, 8, 4, 5, 2, 3};
//     cout &lt;&lt; "Minimum sum is " &lt;&lt; minSumOptimized(arr) &lt;&lt; endl;
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(n log n) for sorting, where n is the number of digits. O(n) to form the numbers. | <b>Space Complexity:</b> O(1) as it uses constant extra space.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr = {6, 8, 4, 5, 2, 3}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">604</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Sorted array: {2, 3, 4, 5, 6, 8}.  Number 1: 246. Number 2: 358. Sum: 246 + 358 = 604</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr = {5, 3, 0, 7, 4}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">82</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Sorted array: {0, 3, 4, 5, 7}. Number 1: 047, Number 2: 35. Sum: 47 + 35 = 82</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr = {1,2,3,4}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">53</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Sorted: {1,2,3,4}. Number1: 13. Number2: 24. Sum = 13+24 = 37</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to the optimized approach is to ensure the smaller digits occupy higher place values in at least one of the numbers. Sorting the digits allows for this, and alternating digit selection achieves it efficiently. Edge cases: array size, zeros in the array, all similar digits.</p>
</div>
<hr style="margin: 40px 0;">
<h2>Backtracking</h2>
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/combination-sum-ii/>Combination Sum II</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.

Each number in candidates may only be used once in the combination.

Note: The solution set must not contain duplicate combinations.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Generate all possible subsets of the candidates. For each subset, check if the sum equals the target. If it does and the subset is unique (i.e., not already present in the result), add it to the result.  This approach uses recursion to explore all combinations and avoid duplicates using a set.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) {
        vector&lt;vector&lt;int&gt;&gt; result;
        set&lt;vector&lt;int&gt;&gt; uniqueResults; // Use a set to store unique combinations
        vector&lt;int&gt; currentCombination;
        sort(candidates.begin(), candidates.end()); // Sort to handle duplicates
        findCombinations(candidates, target, 0, currentCombination, uniqueResults);
        for (const auto& combination : uniqueResults) {
            result.push_back(combination);
        }
        return result;
    }

private:
    void findCombinations(vector&lt;int&gt;&amp; candidates, int target, int start, vector&lt;int&gt;&amp; currentCombination, set&lt;vector&lt;int&gt;&gt;&amp; uniqueResults) {
        if (target == 0) {
            uniqueResults.insert(currentCombination);
            return;
        }

        if (target &lt; 0) {
            return;
        }

        for (int i = start; i &lt; candidates.size(); i++) {
            currentCombination.push_back(candidates[i]);
            findCombinations(candidates, target - candidates[i], i + 1, currentCombination, uniqueResults);
            currentCombination.pop_back(); // Backtrack: remove the last element to explore other possibilities
            // Skip duplicate elements
        }
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(2^N * K) where N is the number of candidates, and K is the average length of the combination. In the worst case, we explore all subsets (2^N). Sorting the candidates takes O(N log N). The insertion into the set takes O(K log R), where R is the number of unique combinations found. However, as the maximum number of combinations is 2^N, we can approximate it as O(2^N * K). | <b>Space Complexity:</b> O(N + K) - where N is the depth of the recursion and K is the space used for storing the current combination. In the worst case, all elements are added to the combination, so the space is O(N). Also, O(U) for the set of unique combinations, where U can be up to 2^N.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Backtracking with Pruning and Sorting</h5>
  <p>Sort the input array. Use backtracking to explore combinations. To avoid duplicates, skip numbers that are the same as the previous number at each level of recursion. This avoids generating the same combinations again. Also, use pruning, returning early if the target becomes negative to avoid exploring invalid paths.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) {
        vector&lt;vector&lt;int&gt;&gt; result;
        vector&lt;int&gt; currentCombination;
        sort(candidates.begin(), candidates.end()); // Sort the candidates to handle duplicates
        backtrack(candidates, target, 0, currentCombination, result);
        return result;
    }

private:
    void backtrack(vector&lt;int&gt;&amp; candidates, int target, int start, vector&lt;int&gt;&amp; currentCombination, vector&lt;vector&lt;int&gt;&gt;&amp; result) {
        if (target == 0) {
            result.push_back(currentCombination);
            return;
        }

        if (target &lt; 0) {
            return;
        }

        for (int i = start; i &lt; candidates.size(); i++) {
            // Skip duplicate elements
            if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) {
                continue;
            }
            currentCombination.push_back(candidates[i]);
            backtrack(candidates, target - candidates[i], i + 1, currentCombination, result);
            currentCombination.pop_back(); // Backtrack: remove the last element
        }
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(2^N) in the worst-case scenario where N is the number of candidates. The sorting step takes O(N log N). The backtracking algorithm itself explores a tree where at each node we can choose or not choose a number. Although we have pruning and skipping duplicates, the worst-case scenario leads to an exponential time complexity. It's less than brute force because of skipping duplicate numbers. | <b>Space Complexity:</b> O(N) due to the recursion depth and the space used for the current combination. In the worst case, the recursion depth could be N (all elements are added to the current combination).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">candidates = [10,1,2,7,6,1,5], target = 8</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,1,6],[1,2,5],[1,7],[2,6]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The numbers are sorted, duplicates are skipped during backtracking. Combinations that add up to the target are found.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">candidates = [2,5,2,1,2], target = 5</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,2,2],[5]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Illustrates handling of duplicate numbers and forming valid combinations.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">candidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1], target = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Illustrates the use of duplicates and target to find valid combinations.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. **Sorting:** Sorting the input array is crucial for the optimized solution to handle duplicates efficiently.
2. **Skipping Duplicates:** In the backtracking approach, the `if (i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) continue;` line is the key to avoiding duplicate combinations. This check ensures that we only consider a number if it's different from the previous number at the same level of recursion.
3. **Backtracking:** The core of the solution is the backtracking algorithm, which explores all possible combinations.  Backtracking involves building up potential solutions incrementally and abandoning a path (backtracking) as soon as it becomes clear that it cannot lead to a valid solution. 
4. **Pruning:** The condition `if (target &lt; 0)` acts as pruning. It short-circuits the exploration of paths that will lead to target sums that are too large, improving efficiency.
5. **Edge Cases:**  An important edge case is when the input `candidates` array contains all the same values, and the `target` is a multiple of that value.  The code correctly handles these situations.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/subset-sum-problem2014/1>Subset Sum Problem</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a set of non-negative integers, and a value sum, determine if there is a subset of the given set with sum equal to given sum.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves generating all possible subsets of the given set and checking if any of them sum up to the target sum. This can be done using recursion, where at each step, we have two choices: either include the current element in the subset or exclude it.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool isSubsetSumRecursive(vector&lt;int&gt;&amp; arr, int n, int sum) {
    // Base cases
    if (sum == 0) return true;  // If sum becomes 0, a subset is found
    if (n == 0) return false; // If no elements and sum > 0, no subset exists

    // If the current element is greater than the sum, exclude it
    if (arr[n - 1] &gt; sum)
        return isSubsetSumRecursive(arr, n - 1, sum);

    // Either include or exclude the current element
    return isSubsetSumRecursive(arr, n - 1, sum - arr[n - 1]) || isSubsetSumRecursive(arr, n - 1, sum);
}

bool isSubsetSum(vector&lt;int&gt;&amp; arr, int n, int sum) {
    return isSubsetSumRecursive(arr, n, sum);
}
</code></pre>
  <p><b>Time Complexity:</b> O(2^n), where n is the number of elements in the array. This is because, in the worst case, we explore all possible subsets. | <b>Space Complexity:</b> O(n) due to the recursion call stack.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming (Tabulation)</h5>
  <p>This approach utilizes dynamic programming to efficiently solve the subset sum problem. We create a 2D boolean table `dp` where `dp[i][j]` indicates whether a subset with sum `j` can be formed using the first `i` elements of the input array. The table is filled iteratively using the following logic:

1.  `dp[i][0]` is `true` for all `i` (an empty subset always sums to 0).
2.  If `arr[i-1] &gt; j`, then `dp[i][j] = dp[i-1][j]` (exclude the current element).
3.  Otherwise, `dp[i][j] = dp[i-1][j] || dp[i-1][j - arr[i-1]]` (either exclude or include the current element).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool isSubsetSum(vector&lt;int&gt;&amp; arr, int n, int sum) {
    // dp[i][j] will be true if a subset of arr[0..i-1] can sum to j
    vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(sum + 1, false));

    // Initialization
    for (int i = 0; i &lt;= n; i++)
        dp[i][0] = true;  // Empty subset sums to 0
    for (int j = 1; j &lt;= sum; j++)
        dp[0][j] = false; // No subset can sum to j with 0 elements

    // Fill the dp table
    for (int i = 1; i &lt;= n; i++) {
        for (int j = 1; j &lt;= sum; j++) {
            if (arr[i - 1] &gt; j)
                dp[i][j] = dp[i - 1][j]; // Exclude the current element
            else
                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - arr[i - 1]]; // Include or exclude
        }
    }

    return dp[n][sum]; // Result is stored at dp[n][sum]
}
</code></pre>
  <p><b>Time Complexity:</b> O(n * sum), where n is the number of elements and sum is the target sum. | <b>Space Complexity:</b> O(n * sum) due to the dp table.</p>
  <h5>‚û§ Dynamic Programming (Space-Optimized)</h5>
  <p>This approach is a space-optimized version of the tabulation method. We can reduce the space complexity to O(sum) by using only one 1D array `dp`.  We iterate through the array elements and for each element, we update `dp` from right to left to avoid using already updated values in the current iteration.  The core logic remains the same as in the tabulation method.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool isSubsetSum(vector&lt;int&gt;&amp; arr, int n, int sum) {
    vector&lt;bool&gt; dp(sum + 1, false);
    dp[0] = true;  // Base case: Empty subset sums to 0

    for (int i = 0; i &lt; n; i++) {
        for (int j = sum; j &gt;= arr[i]; j--) {
            dp[j] = dp[j] || dp[j - arr[i]]; // Include or exclude the current element
        }
    }
    return dp[sum];
}
</code></pre>
  <p><b>Time Complexity:</b> O(n * sum) | <b>Space Complexity:</b> O(sum)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr = {3, 34, 4, 12, 5, 2}, sum = 9</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Subset {4, 5} sums to 9.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr = {3, 34, 4, 12, 5, 2}, sum = 30</td>
        <td style="border: 1px solid #ccc; padding: 6px;">false</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No subset sums to 30.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr = {1, 5, 11, 5}, sum = 11</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Subset {1, 5, 5} sums to 11.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">arr = {1, 2, 3, 4, 5}, sum = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">true</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Empty subset sums to 0.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The sum can be large, so consider the potential for integer overflow when dealing with sums of array elements.
2.  The space-optimized dynamic programming approach is generally preferred due to its reduced space complexity.
3.  The problem can be modified to find the number of subsets with the given sum.  The code will then need to be adapted to store counts rather than boolean values.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/combinations/>Combinations</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n]. You can return the answer in any order.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Generate all possible subsets of numbers from 1 to n. For each subset, check if its size is equal to k. If it is, add it to the result. This involves generating all possible subsets, which can be done recursively.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

void generateCombinations(int n, int k, int start, vector&lt;int&gt; &amp;currentCombination, vector&lt;vector&lt;int&gt;&gt; &amp;result) {
    if (currentCombination.size() == k) {
        result.push_back(currentCombination);
        return;
    }

    for (int i = start; i &lt;= n; ++i) {
        currentCombination.push_back(i);
        generateCombinations(n, k, i + 1, currentCombination, result);
        currentCombination.pop_back(); // Backtrack
    }
}

vector&lt;vector&lt;int&gt;&gt; combineBruteForce(int n, int k) {
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; currentCombination;
    generateCombinations(n, k, 1, currentCombination, result);
    return result;
}

// int main() {
//     int n = 4, k = 2;
//     vector&lt;vector&lt;int&gt;&gt; combinations = combineBruteForce(n, k);
//     for (const auto &amp;combination : combinations) {
//         for (int num : combination) {
//             cout &lt;&lt; num &lt;&lt; " ";
//         }
//         cout &lt;&lt; endl;
//     }
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(nCk), where nCk is 'n choose k', which is the number of combinations.  Each combination takes O(k) time to store. Therefore approximately O(k * nCk) | <b>Space Complexity:</b> O(nCk) to store the result in worst-case, plus O(k) for recursive call stack depth.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Backtracking (Optimized)</h5>
  <p>Backtracking is an algorithmic technique for solving problems recursively by trying to build up a solution incrementally, one piece at a time, removing those solutions that fail to satisfy the constraints of the problem at any point in time. This is a more efficient way of generating combinations compared to brute force, and avoids generating unnecessary subsets.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

void backtrack(int n, int k, int start, vector&lt;int&gt; &amp;current, vector&lt;vector&lt;int&gt;&gt; &amp;result) {
    if (current.size() == k) {
        result.push_back(current);
        return;
    }

    for (int i = start; i &lt;= n; ++i) {
        current.push_back(i);
        backtrack(n, k, i + 1, current, result);
        current.pop_back(); // Backtrack
    }
}

vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) {
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; current;
    backtrack(n, k, 1, current, result);
    return result;
}

// int main() {
//     int n = 4, k = 2;
//     vector&lt;vector&lt;int&gt;&gt; combinations = combine(n, k);
//     for (const auto &amp;combination : combinations) {
//         for (int num : combination) {
//             cout &lt;&lt; num &lt;&lt; " ";
//         }
//         cout &lt;&lt; endl;
//     }
//     return 0;
// }
</code></pre>
  <p><b>Time Complexity:</b> O(nCk) - The time complexity is dominated by the number of combinations that need to be generated, which is nCk. Each combination requires O(k) operations for constructing and storing. | <b>Space Complexity:</b> O(nCk) to store the combinations in worst case. Plus O(k) for recursion depth (at most k elements in the current combination vector).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 4, k = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[2,4],[3,4],[2,3],[1,2],[1,3],[1,4]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">All possible combinations of 2 numbers from the range [1, 4].</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 1, k = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Only one number and selecting one element results in a single combination.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The problem is a standard combinatorial problem. The key is to use backtracking efficiently to explore the solution space. Consider edge cases where k equals 0 or k is equal to n, these cases require slightly different handling but doesn't change algorithmic approach significantly.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/subsets-ii/>Subsets II</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an integer array `nums` that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Generate all possible subsets by iterating through each element and either including or excluding it. To avoid duplicates, sort the input array and skip duplicate elements when making choices (include or exclude).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt;&gt; result;
        vector&lt;int&gt; current;
        sort(nums.begin(), nums.end()); // Sort to handle duplicates
        generateSubsets(nums, 0, current, result);
        return result;
    }

    void generateSubsets(vector&lt;int&gt;&amp; nums, int index, vector&lt;int&gt;&amp; current, vector&lt;vector&lt;int&gt;&gt;&amp; result) {
        result.push_back(current);

        for (int i = index; i &lt; nums.size(); ++i) {
            // Skip duplicates
            if (i &gt; index &amp;&amp; nums[i] == nums[i - 1]) {
                continue;
            }
            current.push_back(nums[i]);
            generateSubsets(nums, i + 1, current, result);
            current.pop_back(); // Backtrack
        }
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N * 2^N) where N is the number of elements in nums.  We generate all 2^N subsets, and for each subset, it takes O(N) time to copy into result. In a more rigorous analysis, we copy elements within generateSubsets and push_back and pop_back for each element, with a theoretical upper bound of O(N * 2^N) | <b>Space Complexity:</b> O(N) for the recursion depth in the worst case, and potentially O(N * 2^N) to store all the subsets (in the worst case if all elements are unique).  The `current` vector will take O(N) space at maximum</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Backtracking with Skipping Duplicates</h5>
  <p>This approach uses backtracking to explore all possible subsets.  It sorts the input array first. When encountering a duplicate element, it skips including that element in the current subset, to avoid generating duplicate subsets. The base case is reached when the index is beyond the size of the input.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt;&gt; result;
        vector&lt;int&gt; current;
        sort(nums.begin(), nums.end());
        generateSubsets(nums, 0, current, result);
        return result;
    }

    void generateSubsets(vector&lt;int&gt;&amp; nums, int index, vector&lt;int&gt;&amp; current, vector&lt;vector&lt;int&gt;&gt;&amp; result) {
        result.push_back(current);

        for (int i = index; i &lt; nums.size(); ++i) {
            if (i &gt; index &amp;&amp; nums[i] == nums[i - 1]) {
                continue; // Skip duplicates
            }
            current.push_back(nums[i]);
            generateSubsets(nums, i + 1, current, result);
            current.pop_back(); // Backtrack
        }
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(N * 2^N), where N is the number of elements in nums.  Similar to the brute force, the backtracking explores 2^N possibilities and the cost is amortized by the duplicate handling in the sorted array. In a formal sense, the algorithm touches each element in the worst case for all subsets. | <b>Space Complexity:</b> O(N) for the recursion stack and, in the worst case, O(N * 2^N) to store the subsets. The `current` vector stores at most N elements.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,2,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[],[1],[1,2],[1,2,2],[2],[2,2]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The function should return a list of subsets, where no duplicate subsets exist.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[],[0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The function returns the power set with the element '0' or without it</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [4,4,4,1,4]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The output avoids duplicates as the array is sorted and duplicates are skipped.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The key to avoiding duplicate subsets is to sort the input array and skip duplicate elements during the subset generation. 
2.  The backtracking approach naturally handles this. 
3.  Ensure to handle the case where the input array can be empty. An empty input array should return a result containing only the empty set. 
4. The sorting is essential, and the skipping logic `if (i &gt; index &amp;&amp; nums[i] == nums[i - 1])` is crucial to prevent duplicates.  This comparison ensures that when an element is the same as its preceding element and is not the first occurrence in the subset, then it is skipped.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://practice.geeksforgeeks.org/problems/m-coloring-problem-1587115620/1>M-Coloring Problem</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an undirected graph and an integer M. The task is to determine if the graph can be colored with at most M colors such that no two adjacent vertices of the graph are colored with the same color.  In other words, we have to find if it is possible to color the graph using M colors or not.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach tries all possible colorings of the graph. For each vertex, it tries all M colors. This leads to a large number of possibilities, making it inefficient.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool isSafe(int v, int graph[][101], int color[], int c, int V) {
    for (int i = 0; i &lt V; i++) {
        if (graph[v][i] &amp;&amp; c == color[i])
            return false;
    }
    return true;
}

bool graphColoringUtil(int m, int V, int graph[][101], int color[], int v) {
    if (v == V)
        return true;

    for (int c = 1; c &lt= m; c++) {
        if (isSafe(v, graph, color, c, V)) {
            color[v] = c;
            if (graphColoringUtil(m, V, graph, color, v + 1))
                return true;
            color[v] = 0; // Backtrack
        }
    }
    return false;
}

bool graphColoring(int m, int V, int graph[][101]) {
    int color[V];
    for (int i = 0; i &lt V; i++)
        color[i] = 0;

    if (!graphColoringUtil(m, V, graph, color, 0))
        return false;

    return true;
}
</code></pre>
  <p><b>Time Complexity:</b> O(M^V), where V is the number of vertices and M is the number of colors. In the worst case, we try M colors for each of the V vertices. | <b>Space Complexity:</b> O(V), for the color array and the recursion call stack in the worst case.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Backtracking</h5>
  <p>The backtracking approach explores the solution space by making choices and undoing them if they lead to a dead end. For each vertex, we try to assign a color from 1 to M.  If a color is safe (i.e., the current vertex is not adjacent to any vertex with the same color), we assign it. If we reach the end of the vertices successfully, we return true; otherwise, we backtrack and try another color. If no color works for a vertex, we backtrack to the previous vertex.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

bool isSafe(int v, int graph[][101], int color[], int c, int V) {
    for (int i = 0; i &lt V; i++) {
        if (graph[v][i] &amp;&amp; c == color[i])
            return false;
    }
    return true;
}

bool graphColoringUtil(int m, int V, int graph[][101], int color[], int v) {
    if (v == V)
        return true;

    for (int c = 1; c &lt= m; c++) {
        if (isSafe(v, graph, color, c, V)) {
            color[v] = c;
            if (graphColoringUtil(m, V, graph, color, v + 1))
                return true;
            color[v] = 0; // Backtrack
        }
    }
    return false;
}

bool graphColoring(int m, int V, int graph[][101]) {
    int color[V];
    for (int i = 0; i &lt V; i++)
        color[i] = 0;

    if (!graphColoringUtil(m, V, graph, color, 0))
        return false;

    return true;
}
</code></pre>
  <p><b>Time Complexity:</b> O(M^V), where V is the number of vertices and M is the number of colors. In the worst-case, we might have to explore all possible color combinations. | <b>Space Complexity:</b> O(V), for the color array and the recursion call stack.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">V = 4, M = 3, graph = [[0, 1, 1, 1], [1, 0, 1, 0], [1, 1, 0, 1], [1, 0, 1, 0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Yes</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The graph can be colored with 3 colors.  For example, color[0] = 1, color[1] = 2, color[2] = 3, color[3] = 2.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">V = 3, M = 2, graph = [[0, 1, 1], [1, 0, 1], [1, 1, 0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The graph cannot be colored with 2 colors. The graph is a complete graph with 3 vertices.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The `isSafe()` function checks if assigning a color to a vertex is valid (i.e., no adjacent vertex has the same color).
2.  The `graphColoringUtil()` function uses backtracking to explore the solution space.
3.  The solution assumes that the graph is represented using an adjacency matrix.  The input adjacency matrix `graph` will indicate the connections between the graph nodes. 
4.  The colors are represented as integers starting from 1.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/beautiful-arrangement/>Beautiful Arrangement</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given an integer n, return the number of beautiful arrangements. A beautiful arrangement is an array of length n such that for every i (1 &lt;= i &lt;= n), either arr[i] is divisible by i, or i is divisible by arr[i].</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Generate all permutations of numbers from 1 to n and check each permutation to see if it satisfies the beautiful arrangement condition. This involves generating all possible orderings and then validating each.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

class Solution {
public:
    int countArrangement(int n) {
        vector&lt;int&gt; nums(n);
        for (int i = 0; i &lt; n; ++i) {
            nums[i] = i + 1;
        }
        
        int count = 0;
        do {
            bool beautiful = true;
            for (int i = 0; i &lt; n; ++i) {
                if ((nums[i] % (i + 1) != 0) &amp;&amp; ((i + 1) % nums[i] != 0)) {
                    beautiful = false;
                    break;
                }
            }
            if (beautiful) {
                count++;
            }
        } while (next_permutation(nums.begin(), nums.end()));
        
        return count;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n! * n) - Generating all permutations takes O(n!) time, and checking each permutation takes O(n) time. | <b>Space Complexity:</b> O(n) - for storing the numbers and recursive call stack in permutation generation.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Backtracking with Optimization</h5>
  <p>Use backtracking to explore possible arrangements.  At each step, try placing a number at a particular index.  If placing a number violates the condition, prune that branch of the search.  This avoids generating and checking all permutations.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class Solution {
public:
    int countArrangement(int n) {
        vector&lt;bool&gt; visited(n + 1, false);
        int count = 0;
        backtrack(n, 1, visited, count);
        return count;
    }

private:
    void backtrack(int n, int index, vector&lt;bool&gt;&amp; visited, int&amp; count) {
        if (index &gt; n) {
            count++;
            return;
        }

        for (int i = 1; i &lt;= n; ++i) {
            if (!visited[i] &amp;&amp; (i % index == 0 || index % i == 0)) {
                visited[i] = true;
                backtrack(n, index + 1, visited, count);
                visited[i] = false; // Backtrack: unmark the number
            }
        }
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(K) where K is the number of valid arrangements.  In the worst-case scenario, which is better than O(n!) in the brute force approach. It's much smaller, but difficult to pinpoint precisely. | <b>Space Complexity:</b> O(n) - for the visited array and the recursion call stack (at most n deep).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The possible beautiful arrangements are [1, 2] and [2, 1].
1.  arr[1] == 1, i == 1: 1 % 1 == 0 (valid)
    arr[2] == 2, i == 2: 2 % 2 == 0 (valid)

2.  arr[1] == 2, i == 1: 2 % 1 == 0 (valid)
    arr[2] == 1, i == 2: 2 % 1 == 0 (valid)</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The only possible beautiful arrangement is [1]. arr[1] == 1, i == 1: 1 % 1 == 0 (valid)</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Valid arrangements are [1,2,3], [1,3,2], [2,1,3], [3,1,2].</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to solving this problem efficiently is to use backtracking to avoid generating and checking all permutations. The backtracking approach prunes branches of the search tree when the condition for a beautiful arrangement is violated.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/palindrome-partitioning/>Palindrome Partitioning</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a string `s`, partition `s` such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of `s`.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Generate all possible partitions of the string and check if each substring within a partition is a palindrome. This involves checking all possible split points.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Function to check if a string is a palindrome
bool isPalindrome(const string& s, int start, int end) {
    while (start &lt end) {
        if (s[start] != s[end]) {
            return false;
        }
        start++;
        end--;
    }
    return true;
}

// Brute force function to generate palindrome partitions
vector&lt;vector&lt;string&gt;&gt; partition(string s) {
    vector&lt;vector&lt;string&gt;&gt; result;
    vector&lt;string&gt; currentPartition;
    int n = s.length();

    function&lt;void(int)&gt; solve = [&](int index) {
        if (index == n) {
            result.push_back(currentPartition);
            return;
        }

        for (int i = index; i &lt n; ++i) {
            if (isPalindrome(s, index, i)) {
                currentPartition.push_back(s.substr(index, i - index + 1));
                solve(i + 1);
                currentPartition.pop_back(); // Backtrack
            }
        }
    };

    solve(0);
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(2^n * n), where n is the length of the string.  In the worst-case, we explore all possible partitions (2^n). For each partition, we spend O(n) time to check if a substring is a palindrome. | <b>Space Complexity:</b> O(n) due to the recursion depth and storing the current partition in the worst case.  Also O(n) space for the substring extraction in the isPalindrome function. This is for a single partition. Total space is proportional to the height of the recursion tree, that is, O(n) + the current partition.  This is bounded by O(n). The number of partitions can be exponential. Therefore the extra space is not counted.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming with Backtracking</h5>
  <p>1. **Precompute Palindromes:** Use dynamic programming to create a table `dp` where `dp[i][j]` is `true` if the substring `s[i...j]` is a palindrome.  This takes O(n^2) time and space.
2. **Backtracking:** Use backtracking to generate all partitions. Before each recursive call check whether it's a valid palindrome using the precomputed `dp` table.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Function to generate palindrome partitions using dynamic programming and backtracking
vector&lt;vector&lt;string&gt;&gt; partition(string s) {
    int n = s.length();
    vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(n, false));
    vector&lt;vector&lt;string&gt;&gt; result;
    vector&lt;string&gt; currentPartition;

    // Precompute palindromes
    for (int i = n - 1; i &gt;= 0; i--) {
        for (int j = i; j &lt n; j++) {
            if (s[i] == s[j] &amp;&amp; (j - i &lt 2 || dp[i + 1][j - 1])) {
                dp[i][j] = true;
            }
        }
    }

    function&lt;void(int)&gt; solve = [&](int index) {
        if (index == n) {
            result.push_back(currentPartition);
            return;
        }

        for (int i = index; i &lt n; i++) {
            if (dp[index][i]) {
                currentPartition.push_back(s.substr(index, i - index + 1));
                solve(i + 1);
                currentPartition.pop_back();
            }
        }
    };

    solve(0);
    return result;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) for precomputing palindromes + O(2^n) for backtracking in the worst case (similar to brute force but with optimized palindrome checks).  The palindrome check is now O(1). Hence the time complexity is dominated by the backtracking part, O(2^n).  This means generating the partitions is exponential, but checking the palindromes is now O(1) given the `dp` table. | <b>Space Complexity:</b> O(n^2) for the `dp` table + O(n) for the recursion depth (worst case) + O(n) for the current partition, so the extra space is O(n).</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "aab"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[["a","a","b"],["aa","b"]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The possible palindrome partitioning are ["a","a","b"] and ["aa","b"].</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "a"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[["a"]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The only palindrome partition is ["a"].</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">s = "aba"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[["a","b","a"],["aba"]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The possible partitions are ["a","b","a"] and ["aba"].</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to optimizing is to precompute palindrome checks. Backtracking is the natural way to explore all possible partitions. The precomputation of palindromes using DP reduces the cost of repeatedly checking if substrings are palindromes.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/permutations-ii/>Permutations II</a> <span style="font-size:14px; color:#888;">Medium</span></h3>
  <p>Given a collection of numbers, `nums`, that might contain duplicates, return all possible unique permutations in any order.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Generate all permutations and then filter out duplicates. This can be done using recursion or libraries to generate permutations, and then using a set to store unique permutations.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt;&gt; result;
        set&lt;vector&lt;int&gt;&gt; uniquePermutations; // Use a set to store unique permutations
        sort(nums.begin(), nums.end());
        do {
            uniquePermutations.insert(nums);
        } while (next_permutation(nums.begin(), nums.end()));

        for (const auto& perm : uniquePermutations) {
            result.push_back(perm);
        }

        return result;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n! * n) where n is the number of elements in nums.  Generating permutations takes O(n!) and checking and inserting into the set takes O(n) time for each permutation, and potentially O(n! * n) total for insertion into set (worst case). | <b>Space Complexity:</b> O(n!) to store all permutations in the set, plus O(n) for temporary storage of each permutation.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Backtracking with pruning</h5>
  <p>Use backtracking to generate permutations. To avoid duplicates, sort the input array first. During backtracking, if the current element is the same as the previous one, and the previous one has not been used, skip the current element to avoid generating duplicate permutations. This effectively prunes the search space.</p>
  <pre><code class="language-python">#include &lt;bits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt;&gt; result;
        vector&lt;int&gt; currentPermutation;
        vector&lt;bool&gt; used(nums.size(), false);
        sort(nums.begin(), nums.end()); // Sort to handle duplicates
        backtrack(nums, result, currentPermutation, used);
        return result;
    }

    void backtrack(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt;&amp; currentPermutation, vector&lt;bool&gt;&amp; used) {
        if (currentPermutation.size() == nums.size()) {
            result.push_back(currentPermutation);
            return;
        }

        for (int i = 0; i &lt; nums.size(); ++i) {
            if (used[i]) continue; // Skip if the number is already used
            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) continue; // Prune duplicates

            used[i] = true;
            currentPermutation.push_back(nums[i]);
            backtrack(nums, result, currentPermutation, used);
            currentPermutation.pop_back();
            used[i] = false;
        }
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n!): In the worst case, backtracking explores all possible permutations. The pruning helps, but in the presence of many distinct numbers, it doesn't significantly reduce the overall time complexity. | <b>Space Complexity:</b> O(n) for the recursion depth (call stack) and O(n) for the `used` vector.  O(n) for storing the current permutation.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,1,2]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,1,2],[1,2,1],[2,1,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The output shows all the unique permutations of the input array, handling the duplicate '1'.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,2,3]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">All unique permutations of the input array.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1, 1, 1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,1,1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Only one unique permutation, even with all duplicates.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to solving this problem efficiently is to handle duplicate numbers correctly.  Sorting the input and pruning duplicate choices during the backtracking process is crucial for avoiding redundant calculations and ensuring that only unique permutations are generated.  Consider the case where there are multiple identical elements; the pruning step prevents re-generating the same permutations that only differ in the position of these identical elements.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/word-search-ii/>Word Search II</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given an m x n board of characters and a list of strings words, return all words on the board that are present in the list words. 

The words must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through each word in the words list. For each word, perform a Depth-First Search (DFS) on the board to see if the word can be found. This involves starting at each cell of the board and recursively exploring adjacent cells to match the word. If a word is found, add it to the result.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;& board, vector&lt;string&gt;& words) {
        vector&lt;string&gt; result;
        int m = board.size();
        int n = board[0].size();

        for (const string& word : words) {
            bool found = false;
            for (int i = 0; i &lt; m; ++i) {
                for (int j = 0; j &lt; n; ++j) {
                    if (board[i][j] == word[0] && dfs(board, i, j, word, 0)) {
                        result.push_back(word);
                        found = true;
                        break;
                    }
                }
                if (found) break;
            }
        }
        return result;
    }

    bool dfs(vector&lt;vector&lt;char&gt;&gt;& board, int row, int col, const string& word, int index) {
        if (index == word.length()) {
            return true;
        }
        if (row &lt; 0 || row &gt;= board.size() || col &lt; 0 || col &gt;= board[0].size() || board[row][col] != word[index]) {
            return false;
        }

        char originalChar = board[row][col];
        board[row][col] = '#'; // Mark as visited

        bool found = dfs(board, row + 1, col, word, index + 1) ||
                     dfs(board, row - 1, col, word, index + 1) ||
                     dfs(board, row, col + 1, word, index + 1) ||
                     dfs(board, row, col - 1, word, index + 1);

        board[row][col] = originalChar; // Backtrack
        return found;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(M * N * W * 4^L), where M and N are the dimensions of the board, W is the number of words, and L is the average length of the words. For each word (W), we might have to start a DFS (potentially up to M * N times), and the DFS has a time complexity of O(4^L) in the worst case (exploring all possible paths of length L) | <b>Space Complexity:</b> O(L), where L is the average length of the words. This is due to the recursion depth of the DFS. Also can be considered O(M*N) in worst case, to store the board marking for visited cells</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Trie and DFS</h5>
  <p>1. **Build a Trie:** Construct a Trie (prefix tree) from the given list of words. This allows for efficient prefix matching.
2. **DFS Traversal:** Iterate through each cell of the board. For each cell, perform a Depth-First Search (DFS) starting from that cell.
3. **Trie Traversal within DFS:** During the DFS, use the Trie to check if the current path forms a valid prefix of any word in the Trie. If it does, continue the DFS. If a word is found (a path reaches the end of a word in the Trie), add it to the result and prune that branch of DFS by removing that word's path in the Trie to avoid duplicate answers and improve performance.
4. **Backtracking and Pruning:** Use backtracking to explore different paths. Mark visited cells during DFS and unmark them when backtracking. When a path doesn't lead to a valid prefix or word, prune the branch early.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

struct TrieNode {
    TrieNode* children[26];
    string word;
    TrieNode() {
        for (int i = 0; i &lt; 26; ++i) {
            children[i] = nullptr;
        }
        word = "";
    }
};

class Solution {
public:
    vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;& board, vector&lt;string&gt;& words) {
        TrieNode* root = buildTrie(words);
        vector&lt;string&gt; result;
        int m = board.size();
        int n = board[0].size();

        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                dfs(board, i, j, root, result);
            }
        }
        return result;
    }

    void dfs(vector&lt;vector&lt;char&gt;&gt;& board, int row, int col, TrieNode* node, vector&lt;string&gt;&& result) {
        if (row &lt; 0 || row &gt;= board.size() || col &lt; 0 || col &gt;= board[0].size() || board[row][col] == '#') {
            return;
        }

        char c = board[row][col];
        if (node-&gt;children[c - 'a'] == nullptr) {
            return;
        }

        node = node-&gt;children[c - 'a'];
        if (!node-&gt;word.empty()) {
            result.push_back(node-&gt;word);
            node-&gt;word = "";  // Prune the word to avoid duplicates
        }

        board[row][col] = '#'; // Mark as visited
        dfs(board, row + 1, col, node, result);
        dfs(board, row - 1, col, node, result);
        dfs(board, row, col + 1, node, result);
        dfs(board, row, col - 1, node, result);
        board[row][col] = c; // Backtrack
    }

    TrieNode* buildTrie(vector&lt;string&gt;& words) {
        TrieNode* root = new TrieNode();
        for (const string& word : words) {
            TrieNode* node = root;
            for (char c : word) {
                if (node-&gt;children[c - 'a'] == nullptr) {
                    node-&gt;children[c - 'a'] = new TrieNode();
                }
                node = node-&gt;children[c - 'a'];
            }
            node-&gt;word = word;
        }
        return root;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(M * N * 4^L + K * L), where M and N are the dimensions of the board, L is the average length of words, and K is the number of words. Building the Trie takes O(K * L). The DFS is done at most M*N times. The DFS at a cell can take 4^L in worst case where L is the word length. However, due to early pruning by the Trie, the effective time complexity is much less in practice. The Trie lookup in each step in the DFS has a time complexity O(1) due to character array access. | <b>Space Complexity:</b> O(K * L), where K is the number of words and L is the average length of the words. This is the space required to store the Trie.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">["eat","oath"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The words "eat" and "oath" can be found on the board.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">board = [["a","b"],["c","d"]], words = ["abcb"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The word "abcb" cannot be found on the board.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">board = [["a","b"],["c","d"]], words = ["abcd"]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The word "abcd" cannot be found on the board. The same letter cell may not be used more than once in a word.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. **Trie Optimization:** The Trie data structure significantly improves the performance by allowing for efficient prefix matching. This dramatically reduces the number of DFS calls compared to the brute-force method.
2. **Backtracking:** Correctly implementing backtracking (marking and unmarking visited cells) is crucial to exploring different paths and preventing infinite loops.
3. **Pruning in DFS:** The Trie helps prune the DFS by checking if a path represents a valid prefix. If not, the search can terminate early, avoiding unnecessary exploration of branches.
4. **Duplicate Words:** The code ensures that duplicate words are not added to the result using pruning after finding a word, so that repeated words are not added in the solution.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/sudoku-solver/>Sudoku Solver</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given a 9x9 Sudoku board, write a program to solve the Sudoku puzzle. The board consists of digits 1-9 and the '.' character representing empty cells. The goal is to fill in the empty cells so that each row, column, and 3x3 subgrid contains all the digits from 1 to 9 without repetition.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Backtracking: Try all possible digits (1-9) for each empty cell. If a digit leads to a conflict (violates Sudoku rules), backtrack and try another digit. Continue until the board is solved or all possibilities are exhausted.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    bool isValid(vector&lt;vector&lt;char&gt;&gt;& board, int row, int col, char digit) {
        // Check row
        for (int i = 0; i &lt 9; i++) {
            if (board[row][i] == digit) {
                return false;
            }
        }
        // Check column
        for (int i = 0; i &lt 9; i++) {
            if (board[i][col] == digit) {
                return false;
            }
        }
        // Check 3x3 subgrid
        int subgridRowStart = (row / 3) * 3;
        int subgridColStart = (col / 3) * 3;
        for (int i = 0; i &lt 3; i++) {
            for (int j = 0; j &lt 3; j++) {
                if (board[subgridRowStart + i][subgridColStart + j] == digit) {
                    return false;
                }
            }
        }
        return true;
    }

    bool solveSudoku(vector&lt;vector&lt;char&gt;&gt;& board) {
        for (int row = 0; row &lt 9; row++) {
            for (int col = 0; col &lt 9; col++) {
                if (board[row][col] == '.') {
                    for (char digit = '1'; digit &lt= '9'; digit++) {
                        if (isValid(board, row, col, digit)) {
                            board[row][col] = digit;
                            if (solveSudoku(board)) {
                                return true;
                            }
                            else {
                                board[row][col] = '.'; // Backtrack
                            }
                        }
                    }
                    return false; // No digit works
                }
            }
        }
        return true; // Board solved
    }

    void solveSudokuWrapper(vector&lt;vector&lt;char&gt;&gt;& board) {
        solveSudoku(board);
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(9^(m)) where m is the number of empty cells. In the worst case, we try 9 digits for each empty cell. | <b>Space Complexity:</b> O(1) ignoring the space used by the call stack (recursion depth can be O(m) where m is the number of empty cells).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Backtracking with Optimization</h5>
  <p>Similar to the brute-force approach (backtracking), but includes optimizations like pre-calculating possible values for each cell and using more efficient data structures (e.g., bitsets) to check for conflicts. This often speeds up the checking process.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class Solution {
public:
    bool isValid(vector&lt;vector&lt;char&gt;&gt;& board, int row, int col, char digit) {
        for (int i = 0; i &lt 9; i++) {
            if (board[row][i] == digit) return false;
            if (board[i][col] == digit) return false;
            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == digit) return false;
        }
        return true;
    }

    bool solveSudoku(vector&lt;vector&lt;char&gt;&gt;& board) {
        for (int i = 0; i &lt 9; i++) {
            for (int j = 0; j &lt 9; j++) {
                if (board[i][j] == '.') {
                    for (char digit = '1'; digit &lt= '9'; digit++) {
                        if (isValid(board, i, j, digit)) {
                            board[i][j] = digit;
                            if (solveSudoku(board)) return true;
                            else board[i][j] = '.';
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }

    void solveSudokuWrapper(vector&lt;vector&lt;char&gt;&gt;& board) {
        solveSudoku(board);
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(9^(m)), where m is the number of empty cells. While the worst-case remains the same as brute force, optimizations can lead to significant practical speedups. | <b>Space Complexity:</b> O(1) - ignoring the stack space of recursion.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The provided Sudoku board is solved, and a valid solution is returned. The input and output are represented using string arrays.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">board = [["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">This is the same as the first example, demonstrating the solution process for a valid Sudoku.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  The problem requires modifying the board in-place.
2.  The input Sudoku is guaranteed to have a unique solution.
3.  Backtracking is a common and effective approach for constraint satisfaction problems like Sudoku.
4.  Optimizations can include trying digits that have fewer possible candidates first.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/n-queens/>N-Queens</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>The N-Queens problem asks to place N chess queens on an NxN chessboard such that no two queens threaten each other. A queen can attack horizontally, vertically, and diagonally. The goal is to find all distinct solutions to this problem.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach tries all possible placements of queens on the board. For each cell on the board, it tries placing a queen and then recursively calls itself to place the remaining queens. This approach checks if the current placement is valid after each queen placement.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

// Function to check if a queen can be placed at board[row][col]
bool isSafe(vector&lt;string&gt;&amp; board, int row, int col, int n) {
    // Check same column
    for (int i = 0; i &lt; row; i++) {
        if (board[i][col] == 'Q') {
            return false;
        }
    }

    // Check upper left diagonal
    for (int i = row, j = col; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) {
        if (board[i][j] == 'Q') {
            return false;
        }
    }

    // Check upper right diagonal
    for (int i = row, j = col; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) {
        if (board[i][j] == 'Q') {
            return false;
        }
    }

    return true;
}

// Recursive function to solve N-Queens
void solveNQueensBruteForce(vector&lt;vector&lt;string&gt;&gt;&amp; solutions, vector&lt;string&gt;&amp; board, int row, int n) {
    if (row == n) {
        solutions.push_back(board);
        return;
    }

    for (int col = 0; col &lt; n; col++) {
        if (isSafe(board, row, col, n)) {
            board[row][col] = 'Q';
            solveNQueensBruteForce(solutions, board, row + 1, n);
            board[row][col] = '.'; // Backtrack
        }
    }
}

vector&lt;vector&lt;string&gt;&gt; solveNQueensBruteForce(int n) {
    vector&lt;vector&lt;string&gt;&gt; solutions;
    vector&lt;string&gt; board(n, string(n, '.'));
    solveNQueensBruteForce(solutions, board, 0, n);
    return solutions;
}

//int main() {
//    int n = 4;
//    vector&lt;vector&lt;string&gt;&gt; solutions = solveNQueensBruteForce(n);
//    for (const auto&amp; solution : solutions) {
//        for (const string&amp; row : solution) {
//            cout &lt;&lt; row &lt;&lt; endl;
//        }
//        cout &lt;&lt; endl;
//    }
//    return 0;
//}
</code></pre>
  <p><b>Time Complexity:</b> O(N!) - where N is the size of the board.  We explore all possible combinations. The number of possible placements grows factorially. | <b>Space Complexity:</b> O(N^2) - space for the board and recursive call stack in worst-case (all possible solutions are generated)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Backtracking with Optimization</h5>
  <p>This approach is also a backtracking approach, but it optimizes the safety checks by using auxiliary arrays to keep track of columns, diagonals, and anti-diagonals that are under attack. This avoids repeatedly iterating through the board to check for conflicts.  This approach still relies on recursion and backtracking.</p>
  <pre><code class="language-python">#include &lt;bits/stdc++.h&gt;

using namespace std;

void solveNQueens(vector&lt;vector&lt;string&gt;&gt;&amp; solutions, vector&lt;string&gt;&amp; board, vector&lt;bool&gt;&amp; cols, vector&lt;bool&gt;&amp; diag1, vector&lt;bool&gt;&amp; diag2, int row, int n) {
    if (row == n) {
        solutions.push_back(board);
        return;
    }

    for (int col = 0; col &lt; n; col++) {
        if (!cols[col] &amp;&amp; !diag1[row + col] &amp;&amp; !diag2[row - col + n - 1]) {
            board[row][col] = 'Q';
            cols[col] = true;
            diag1[row + col] = true;
            diag2[row - col + n - 1] = true;
            solveNQueens(solutions, board, cols, diag1, diag2, row + 1, n);
            board[row][col] = '.'; // Backtrack
            cols[col] = false;
            diag1[row + col] = false;
            diag2[row - col + n - 1] = false;
        }
    }
}

vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {
    vector&lt;vector&lt;string&gt;&gt; solutions;
    vector&lt;string&gt; board(n, string(n, '.'));
    vector&lt;bool&gt; cols(n, false);
    vector&lt;bool&gt; diag1(2 * n - 1, false); // row + col
    vector&lt;bool&gt; diag2(2 * n - 1, false); // row - col + n - 1
    solveNQueens(solutions, board, cols, diag1, diag2, 0, n);
    return solutions;
}

//int main() {
//    int n = 4;
//    vector&lt;vector&lt;string&gt;&gt; solutions = solveNQueens(n);
//    for (const auto&amp; solution : solutions) {
//        for (const string&amp; row : solution) {
//            cout &lt;&lt; row &lt;&lt; endl;
//        }
//        cout &lt;&lt; endl;
//    }
//    return 0;
//}
</code></pre>
  <p><b>Time Complexity:</b> O(N!) -  Worst-case time complexity is still factorial because we are trying all possible placements. | <b>Space Complexity:</b> O(N^2) - for the board and O(N) for auxiliary arrays, overall still dominated by the board storage.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[ ".Q..",  "...Q",  "Q...",  "..Q." ], [ "..Q.",  "Q...",  "...Q",  ".Q.."]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Two distinct solutions exist for n=4.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[ "Q" ]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">One solution exists for n=1.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">n = 8</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[[...], [...], ...]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Many solutions exist for n=8. (Not fully shown as output will be long)</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The time complexity is inherently exponential due to the nature of the problem. Backtracking is necessary to explore all solution possibilities. The optimization primarily focuses on speeding up the conflict checks within each recursive step. Edge case: When n = 1 or n = 2 or n = 3, only a few solutions or no solutions will exist. For larger n, the number of solutions increase significantly.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/unique-paths-iii/>Unique Paths III</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>You are given an m x n integer array grid where grid[i][j] represents the value of the cell. 

*   1 represents the starting point.
*   2 represents the ending point.
*   0 represents empty cells that you can walk over.
*   -1 represents obstacles that you cannot walk over.

Return the number of 4-directional walks from the starting point to the ending point, such that each empty cell is visited exactly once.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves exploring all possible paths from the starting cell to the ending cell. For each path, we check if it visits all the empty cells exactly once. This can be implemented using recursion with backtracking.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    int uniquePathsIII(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int m = grid.size();
        int n = grid[0].size();
        int startRow, startCol, emptyCells = 0;

        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (grid[i][j] == 1) {
                    startRow = i;
                    startCol = j;
                } else if (grid[i][j] == 0) {
                    emptyCells++;
                }
            }
        }

        int count = 0;
        dfs(grid, startRow, startCol, emptyCells + 1, count);
        return count;
    }

    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col, int remainingCells, int&amp; count) {
        int m = grid.size();
        int n = grid[0].size();

        if (row &lt; 0 || row &gt;= m || col &lt; 0 || col &gt;= n || grid[row][col] == -1) {
            return;
        }

        if (grid[row][col] == 2) {
            if (remainingCells == 0) {
                count++;
            }
            return;
        }

        if (grid[row][col] == 0 || grid[row][col] == 1) {
            grid[row][col] = -2; // Mark as visited
            dfs(grid, row + 1, col, remainingCells - 1, count);
            dfs(grid, row - 1, col, remainingCells - 1, count);
            dfs(grid, row, col + 1, remainingCells - 1, count);
            dfs(grid, row, col - 1, remainingCells - 1, count);
            grid[row][col] = 0; // Backtrack
        }
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(4^(m*n)), where m and n are the dimensions of the grid.  In the worst case, we explore all possible paths, which can be as many as 4 choices at each cell. We visit at most m*n cells. | <b>Space Complexity:</b> O(m*n) due to the recursion depth (in the worst case).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized DFS with Bitmasking</h5>
  <p>The optimized solution uses Depth-First Search (DFS) with bitmasking to track visited cells, reducing redundant explorations. We maintain a bitmask representing which empty cells have been visited. When we encounter the end cell, we check if all empty cells have been visited (bitmask is full).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

class Solution {
public:
    int uniquePathsIII(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int m = grid.size();
        int n = grid[0].size();
        int startRow, startCol, emptyCells = 0;

        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (grid[i][j] == 1) {
                    startRow = i;
                    startCol = j;
                } else if (grid[i][j] == 0) {
                    emptyCells++;
                }
            }
        }

        int count = 0;
        dfs(grid, startRow, startCol, emptyCells, 0, count);
        return count;
    }

    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col, int emptyCells, int visited, int&amp; count) {
        int m = grid.size();
        int n = grid[0].size();

        if (row &lt; 0 || row &gt;= m || col &lt; 0 || col &gt;= n || grid[row][col] == -1) {
            return;
        }

        if (grid[row][col] == 2) {
            if (visited == emptyCells) {
                count++;
            }
            return;
        }

        if (grid[row][col] == 0 || grid[row][col] == 1) {
            grid[row][col] = -2; // Mark as visited

            dfs(grid, row + 1, col, emptyCells, visited + 1, count);
            dfs(grid, row - 1, col, emptyCells, visited + 1, count);
            dfs(grid, row, col + 1, emptyCells, visited + 1, count);
            dfs(grid, row, col - 1, emptyCells, visited + 1, count);

            grid[row][col] = 0; // Backtrack
        }
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(4^(number of empty cells)).  In the worst case, this will still be exponential as with brute-force, though with bitmasking we've reduced the overall search space by keeping track of visited nodes efficiently. | <b>Space Complexity:</b> O(m*n) in the worst case for recursive call stack.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There are two paths that visit all empty cells exactly once.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[1,0,0,0],[0,0,0,0],[0,0,0,2]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There are four paths that visit all empty cells exactly once.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">[[0,1],[2,0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There is no path that visits all empty cells exactly once.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The key to solving this problem efficiently is to correctly identify and mark visited cells and backtracking. Bitmasking can greatly optimize path checking by representing the visited status of each empty cell compactly.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/find-maximum-number-possible-by-doing-at-most-k-swaps/>Find maximum number possible by doing at most K swaps</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given a string representing a number and an integer k, find the maximum possible number that can be formed by performing at most k swaps of digits.  For example, given "2543" and k=1, the output would be "5243".</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Generate all possible permutations by performing at most k swaps. For each permutation, convert it to a number and keep track of the maximum number found so far. This involves recursion to generate swaps.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

string findMaximumNum_brute_force(string str, int k, string& max_num, int index) {
    if (k == 0 || index == str.length()) {
        return str;
    }

    for (int i = index; i &lt str.length(); i++) {
        if (str[i] &gt str[index]) {
            swap(str[i], str[index]);
            if (str &gt max_num) {
                max_num = str;
            }
            findMaximumNum_brute_force(str, k - 1, max_num, index + 1);
            swap(str[i], str[index]);
        }
    }
    findMaximumNum_brute_force(str, k, max_num, index + 1);
    return max_num;
}

string findMaximumNum_brute_force_wrapper(string str, int k) {
    string max_num = str;
    return findMaximumNum_brute_force(str, k, max_num, 0);
}
</code></pre>
  <p><b>Time Complexity:</b> O(n! * k), where n is the length of the string. For each level of recursion, we perform swaps which are O(1). | <b>Space Complexity:</b> O(n) due to recursion depth.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Greedy with Backtracking</h5>
  <p>Iterate through the string. For each position, find the largest digit to the right and swap if it's greater.  Recursively call the function with k-1 and next index. Maintain a global maximum string to store results. This utilizes a greedy approach to maximize the number at each step and backtracking to explore different swap combinations.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

string max_num;

void findMaximumNum_optimized_recursive(string& str, int k, int index) {
    if (k == 0 || index == str.length()) {
        return;
    }

    char max_char = str[index];
    int max_index = index;

    for (int i = index + 1; i &lt str.length(); i++) {
        if (str[i] &gt max_char) {
            max_char = str[i];
            max_index = i;
        }
    }

    if (max_char != str[index]) {
        swap(str[index], str[max_index]);
        if (str &gt max_num) {
            max_num = str;
        }
        findMaximumNum_optimized_recursive(str, k - 1, index + 1);
        swap(str[index], str[max_index]);
    }
    findMaximumNum_optimized_recursive(str, k, index + 1);
}

string findMaximumNum_optimized(string str, int k) {
    max_num = str;
    findMaximumNum_optimized_recursive(str, k, 0);
    return max_num;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2 * k) in the worst case, where n is the length of the string.  The outer loop iterates up to n times. The inner loop to find max character iterates up to n times.  The recursive calls contribute a factor of k. | <b>Space Complexity:</b> O(n) due to recursion depth.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">{"str": "2543", "k": 1}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">"5243"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Swapping 2 and 5 gives the maximum possible number.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">{"str": "2543", "k": 2}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">"5423"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Swapping 2 and 5, then 3 and 4 yields the maximum.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">{"str": "12345", "k": 4}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">"54321"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">We can swap any two digits.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">{"str": "12345", "k": 0}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">"12345"</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No swaps allowed, so return the original number.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The optimized solution provides a significant performance improvement over the brute-force approach. Edge cases to consider: when k is greater than or equal to the number of possible swaps. If the input string consists of all the same digits, the original string will be returned. If k is 0, return the input string.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/partition-set-k-subsets-equal-sum/>Partition a set into K subsets with equal sum</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given an array of integers `nums` and a positive integer `k`, determine if it is possible to divide the array into `k` non-empty subsets such that the sum of elements in each subset is equal. </p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves generating all possible subsets of the input array. For each subset, check if its sum is equal to the target sum (total sum of array / k). If a subset with the target sum is found, recursively check if the remaining elements can be partitioned into the remaining k-1 subsets. This approach explores all combinations and is inefficient due to exponential time complexity.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;numeric&gt;

using namespace std;

// Function to calculate the sum of a subset
int subsetSum(const vector&lt;int&gt;& nums, const vector&lt;bool&gt;& mask) {
    int sum = 0;
    for (size_t i = 0; i &lt; nums.size(); ++i) {
        if (mask[i]) {
            sum += nums[i];
        }
    }
    return sum;
}

// Recursive function to check if the remaining elements can be partitioned
bool canPartitionRecursive(const vector&lt;int&gt;& nums, int k, int targetSum, vector&lt;bool&gt;& used, int currentSubsetSum, int startIndex) {
    if (k == 0) {
        return true; // All subsets have been successfully formed
    }

    if (currentSubsetSum == targetSum) {
        return canPartitionRecursive(nums, k - 1, targetSum, used, 0, 0); // Move to next subset
    }

    for (int i = startIndex; i &lt; nums.size(); ++i) {
        if (!used[i] &amp;&amp; currentSubsetSum + nums[i] &lt;= targetSum) {
            used[i] = true;
            if (canPartitionRecursive(nums, k, targetSum, used, currentSubsetSum + nums[i], i + 1)) {
                return true;
            }
            used[i] = false; // Backtrack: Try another element
        }
    }
    return false; // This subset could not be formed
}

bool canPartitionKSubsetsBruteForce(vector&lt;int&gt;& nums, int k) {
    int n = nums.size();
    if (k &lt;= 0 || n &lt; k) {
        return false; // Invalid input
    }

    int sum = accumulate(nums.begin(), nums.end(), 0); // Sum of all elements
    if (sum % k != 0) {
        return false; // If sum is not divisible by k, it's impossible
    }

    int targetSum = sum / k;
    vector&lt;bool&gt; used(n, false); // Keep track of used elements
    return canPartitionRecursive(nums, k, targetSum, used, 0, 0);
}

int main() {
    vector&lt;int&gt; nums = {4, 3, 2, 3, 5, 2}; // Example input
    int k = 4;
    bool result = canPartitionKSubsetsBruteForce(nums, k);
    cout &lt;&lt; "Can partition into " &lt;&lt; k &lt;&lt; " subsets? " &lt;&lt; (result ? "Yes" : "No") &lt;&lt; endl;
    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(k * 2^n), where n is the number of elements in the array. This is because, in worst-case scenario, we try all possible subsets. For each subset, we explore the remaining elements.  The factor of k comes from the recursive calls.  | <b>Space Complexity:</b> O(n) due to recursion depth and the boolean array `used`.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming with Bitmasking and Memoization</h5>
  <p>This optimized approach utilizes dynamic programming with bitmasking to keep track of which elements have been included in the subsets. Memoization helps to avoid redundant calculations. The algorithm checks for all possible combinations of subsets to create the required number of subsets. The key is to represent the inclusion/exclusion of elements using a bitmask, and a 2D DP table to store results.</p>
  <pre><code class="language-python">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;numeric&gt;

using namespace std;

bool canPartitionKSubsetsDP(vector&lt;int&gt;& nums, int k) {
    int n = nums.size();
    if (k &lt;= 0 || n &lt; k) {
        return false;
    }

    int sum = accumulate(nums.begin(), nums.end(), 0);  
    if (sum % k != 0) {
        return false;
    }

    int targetSum = sum / k;
    vector&lt;vector&lt;int&gt;&gt; dp(1 &lt;&lt; n, vector&lt;int&gt;(k + 1, -1));
    dp[0][0] = 0; // Base case: empty subset, 0 subsets formed.

    for (int mask = 0; mask &lt; (1 &lt;&lt; n); ++mask) {
        for (int subsets = 1; subsets &lt;= k; ++subsets) {
            if (dp[mask][subsets - 1] == -1) continue; // If previous state not possible

            for (int i = 0; i &lt; n; ++i) {
                if (!(mask &amp; (1 &lt;&lt; i))) { // If ith element is not in current mask
                    int nextMask = mask | (1 &lt;&lt; i); // Adding ith element to the mask

                    if (dp[mask][subsets - 1] + nums[i] == targetSum) {
                        dp[nextMask][subsets] = 0; // Subset formed; start next subset
                    } else if (dp[mask][subsets - 1] + nums[i] &lt; targetSum) {
                        dp[nextMask][subsets - 1] = dp[mask][subsets - 1] + nums[i];
                    }
                }
            }
        }
    }
    return dp[(1 &lt;&lt; n) - 1][k] == 0; // Check if all elements included and all subsets formed
}

int main() {
    vector&lt;int&gt; nums = {4, 3, 2, 3, 5, 2};
    int k = 4;
    bool result = canPartitionKSubsetsDP(nums, k);
    cout &lt;&lt; "Can partition into " &lt;&lt; k &lt;&lt; " subsets? " &lt;&lt; (result ? "Yes" : "No") &lt;&lt; endl;
    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(k * 2^n * n), where n is the number of elements and k is the number of subsets. The outer loops iterate through all possible subsets (2^n) and all possible subsets (k). Inside the inner loop it check for each element. | <b>Space Complexity:</b> O(2^n * k) for the DP table.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [4, 3, 2, 3, 5, 2], k = 4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">True</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The array can be partitioned into the following subsets: [4, 2], [3, 3], [5], [2]</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1, 2, 3, 4], k = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">False</td>
        <td style="border: 1px solid #ccc; padding: 6px;">It is impossible to partition the array into 3 subsets with equal sum.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [10, 4, 6, 3, 7, 9, 2], k = 3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">True</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Partitioned into [10, 2], [4, 6, 3], [7, 9]</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. The sum of the elements must be divisible by k.
2. The backtracking approach is computationally expensive.
3. The dynamic programming approach with bitmasking is significantly more efficient.
4. Consider cases where k is larger than the array size.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/tug-of-war/>Tug of War</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given a set of weights, divide them into two subsets such that the difference between the sums of the weights in the two subsets is minimized. The goal is to find the smallest possible difference in sums.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Generate all possible subsets of the given array. For each subset, calculate its sum and the sum of its complement. Find the minimum absolute difference between the sums of the two subsets.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int findMinDiff(const vector&lt;int&gt;& weights) {
    int n = weights.size();
    int totalSum = accumulate(weights.begin(), weights.end(), 0);
    int minDiff = INT_MAX;

    for (int i = 0; i &lt (1 &lt&lt n); ++i) {
        int subsetSum = 0;
        for (int j = 0; j &lt n; ++j) {
            if ((i & (1 &lt&lt j)) != 0) {
                subsetSum += weights[j];
            }
        }
        int otherSubsetSum = totalSum - subsetSum;
        minDiff = min(minDiff, abs(subsetSum - otherSubsetSum));
    }

    return minDiff;
}
</code></pre>
  <p><b>Time Complexity:</b> O(2^n * n), where n is the number of weights.  Generating all subsets takes O(2^n) and calculating the sum of each subset takes O(n). | <b>Space Complexity:</b> O(1).  We use constant extra space.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming</h5>
  <p>Use dynamic programming to determine which sums are achievable with the given weights. Build a boolean table `dp[i][j]` where `dp[i][j]` is true if a sum of `j` can be achieved using the first `i` weights.  Then, iterate through the possible sums close to half the total sum and calculate the minimum difference.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int findMinDiffDP(const vector&lt;int&gt;& weights) {
    int n = weights.size();
    int totalSum = accumulate(weights.begin(), weights.end(), 0);
    int halfSum = totalSum / 2;

    vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(totalSum + 1, false));

    // Initialize the first column to true (sum 0 is always possible)
    for (int i = 0; i &lt= n; ++i) {
        dp[i][0] = true;
    }

    // Fill the DP table
    for (int i = 1; i &lt= n; ++i) {
        for (int j = 1; j &lt= totalSum; ++j) {
            // If the current weight is less than or equal to the current sum, 
            // we have two options: include the weight or exclude it.
            if (weights[i - 1] &lt= j) {
                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - weights[i - 1]];
            } else {
                // If the current weight is greater than the current sum, 
                // we cannot include it.
                dp[i][j] = dp[i - 1][j];
            }
        }
    }

    // Find the closest sum to halfSum
    int minDiff = INT_MAX;
    for (int j = 0; j &lt= halfSum; ++j) {
        if (dp[n][j]) {
            minDiff = min(minDiff, totalSum - 2 * j);
        }
    }

    return minDiff;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n * sum), where n is the number of weights and sum is the total sum of weights. | <b>Space Complexity:</b> O(n * sum)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">weights = {1, 6, 11, 5}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">We can divide the weights into two sets: {1, 5, 6} and {11}. The difference is |12 - 11| = 1.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">weights = {3, 4, 5, 6, 8, 11}</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The sets can be {3,4,5,8} and {6,11}, and the difference is |20-17|=3. Or {3,4,6,8} and {5,11}, and the difference is |21-16|=5. The minimum is when one of them is {3,5,11} and {4,6,8}, difference is |19-18| = 1.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The dynamic programming approach is significantly more efficient than the brute-force approach, especially for larger input sizes.  Consider the edge case of an empty input array (return 0) or an array with a single element (return the element itself).</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/find-paths-from-corner-cell-to-middle-cell-in-maze/>Find paths from corner cell to middle cell in a maze</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given a maze represented by a 2D matrix, where 0 represents a traversable cell and 1 represents a blocked cell, find the number of paths from a corner cell (e.g., top-left) to the middle cell (or cells, in the case of even dimensions) of the maze. You can only move right and down.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Recursively explore all possible paths from the starting corner to the middle cell(s). For each cell, check if it's valid (within bounds and not blocked) and recursively call the function for the right and down moves.  Count the successful paths.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int countPaths(vector&lt;vector&lt;int&gt;&gt;&amp; maze, int row, int col, int endRow, int endCol) {
    int rows = maze.size();
    int cols = maze[0].size();

    // Base cases
    if (row &lt 0 || row &gt= rows || col &lt 0 || col &gt= cols || maze[row][col] == 1) {
        return 0; // Out of bounds or blocked cell
    }

    if (row == endRow &amp;&amp; col == endCol) {
        return 1; // Reached the end cell
    }

    // Recursive calls
    return countPaths(maze, row + 1, col, endRow, endCol) +  // Move down
           countPaths(maze, row, col + 1, endRow, endCol);  // Move right
}


int main() {
    vector&lt;vector&lt;int&gt;&gt; maze = {
        {0, 0, 0, 0, 0},
        {0, 1, 1, 1, 0},
        {0, 0, 0, 1, 0},
        {0, 1, 0, 1, 0},
        {0, 0, 0, 0, 0}
    };

    int rows = maze.size();
    int cols = maze[0].size();

    int endRow = (rows - 1) / 2;
    int endCol = (cols - 1) / 2;

    int numPaths = countPaths(maze, 0, 0, endRow, endCol);
    cout &lt&lt "Number of paths: " &lt&lt numPaths &lt&lt endl;

    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(2^(M+N)), where M and N are the dimensions of the maze.  Each cell may have 2 recursive calls. | <b>Space Complexity:</b> O(M+N) due to the recursion depth in the worst case (when the path is long).</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Dynamic Programming (Tabulation)</h5>
  <p>Use dynamic programming to store the number of paths from the starting cell to each cell in the maze.  Iterate through the maze, calculating the number of paths to a cell by summing the number of paths from the cell above and the cell to the left. Handle base cases (first row/column) and blocked cells.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int countPathsDP(vector&lt;vector&lt;int&gt;&gt;&amp; maze, int endRow, int endCol) {
    int rows = maze.size();
    int cols = maze[0].size();

    vector&lt;vector&lt;int&gt;&gt; dp(rows, vector&lt;int&gt;(cols, 0));

    // Base case: starting cell
    if (maze[0][0] == 0) {
        dp[0][0] = 1;
    }

    // Fill first row
    for (int j = 1; j &lt cols; ++j) {
        if (maze[0][j] == 0) {
            dp[0][j] = dp[0][j - 1];
        }
    }

    // Fill first column
    for (int i = 1; i &lt rows; ++i) {
        if (maze[i][0] == 0) {
            dp[i][0] = dp[i - 1][0];
        }
    }

    // Fill the DP table
    for (int i = 1; i &lt rows; ++i) {
        for (int j = 1; j &lt cols; ++j) {
            if (maze[i][j] == 0) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
    }

    return dp[endRow][endCol];
}

int main() {
    vector&lt;vector&lt;int&gt;&gt; maze = {
        {0, 0, 0, 0, 0},
        {0, 1, 1, 1, 0},
        {0, 0, 0, 1, 0},
        {0, 1, 0, 1, 0},
        {0, 0, 0, 0, 0}
    };

    int rows = maze.size();
    int cols = maze[0].size();

    int endRow = (rows - 1) / 2;
    int endCol = (cols - 1) / 2;

    int numPaths = countPathsDP(maze, endRow, endCol);
    cout &lt&lt "Number of paths: " &lt&lt numPaths &lt&lt endl;

    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(M * N), where M and N are the dimensions of the maze. | <b>Space Complexity:</b> O(M * N) for the DP table.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">maze = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">There are two possible paths from the top-left to the middle cell (1,1).</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">maze = [[0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">4</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The middle cells are (1,1) and (1,2). The paths to either will be the same. There are 4 such paths.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">maze = [[0]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">A maze with only one cell will have one path.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>Consider the case where the start or end cell is blocked (value 1), or where the dimensions are even. Handle the case where the maze is a single cell. The dynamic programming approach provides a significant performance improvement over the brute-force recursive solution. The problem can also be extended by allowing diagonal moves (which adds complexity to the DP table calculations).</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/solving-cryptarithmetic-puzzles-backtracking-8/>Solving Cryptarithmetic Puzzles using Backtracking</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given an equation of the form "SEND + MORE = MONEY" where each letter represents a digit from 0 to 9, the task is to assign digits to each letter such that the equation holds true. No two letters can be assigned the same digit. The goal is to find a valid assignment of digits to letters or determine that no such assignment exists.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Generate all possible permutations of digits (0-9) and assign them to the unique letters in the equation. For each permutation, check if the resulting arithmetic equation is valid. If a valid assignment is found, return it. Otherwise, continue trying all permutations.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

bool isValid(string& s1, string& s2, string& s3, map&ltchar, int&gt& mp) {
    long long num1 = 0, num2 = 0, num3 = 0;
    for (char c : s1) {
        num1 = num1 * 10 + mp[c];
    }
    for (char c : s2) {
        num2 = num2 * 10 + mp[c];
    }
    for (char c : s3) {
        num3 = num3 * 10 + mp[c];
    }
    return num1 + num2 == num3;
}

bool solve(string& s1, string& s2, string& s3, vector&ltchar&gt& letters, map&ltchar, int&gt& mp, vector&ltbool&gt& used, int index) {
    if (index == letters.size()) {
        return isValid(s1, s2, s3, mp);
    }

    for (int i = 0; i &lt; 10; i++) {
        if (!used[i]) {
            used[i] = true;
            mp[letters[index]] = i;
            if (solve(s1, s2, s3, letters, mp, used, index + 1)) {
                return true;
            }
            used[i] = false;
        }
    }
    return false;
}

int main() {
    string s1 = "SEND", s2 = "MORE", s3 = "MONEY";
    vector&ltchar&gt letters;
    map&ltchar, int&gt mp;
    vector&ltbool&gt used(10, false);
    set&ltchar&gt seen;

    for (char c : s1) {if (seen.find(c) == seen.end()) {letters.push_back(c); seen.insert(c);}}
    for (char c : s2) {if (seen.find(c) == seen.end()) {letters.push_back(c); seen.insert(c);}}
    for (char c : s3) {if (seen.find(c) == seen.end()) {letters.push_back(c); seen.insert(c);}}

    if (solve(s1, s2, s3, letters, mp, used, 0)) {
        cout &lt&lt "Solution found:\n";
        for (auto const& [key, val] : mp) {
            cout &lt&lt key &lt&lt ": " &lt&lt val &lt&lt endl;
        }
    } else {
        cout &lt&lt "No solution exists" &lt&lt endl;
    }

    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(10! * k) where k is the time to check the validity of each assignment, and 10! is the number of permutations. k is roughly equal to the length of the strings (number of digits). Thus, it is roughly O(10! * L) where L is string length. | <b>Space Complexity:</b> O(N) where N is the number of unique letters (in worst case, N = 10)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Backtracking with Pruning</h5>
  <p>This is the same as brute force with optimization. The key is to avoid exploring branches of the search tree that are guaranteed to fail. The optimization here is about premature termination or pruning. For example: 1. If leading digits of the sum and addends are known and an invalid result is obtained. 2. Carry-over handling helps pruning. 3. If intermediate sums at each column (right to left) are evaluated. Whenever a conflict is found, the path can be abandoned.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

bool solve(string& s1, string& s2, string& s3, map&ltchar, int&gt& mp, vector&ltbool&gt& used, int index, vector&ltchar&gt& letters, int& carry) {
    if (index == letters.size()) {
        if(carry == 0){
            return isValid(s1, s2, s3, mp);
        }
        return false;
    }

    for (int i = 0; i &lt; 10; i++) {
        if (!used[i]) {
            used[i] = true;
            mp[letters[index]] = i;

            if (solve(s1, s2, s3, mp, used, index + 1, letters, carry)) {
                return true;
            }
            used[i] = false;
        }
    }
    return false;
}

bool isValid(string& s1, string& s2, string& s3, map&ltchar, int&gt& mp) {
    long long num1 = 0, num2 = 0, num3 = 0;
    if (mp[s1[0]] == 0 || mp[s2[0]] == 0 || mp[s3[0]] == 0) return false;
    for (char c : s1) {
        num1 = num1 * 10 + mp[c];
    }
    for (char c : s2) {
        num2 = num2 * 10 + mp[c];
    }
    for (char c : s3) {
        num3 = num3 * 10 + mp[c];
    }
    return num1 + num2 == num3;
}

int main() {
    string s1 = "SEND", s2 = "MORE", s3 = "MONEY";
    vector&ltchar&gt letters;
    map&ltchar, int&gt mp;
    vector&ltbool&gt used(10, false);
    set&ltchar&gt seen;

    for (char c : s1) {if (seen.find(c) == seen.end()) {letters.push_back(c); seen.insert(c);}}
    for (char c : s2) {if (seen.find(c) == seen.end()) {letters.push_back(c); seen.insert(c);}}
    for (char c : s3) {if (seen.find(c) == seen.end()) {letters.push_back(c); seen.insert(c);}}

    int carry = 0;
    if (solve(s1, s2, s3, mp, used, 0, letters, carry)) {
        cout &lt&lt "Solution found:\n";
        for (auto const& [key, val] : mp) {
            cout &lt&lt key &lt&lt ": " &lt&lt val &lt&lt endl;
        }
    } else {
        cout &lt&lt "No solution exists" &lt&lt endl;
    }

    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(10!) in the worst case. However, in practice, due to pruning, it is significantly faster than the brute force approach. | <b>Space Complexity:</b> O(N) where N is the number of unique letters (in worst case, N = 10)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">SEND + MORE = MONEY</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Solution found:
S: 9
E: 5
N: 6
D: 7
M: 1
O: 0
R: 8
Y: 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The given equation is solved by assigning digits to the letters such that the equation holds true.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">TW + TWO = THREE</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Solution found:
T: 6
W: 5
O: 8
E: 9
R: 1
H: 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Another example of a valid cryptarithmetic solution.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">ODD + ODD = EVEN</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No solution exists</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Illustrates a case where no valid solution is found.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1.  **Leading Zeros:** Handle cases where a letter cannot be assigned 0 if it's the leading digit of a number.
2.  **Efficiency:** Pruning the search space using constraints significantly improves performance, especially in the optimized approach.
3. **Constraints:** The constraint that each letter must be assigned a unique digit from 0-9 is critical.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://www.geeksforgeeks.org/print-palindromic-partitions-string/>Print all palindromic partitions of a string</a> <span style="font-size:14px; color:#888;">Hard</span></h3>
  <p>Given a string, the task is to print all possible palindromic partitions of the given string. A palindromic partition of a string is a partition of the string such that each substring in the partition is a palindrome.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Generate all possible partitions of the string. For each partition, check if all substrings are palindromes. If they are, print the partition.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Function to check if a string is palindrome
bool isPalindrome(const string& s, int start, int end) {
    while (start &lt= end) {
        if (s[start++] != s[end--]) {
            return false;
        }
    }
    return true;
}

// Recursive function to find all palindromic partitions
void allPalPartitionsHelper(string& s, int start, vector&lt;string&gt;&amp; currentPartition, vector&lt;vector&lt;string&gt;&gt;&amp; allPartitions) {
    if (start &gt= s.length()) {
        allPartitions.push_back(currentPartition);
        return;
    }

    for (int i = start; i &lt s.length(); ++i) {
        if (isPalindrome(s, start, i)) {
            currentPartition.push_back(s.substr(start, i - start + 1));
            allPalPartitionsHelper(s, i + 1, currentPartition, allPartitions);
            currentPartition.pop_back(); // Backtrack: Remove the last partition to explore other possibilities
        }
    }
}

// Function to find all palindromic partitions
vector&lt;vector&lt;string&gt;&gt; allPalindromicPartitions(string s) {
    vector&lt;vector&lt;string&gt;&gt; allPartitions;
    vector&lt;string&gt; currentPartition;
    allPalPartitionsHelper(s, 0, currentPartition, allPartitions);
    return allPartitions;
}

// Function to print the palindromic partitions
void printPalindromicPartitions(string s) {
    vector&lt;vector&lt;string&gt;&gt; partitions = allPalindromicPartitions(s);
    for (const auto& partition : partitions) {
        for (const string& str : partition) {
            cout &lt&lt str &lt&lt " ";
        }
        cout &lt&lt endl;
    }
}

// Driver code
int main() {
    string s = "geeks";
    printPalindromicPartitions(s);
    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N * 2^N), where N is the length of the string.  Generating all partitions takes O(2^N) and checking if substrings are palindromes takes O(N) in worst case. | <b>Space Complexity:</b> O(N) for recursion depth in worst case. Also O(N) to store the current partition.  O(N^2) to store all the possible partitions in the worst case</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Optimized Recursive with Dynamic Programming (Memoization)</h5>
  <p>Use recursion with memoization to avoid redundant palindrome checks.  Precompute palindrome table to optimize the isPalindrome check.  Use dynamic programming to store whether a substring is a palindrome or not. This optimization significantly reduces redundant computations.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

// Function to check if a string is palindrome
bool isPalindrome(const string& s, int start, int end, vector&lt;vector&lt;bool&gt;&gt;&amp; dp) {
    if (start &gt= end) return true;
    if (dp[start][end] != false) return dp[start][end]; // Use cached value

    while (start &lt= end) {
        if (s[start++] != s[end--]) {
            dp[start - 1][end + 1] = false;
            return false;
        }
    }
    dp[start - 1][end + 1] = true;
    return true;
}

// Recursive function to find all palindromic partitions
void allPalPartitionsHelper(string& s, int start, vector&lt;string&gt;&amp; currentPartition, vector&lt;vector&lt;string&gt;&gt;&amp; allPartitions, vector&lt;vector&lt;bool&gt;&gt;&amp; dp) {
    if (start &gt= s.length()) {
        allPartitions.push_back(currentPartition);
        return;
    }

    for (int i = start; i &lt s.length(); ++i) {
        if (isPalindrome(s, start, i, dp)) {
            currentPartition.push_back(s.substr(start, i - start + 1));
            allPalPartitionsHelper(s, i + 1, currentPartition, allPartitions, dp);
            currentPartition.pop_back(); // Backtrack
        }
    }
}

// Function to find all palindromic partitions
vector&lt;vector&lt;string&gt;&gt; allPalindromicPartitions(string s) {
    vector&lt;vector&lt;string&gt;&gt; allPartitions;
    vector&lt;string&gt; currentPartition;
    vector&lt;vector&lt;bool&gt;&gt; dp(s.length(), vector&lt;bool&gt;(s.length(), false));
    allPalPartitionsHelper(s, 0, currentPartition, allPartitions, dp);
    return allPartitions;
}

// Function to print the palindromic partitions
void printPalindromicPartitions(string s) {
    vector&lt;vector&lt;string&gt;&gt; partitions = allPalindromicPartitions(s);
    for (const auto& partition : partitions) {
        for (const string& str : partition) {
            cout &lt&lt str &lt&lt " ";
        }
        cout &lt&lt endl;
    }
}

// Driver code
int main() {
    string s = "geeks";
    printPalindromicPartitions(s);
    return 0;
}
</code></pre>
  <p><b>Time Complexity:</b> O(N^2) time complexity. The palindrome check takes O(1) time (using memoization). There are at most N recursive calls for building partitions. The time to build up the DP table will also be O(N^2) | <b>Space Complexity:</b> O(N^2) to store the DP table and the partitions in worst case. O(N) for recursion depth.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">geeks</td>
        <td style="border: 1px solid #ccc; padding: 6px;">g e e k s 
g ee k s 
ge e ks 
</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The output shows all possible palindromic partitions for the input string "geeks".</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">madam</td>
        <td style="border: 1px solid #ccc; padding: 6px;">m a d a m 
m ada m 
madam 
</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The output shows all possible palindromic partitions for the input string "madam".</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">aba</td>
        <td style="border: 1px solid #ccc; padding: 6px;">a b a 
aba 
</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The output shows all possible palindromic partitions for the input string "aba".</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The problem involves identifying all possible ways to divide a given string into substrings, where each substring is a palindrome. The brute-force approach explores all possible partitions, while the optimized approach uses dynamic programming for efficiency, by memorizing results to avoid recalculating them. The key to efficiency lies in pre-computing whether a substring is a palindrome or not, and avoiding the repetitive palindrome checks.</p>
</div>
<hr style="margin: 40px 0;">
<h2>Segment Tree</h2>
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/range-sum-query-immutable/>Range Sum Query - Immutable</a> <span style="font-size:14px; color:#888;">Medium/Hard</span></h3>
  <p>Given an integer array `nums`, handle multiple queries of the following type:

Calculate the sum of the elements of `nums` between indices `left` and `right` (inclusive) where `left <= right`.

Implement the `NumArray` class:

*   `NumArray(int[] nums)` initializes the object with the integer array `nums`.
*   `int sumRange(int left, int right)` returns the sum of the subarray `nums[left...right]` (i.e., `nums[left] + nums[left+1] + ... + nums[right]`)
</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the array from `left` to `right` and calculate the sum.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

class NumArray {
public:
    vector&lt;int&gt; nums;

    NumArray(vector&lt;int&gt;& nums) {
        this-&gt;nums = nums;
    }

    int sumRange(int left, int right) {
        int sum = 0;
        for (int i = left; i &lt= right; ++i) {
            sum += nums[i];
        }
        return sum;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n) for each `sumRange` query, where n is the range size (right - left + 1). O(1) for constructor. | <b>Space Complexity:</b> O(1) auxiliary space, excluding the space to store the input array.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Prefix Sum</h5>
  <p>Calculate and store the prefix sums in an array during initialization. For each `sumRange` query, return `prefixSum[right] - prefixSum[left - 1]` (or `prefixSum[right]` if `left` is 0).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt
using namespace std;

class NumArray {
public:
    vector&lt;int&gt; prefixSum;

    NumArray(vector&lt;int&gt;& nums) {
        int n = nums.size();
        prefixSum.resize(n);
        if (n &gt 0) {
            prefixSum[0] = nums[0];
            for (int i = 1; i &lt n; ++i) {
                prefixSum[i] = prefixSum[i - 1] + nums[i];
            }
        }
    }

    int sumRange(int left, int right) {
        if (left == 0) {
            return prefixSum[right];
        } else {
            return prefixSum[right] - prefixSum[left - 1];
        }
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(n) for the constructor, where n is the size of nums. O(1) for each `sumRange` query. | <b>Space Complexity:</b> O(n) for the prefix sum array.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [-2, 0, 3, -5, 2, -1]
sumRange(0, 2)
sumRange(2, 5)
sumRange(0, 5)</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1
-1
-3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)
numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1))
numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [1,2,3]
sumRange(0,2)</td>
        <td style="border: 1px solid #ccc; padding: 6px;">6</td>
        <td style="border: 1px solid #ccc; padding: 6px;">NumArray numArray = new NumArray([1,2,3]);
numArray.sumRange(0, 2); // return 6 (1 + 2 + 3)</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The problem focuses on optimizing the time complexity of `sumRange`. The brute-force approach has a time complexity of O(n) per query. The prefix sum technique significantly improves this to O(1) per query by pre-calculating sums. Edge cases include empty input arrays and queries with left and right indices outside of bounds, however, the problem description guarentees that left &lt= right.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/range-sum-query-mutable/>Range Sum Query - Mutable</a> <span style="font-size:14px; color:#888;">Medium/Hard</span></h3>
  <p>Given an integer array `nums`, handle multiple queries of the following types:

1.  `update(index, val)`: Updates the value of `nums[index]` to `val`.
2.  `sumRange(left, right)`: Returns the sum of the elements of `nums` between indices `left` and `right` (inclusive).

Implement the `NumArray` class to support these operations.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>The brute-force approach involves directly implementing the `update` and `sumRange` operations as described in the problem statement. For `update`, we simply modify the element at the given index. For `sumRange`, we iterate through the specified range and calculate the sum.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class NumArray {
public:
    vector&lt;int&gt; nums;

    NumArray(vector&lt;int&gt;& nums) {
        this-&gt;nums = nums;
    }

    void update(int index, int val) {
        nums[index] = val;
    }

    int sumRange(int left, int right) {
        int sum = 0;
        for (int i = left; i &lt;= right; ++i) {
            sum += nums[i];
        }
        return sum;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(1) for `update`, O(N) for `sumRange`, where N is the size of the input array.  The `sumRange` function has a linear time complexity in the size of the array due to iteration. | <b>Space Complexity:</b> O(1). The space complexity is constant, as we only use a few extra variables regardless of the size of the array.  The input array itself is considered as an input and not extra space usage.</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Segment Tree</h5>
  <p>A segment tree is a tree-based data structure that allows for efficient querying and updating of array elements. Each node in the segment tree represents a range of elements in the input array. The root node represents the entire array, and the children of a node represent subranges of the array. The leaves of the tree represent individual elements of the array.  `update` operation updates the value at a given index and propagates the changes to all the nodes that contain that index in their range.  `sumRange` operation efficiently calculates the sum of a range by traversing the tree and summing the values of the nodes that fully or partially cover the range. This reduces the time complexity from O(N) in the brute-force to O(logN).</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class NumArray {
public:
    vector&lt;int&gt; segmentTree;
    vector&lt;int&gt; nums;
    int n;

    NumArray(vector&lt;int&gt;& nums) {
        this-&gt;nums = nums;
        n = nums.size();
        segmentTree.resize(4 * n);
        buildSegmentTree(0, 0, n - 1);
    }

    void buildSegmentTree(int node, int start, int end) {
        if (start == end) {
            segmentTree[node] = nums[start];
        } else {
            int mid = start + (end - start) / 2;
            buildSegmentTree(2 * node + 1, start, mid);
            buildSegmentTree(2 * node + 2, mid + 1, end);
            segmentTree[node] = segmentTree[2 * node + 1] + segmentTree[2 * node + 2];
        }
    }

    void update(int index, int val) {
        updateSegmentTree(0, 0, n - 1, index, val);
        nums[index] = val; // Also update the original array for consistency
    }

    void updateSegmentTree(int node, int start, int end, int index, int val) {
        if (start == end) {
            segmentTree[node] = val;
        } else {
            int mid = start + (end - start) / 2;
            if (index &lt;= mid) {
                updateSegmentTree(2 * node + 1, start, mid, index, val);
            } else {
                updateSegmentTree(2 * node + 2, mid + 1, end, index, val);
            }
            segmentTree[node] = segmentTree[2 * node + 1] + segmentTree[2 * node + 2];
        }
    }

    int sumRange(int left, int right) {
        return querySegmentTree(0, 0, n - 1, left, right);
    }

    int querySegmentTree(int node, int start, int end, int left, int right) {
        if (right &lt; start || left &gt; end) {
            return 0;
        }
        if (left &lt;= start &amp;&amp; end &lt;= right) {
            return segmentTree[node];
        }
        int mid = start + (end - start) / 2;
        int leftSum = querySegmentTree(2 * node + 1, start, mid, left, right);
        int rightSum = querySegmentTree(2 * node + 2, mid + 1, end, left, right);
        return leftSum + rightSum;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(log N) for both `update` and `sumRange` operations, where N is the size of the input array. Building the segment tree takes O(N) time initially. | <b>Space Complexity:</b> O(N), for the segment tree itself.</p>
  <h5>‚û§ Binary Indexed Tree (Fenwick Tree)</h5>
  <p>A Binary Indexed Tree (BIT), also known as a Fenwick tree, is another data structure that allows for efficient prefix sum calculations and element updates.  It uses the binary representation of indices to store sums, allowing for O(log N) update and range sum operations. The update operation updates all relevant nodes in the tree by adding the difference between the new value and the old value. The sumRange operation calculates the sum up to a given index and then calculates the sum between two ranges by subtracting the sum up to the left-1 index from the sum up to the right index.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

class NumArray {
public:
    vector&lt;int&gt; bit;
    vector&lt;int&gt; nums;
    int n;

    NumArray(vector&lt;int&gt;& nums) {
        this-&gt;nums = nums;
        n = nums.size();
        bit.resize(n + 1, 0);
        for (int i = 0; i &lt; n; ++i) {
            updateBIT(i, nums[i]);
        }
    }

    void update(int index, int val) {
        int diff = val - nums[index];
        nums[index] = val;
        updateBIT(index, diff);
    }

    void updateBIT(int index, int val) {
        index++; // BIT uses 1-based indexing
        while (index &lt;= n) {
            bit[index] += val;
            index += index &amp; -index; //Move to the parent node
        }
    }

    int sumRange(int left, int right) {
        return getSum(right) - getSum(left - 1);
    }

    int getSum(int index) {
        int sum = 0;
        index++; // BIT uses 1-based indexing
        while (index &gt; 0) {
            sum += bit[index];
            index -= index &amp; -index; // Move to the parent
        }
        return sum;
    }
};
</code></pre>
  <p><b>Time Complexity:</b> O(log N) for both `update` and `sumRange` operations. | <b>Space Complexity:</b> O(N), for the BIT (Fenwick Tree) itself.</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["NumArray","sumRange","update","sumRange"]
[[[1,3,5]],[0,2],[1,2],[0,2]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[null,9,null,7]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">NumArray numArray = new NumArray([1, 3, 5]);
numArray.sumRange(0, 2); // return 1 + 3 + 5 = 9
numArray.update(1, 2);
numArray.sumRange(0, 2); // return 1 + 2 + 5 = 7</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">["NumArray","sumRange","update","sumRange","update","sumRange"]
[[[1,2,3,4,5]],[0,2],[0,5],[0,3],[4,10],[0,4]]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[null,6,null,15,null,20]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">NumArray numArray = new NumArray([1, 2, 3, 4, 5]);
numArray.sumRange(0, 2); // return 1 + 2 + 3 = 6
numArray.update(0, 5);
numArray.sumRange(0, 3); // return 5 + 2 + 3 + 4 = 14
numArray.update(4, 10);
numArray.sumRange(0, 4); // return 5 + 2 + 3 + 4 + 10 = 24</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The choice of data structure depends on the specific requirements of the problem, specifically how frequently the update operation is called versus how frequently the range sum query is performed. If there are many updates and few range sum queries, then the Fenwick Tree or Segment Tree would be more efficient than brute-force.</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/count-of-smaller-numbers-after-self/>Count of Smaller Numbers After Self</a> <span style="font-size:14px; color:#888;">Medium/Hard</span></h3>
  <p>Given an integer array `nums`, return an array `counts` where `counts[i]` is the number of smaller elements to the right of `nums[i]`. For example, if `nums = [5,2,6,1]`, then the output should be `[2,1,1,0]`. This is because:
- To the right of 5 there are 2 smaller elements (2 and 1).
- To the right of 2 there is 1 smaller element (1).
- To the right of 6 there is 1 smaller element (1).
- To the right of 1 there are 0 smaller elements.</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through the array. For each element, iterate through the remaining elements to the right and count the smaller ones.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

vector&lt;int&gt; countSmallerBruteForce(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    vector&lt;int&gt; counts(n, 0);

    for (int i = 0; i &lt; n; ++i) {
        for (int j = i + 1; j &lt; n; ++j) {
            if (nums[j] &lt; nums[i]) {
                counts[i]++;
            }
        }
    }
    return counts;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) | <b>Space Complexity:</b> O(n)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Merge Sort with Modification</h5>
  <p>Modify the merge sort algorithm. During the merge step, count the smaller elements that are to the right of each element. Maintain an index to track the original positions of elements.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

void merge(vector&lt;pair&lt;int, int&gt;&gt;&amp; nums, int left, int mid, int right, vector&lt;int&gt;&amp; counts, vector&lt;pair&lt;int, int&gt;&gt;&amp; temp) {
    int i = left, j = mid + 1, k = left;
    while (i &lt;= mid &amp;&amp; j &lt;= right) {
        if (nums[i].first &lt;= nums[j].first) {
            counts[nums[i].second] += (j - mid - 1);
            temp[k++] = nums[i++];
        } else {
            temp[k++] = nums[j++];
        }
    }
    while (i &lt;= mid) {
        counts[nums[i].second] += (j - mid - 1);
        temp[k++] = nums[i++];
    }
    while (j &lt;= right) {
        temp[k++] = nums[j++];
    }
    for (int l = left; l &lt;= right; ++l) {
        nums[l] = temp[l];
    }
}

void mergeSort(vector&lt;pair&lt;int, int&gt;&gt;&amp; nums, int left, int right, vector&lt;int&gt;&amp; counts, vector&lt;pair&lt;int, int&gt;&gt;&amp; temp) {
    if (left &lt; right) {
        int mid = left + (right - left) / 2;
        mergeSort(nums, left, mid, counts, temp);
        mergeSort(nums, mid + 1, right, counts, temp);
        merge(nums, left, mid, right, counts, temp);
    }
}

vector&lt;int&gt; countSmallerMergeSort(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    vector&lt;int&gt; counts(n, 0);
    vector&lt;pair&lt;int, int&gt;&gt; nums_with_indices(n);
    for (int i = 0; i &lt; n; ++i) {
        nums_with_indices[i] = {nums[i], i};
    }

    vector&lt;pair&lt;int, int&gt;&gt; temp(n);
    mergeSort(nums_with_indices, 0, n - 1, counts, temp);
    return counts;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log n) | <b>Space Complexity:</b> O(n)</p>
  <h5>‚û§ Binary Search Tree (BST)</h5>
  <p>Build a BST from right to left.  For each element, insert it into the BST, and count smaller elements encountered during insertion.</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;

using namespace std;

struct Node {
    int val;
    int count;
    int leftCount;
    Node* left;
    Node* right;
    Node(int x) : val(x), count(1), leftCount(0), left(nullptr), right(nullptr) {}
};

vector&lt;int&gt; countSmallerBST(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    vector&lt;int&gt; counts(n, 0);
    Node* root = nullptr;

    for (int i = n - 1; i &gt;= 0; --i) {
        Node* current = new Node(nums[i]);
        Node* node = root;
        int smallerCount = 0;

        while (node) {
            if (current-&gt;val &gt; node-&gt;val) {
                smallerCount += node-&gt;leftCount + node-&gt;count;
                if (node-&gt;right == nullptr) {
                    node-&gt;right = current;
                    break;
                }
                node = node-&gt;right;
            } else if (current-&gt;val &lt; node-&gt;val) {
                node-&gt;leftCount++;
                if (node-&gt;left == nullptr) {
                    node-&gt;left = current;
                    break;
                }
                node = node-&gt;left;
            } else {
                smallerCount += node-&gt;leftCount;
                node-&gt;count++;
                break;
            }
        }
        counts[i] = smallerCount;
        if (!root) {
            root = current;
        }
    }
    return counts;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log n) on average, O(n^2) in worst case (if the tree becomes skewed). | <b>Space Complexity:</b> O(n)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [5,2,6,1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[2,1,1,0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there are 0 smaller elements.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [-1,-1]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[0,0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">Both -1s have no smaller elements to their right.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [5, 5, 5, 5]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">[0, 0, 0, 0]</td>
        <td style="border: 1px solid #ccc; padding: 6px;">No numbers are smaller to the right in this case.</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>The merge sort approach and BST approach offer better time complexity than the brute-force method. The BST approach is generally good but can degrade to O(n^2) in the worst case if the input array is already sorted.  Merge sort is generally the more stable option and is guaranteed O(n log n).</p>
</div>
<hr style="margin: 40px 0;">
<div class="problem-block">
  <h3><a href=https://leetcode.com/problems/count-of-range-sum/>Count of Range Sum</a> <span style="font-size:14px; color:#888;">Medium/Hard</span></h3>
  <p>Given an integer array nums and two integers lower and upper, return the number of range sums that lie in the closed interval [lower, upper].

Range sum S(i, j) is defined as the sum of the elements of nums between indices i and j (i ‚â§ j), inclusive.

For example, given nums = [-2, 5, -1], lower = -2, upper = 2,
Return 3.
The three range sums are : [‚àí2, 0], [‚àí2, 5], [‚àí2, 5, ‚àí1]</p>

  <h4>üß† Brute Force Approach</h4>
  <p>Iterate through all possible subarrays and calculate their sums. Check if each sum falls within the range [lower, upper].</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int countRangeSum_bruteForce(vector&lt;int&gt;&amp; nums, int lower, int upper) {
    int n = nums.size();
    int count = 0;

    for (int i = 0; i &lt; n; ++i) {
        long long current_sum = 0;
        for (int j = i; j &lt; n; ++j) {
            current_sum += nums[j];
            if (current_sum &gt;= lower &amp;&amp; current_sum &lt;= upper) {
                count++;
            }
        }
    }
    return count;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n^2) | <b>Space Complexity:</b> O(1)</p>

  <h4>üöÄ Optimal Approaches</h4>
  <h5>‚û§ Merge Sort with Prefix Sums</h5>
  <p>Utilize the merge sort algorithm.  During the merge step, efficiently count the range sums using prefix sums. The prefix sums are calculated for each subarray and the merge sort structure allows efficiently finding sums in the range [lower, upper].</p>
  <pre><code class="language-python">#include &ltbits/stdc++.h&gt;
using namespace std;

int countRangeSum_mergeSort(vector&lt;int&gt;&amp; nums, int lower, int upper) {
    int n = nums.size();
    vector&lt;long long&gt; prefix_sums(n + 1, 0);
    for (int i = 0; i &lt; n; ++i) {
        prefix_sums[i + 1] = prefix_sums[i] + nums[i];
    }

    return mergeSort(prefix_sums, 0, n, lower, upper);
}

int mergeSort(vector&lt;long long&gt;&amp; prefix_sums, int left, int right, int lower, int upper) {
    if (left == right) {
        return 0;
    }

    int mid = left + (right - left) / 2;
    int count = mergeSort(prefix_sums, left, mid, lower, upper) + mergeSort(prefix_sums, mid + 1, right, lower, upper);

    int j = mid + 1, k = mid + 1;
    for (int i = left; i &lt;= mid; ++i) {
        while (j &lt;= right &amp;&amp; prefix_sums[j] - prefix_sums[i] &lt; upper) {
            j++;
        }
        while (k &lt;= right &amp;&amp; prefix_sums[k] - prefix_sums[i] &lt;= lower -1) {
            k++;
        }
        count += (j - k);
    }

    vector&lt;long long&gt; sorted;
    int i = left, l = mid + 1;
    while (i &lt;= mid || l &lt;= right) {
        if (i &lt;= mid &amp;&amp; (l &gt; right || prefix_sums[i] &lt;= prefix_sums[l])) {
            sorted.push_back(prefix_sums[i++]);
        } else {
            sorted.push_back(prefix_sums[l++]);
        }
    }

    for (int p = 0; p &lt; sorted.size(); ++p) {
        prefix_sums[left + p] = sorted[p];
    }

    return count;
}
</code></pre>
  <p><b>Time Complexity:</b> O(n log n) | <b>Space Complexity:</b> O(n)</p>
  <h4>üîç Examples</h4>
  <table style="border-collapse: collapse; width: 100%;">
    <thead>
      <tr style="background: #f0f0f0;">
        <th style="border: 1px solid #ccc; padding: 6px;">Input</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Output</th>
        <th style="border: 1px solid #ccc; padding: 6px;">Explanation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [-2,5,-1], lower = -2, upper = 2</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The range sums are: [-2], [5, -1], [-2, 5, -1]. The sums that fall within the range [-2, 2] are: -2, 4, 2. So, 3 valid sums.</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [0], lower = 0, upper = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">1</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The only range sum is 0, and it is in the range [0, 0].</td>
      </tr>
      <tr>
        <td style="border: 1px solid #ccc; padding: 6px;">nums = [-2147483647,0,2147483647,-2147483646], lower = -1, upper = 0</td>
        <td style="border: 1px solid #ccc; padding: 6px;">3</td>
        <td style="border: 1px solid #ccc; padding: 6px;">The valid sums are 0, -2147483646, and -2147483647+0 = -2147483647 is not valid as it is less than -1</td>
      </tr>
    </tbody>
  </table>

  <h4>üìù Notes</h4>
  <p>1. Consider potential integer overflow issues, especially when calculating sums.  Use `long long` to prevent it.
2. The Merge Sort approach effectively reduces the time complexity by organizing and counting at the merge step.
3. Edge cases include empty arrays or arrays with only one element.
4. The Merge Sort approach is the most efficient for solving this problem.</p>
</div>
<hr style="margin: 40px 0;">
</body>
</html>